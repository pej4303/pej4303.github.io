{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1138 난이도 : 실버2 2. 내 풀이 방법 시도1 접근 방법 입력 받기 index랑 사람수를 같이 저장할 클래스 선언 list에 넣기 사람수를 기준으로 오름차순 출력 문제점 단순 오름차순 정렬로는 사람 수 조건을 모두 만족하기 어렵다. 자리 배치를 하면서 현재 배…","fields":{"slug":"/archive/algorithm/24/"},"frontmatter":{"date":"June 12, 2025","title":"[백준] 한 줄로 서기 Java","description":"한 줄로 서기 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/1138](https://www.acmicpc.net/problem/1138)\n+ 난이도 : 실버2\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 입력 받기\n    + index랑 사람수를 같이 저장할 클래스 선언\n    + list에 넣기\n    + 사람수를 기준으로 오름차순 \n    + 출력\n+ 문제점\n    + 단순 오름차순 정렬로는 사람 수 조건을 모두 만족하기 어렵다.\n    + 자리 배치를 하면서 현재 배열 상태를 고려해야 하기 때문에 이 방식은 논리적으로 성립하지 않음\n    + **정렬보다는 \"자리 찾기\" 방식으로 풀어야 한다.**\n\n### 시도2\n+ 접근 방법\n    + 입력 받기\n    + 결과를 저장할 배열 result 선언\n    + N까지 반복\n        + arr[i-1] → 왼쪽에 있어야 할 키 큰 사람 수 = peopleCnt\n        + result 배열에서 다음을 반복:\n            + 0(빈칸)을 만날 때마다 cnt 변수 값 증가\n            + cnt와 peopleCnt이 같으면 빈칸 위치에 i번 사람을 배치\n        + 한번 배치하면 루프 종료\n    + 출력\n+ 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            // 사람의 수\n            int n = Integer.parseInt(br.readLine());\n            // 배열\n            StringTokenizer st = new StringTokenizer(br.readLine());\n\n            int[] arr = new int[n];\n            for (int i=0; i<arr.length; i++) {\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n\n            int[] result = new int[n];\n            for (int i=0; i<n; i++) {\n                int peopleCnt = arr[i]; // 왼쪽에 있어야 할 사람 수\n                int cnt = 0;\n\n                for (int j=0; j<n; j++) {\n                    // 빈 칸이면 키 큰 사람 수를 셀 수 있음\n                    if (result[j] == 0) {\n                        if (cnt == peopleCnt) {\n                            result[j] = i + 1; // 사람 번호는 i+1\n                            break;\n                        }\n                        cnt++;\n                    }\n                }\n            }\n\n            Arrays.stream(result).forEach(i -> System.out.print(String.format(\"%d \", i)) );\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음에는 사람 번호와 왼쪽에 있어야 하는 사람 수를 클래스로 묶어 리스트에 저장하고 이 리스트를 정렬해서 처리하면 될 거라고 생각했다. 하지만 검색해보니 단순 정렬만으로는 모든 사람의 조건을 만족시키는 순서를 만들기 어렵다는 걸 깨달았다.\n\n+ 🛠 해결 과정\n검색을 통해 문제 해결의 핵심이 \"정렬\"이 아니라 \"자리 찾기\"라는 것을 알게 되었고 사람 번호를 1번부터 N번까지 순서대로 보면서 자기가 원하는 조건을 만족하는 자리를 result 배열에서 직접 찾아가는 방식으로 구현했다.\n배열의 빈칸을 순회하면서 카운트를 세고 자신보다 키 큰 사람이 pepoleCnt명만큼 있을 때 그 자리에 자신을 넣는 방식은 생각보다 간단하면서도 효과적이었다.\n\n+ ⚠ 개선할 점\n처음엔 구현 아이디어가 명확히 떠오르지 않아 검색에 의존했다. 앞으로는 문제를 더 다양한 관점에서 바라보고 조건 하나하나를 코드 흐름으로 바꾸는 연습을 더 해야겠다. \n```\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/42889 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 Stage 클래스 선언, Stage 타입의 List 선언 스테이지 개수 만큼 for문 수행 실패율 로직 처리 해당 index와 동일한 번호가 있으면 실패율…","fields":{"slug":"/archive/algorithm/23/"},"frontmatter":{"date":"June 11, 2025","title":"[프로그래머스] 실패율 Java","description":"실패율 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/42889](https://school.programmers.co.kr/learn/courses/30/lessons/42889)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + Stage 클래스 선언, Stage 타입의 List 선언\n    + 스테이지 개수 만큼 for문 수행\n    + 실패율 로직 처리\n        + 해당 index와 동일한 번호가 있으면 실패율 계산\n        + 없다면 도달한 유저가 없는것으로 실패율을 0으로 정의\n        + list에 담기\n    + list 정렬\n        + 실패율 내림차순 같으면 스테이지 오름차순\n    + list -> int[] 변환\n    + answer 반환\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        class Stage {\n            int index;\n            double rate;\n\n            Stage(int index, double rate) {\n                this.index = index;\n                this.rate = rate;\n            }\n        }\n\n        public int[] solution(int N, int[] stages) {\n            int[] answer = {};\n                \n            List<Stage> list = new ArrayList<>();\n            // 1. 스테이지 개수 만큼 for문 수행\n            for (int i=1; i<=N; i++) {\n                // 실패율 계산\n                double rate = calc(stages, i);\n                // list에 담기\n                list.add(new Stage(i, rate));\n            }\n                \n            // 3. list 정렬\n            // 실패율 내림차순, 같으면 스테이지 오름차순\n            Collections.sort(list, (a, b) -> {\n                    if (Double.compare(b.rate, a.rate) == 0) {\n                        return a.index - b.index;   // 스테이지 번호 오름차순\n                    } else {\n                        return Double.compare(b.rate, a.rate);  // 실패율 내림차순\n                    }\n            });\n            \n                \n            // 4. list -> int[] 변환\n            answer = list.stream().mapToInt(stage -> stage.index).toArray();\n                \n            return answer;\n        }\n        \n        private double calc(int[] stages, int stage) {\n            int fail = 0;\n            int sucess = 0;\n\n            for (int i=0; i<stages.length; i++) {\n                if (stages[i] >= stage) { // 해당 스테이지에 도달한 사용자\n                    sucess++;\n                }\n                if (stages[i] == stage) { // 해당 스테이지에서 실패한 사용자\n                    fail++;\n                }\n            }\n\n            if (sucess == 0) {\n                return 0.0;\n            } else {\n                return (double) fail / sucess;\n            }\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 처음 읽고 대략적인 구현 방법은 금방 떠올랐다. 하지만 실패율 계산 로직과 정렬 기준 구현에서 조금 막혔다. 특히 실패율을 정확히 계산하고 이를 기준으로 스테이지 번호까지 고려하여 정렬하는 부분이 생각보다 까다로웠다.\n\n+ 🛠 해결 과정\n실패율은 각 스테이지에 도달한 사용자 수를 기준으로 해당 스테이지를 클리어하지 못한 사용자 수의 비율로 계산하면 됐다. 이때 도달한 유저가 0명인 경우 실패율은 0으로 처리해야 한다는 조건도 주의 깊게 반영했다. 정렬은 처음에는 TreeMap을 사용하면 자동 정렬이 되지 않을까 생각했지만 TreeMap은 key 기준으로만 정렬되기 때문에 실패율이 같은 경우 스테이지 번호 기준으로 정렬하는 조건을 만족시키기 어려웠다. 그래서 실패율과 스테이지 번호를 함께 담는 Stage 클래스를 만들고 Collections.sort()를 사용해 커스텀 정렬 로직을 적용했다.\n이 방법이 훨씬 직관적이고 조건을 세부적으로 제어할 수 있어서 적합하다는 것을 알게 되었다.\n\n+ ⚠ 개선할 점\n정렬 로직은 여전히 자주 헷갈리는 부분이다. 특히 다중 조건(실패율 내림차순, 스테이지 번호 오름차순) 정렬을 구현할 때 매번 혼란이 생기곤 한다.\n앞으로는 Comparator.comparing(), thenComparing() 같은 메서드를 활용해 가독성을 높이고 명확한 정렬 기준을 설정하는 연습이 더 필요하다고 느꼈다.\n```java\n-- Comparator 체이닝 방식\n-- 참고로 해당 메서드를 쓰려면 Stage 클래스에 getter가 필요하다.\nlist.sort(\n    Comparator\n        // 실패율을 기준으로 내림차순 정렬\n        .comparingDouble(Stage::getRate).reversed()\n        // 실패율이 같을 경우 스테이지 번호 기준으로 오름차순 정렬\n        .thenComparingInt(Stage::getIndex)\n);\n```\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/340199 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 minBill > minWallet 이거나 maxBill > maxWallet인 동안만 while문 반복 bill[0]과 bill[1]를 비교하여 큰 값…","fields":{"slug":"/archive/algorithm/22/"},"frontmatter":{"date":"June 10, 2025","title":"[프로그래머스] [PCCE 기출문제] 9번 / 지폐 접기 Java","description":"[PCCE 기출문제] 9번 / 지폐 접기 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/340199](https://school.programmers.co.kr/learn/courses/30/lessons/340199)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + minBill > minWallet 이거나 maxBill > maxWallet인 동안만 while문 반복\n    + bill[0]과 bill[1]를 비교하여 큰 값을 2로 나누고 나머지를 버림\n    + minBill, maxBill 값 갱신\n    + answer 값 증가\n    + answer 반환\n+ 소스 코드\n    ```java\n    class Solution {\n        public int solution(int[] wallet, int[] bill) {\n            int answer = 0;\n        \n            int minBill = Math.min(bill[0], bill[1]);\n            int maxBill = Math.max(bill[0], bill[1]);\n            int minWallet = Math.min(wallet[0], wallet[1]);\n            int maxWallet = Math.max(wallet[0], wallet[1]);\n            \n            // 1. 반복문을 이용해 bill의 작은 값이 wallet의 작은 값 보다 크거나 bill의 큰 값이 wallet의 큰 값 보다 큰 동안 아래 과정을 반복합니다.\n            while (minBill > minWallet || maxBill > maxWallet) {\n                if (bill[0] > bill[1]) {\n                    // 2-1. bill[0]이 bill[1]보다 크다면 bill[0]을 2로 나누고 나머지는 버립니다.\n                    bill[0] /= 2;\n                } else {\n                    // 2-2. 그렇지 않다면 bill[1]을 2로 나누고 나머지는 버립니다.    \n                    bill[1] /= 2;\n                }\n                // 최소값, 최대값 갱신\n                minBill = Math.min(bill[0], bill[1]);\n                maxBill = Math.max(bill[0], bill[1]);\n                \n                // 2-3. answer을 1 증가시킵니다.\n                answer++;\n                \n            }\n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제 지문에 구현 방식이 친절하게 설명되어 있어 그대로 따라가며 구현하기만 하면 되는 문제였다.\n\n+ 🛠 해결 과정\n반복문을 이용해 bill의 작은 값이 wallet의 작은 값 보다 크거나 bill의 큰 값이 wallet의 큰 값 보다 큰 동안 과정을 반복하면 된다. bill[0]이 bill[1]보다 크다면 bill[0]을 2로 나누고 그렇지 않다면 bill[1]을 2로 나누고 나머지는 버린다. 그리고 bill의 작은 값, bill의 큰 값을 갱신해주고 answer 값을 증가시킨다.\n\n+ ✅ 잘한 점\n제한 시간 30분 내에 문제를 정확히 해결했다.\n\n+ ⚠ 개선할 점\n처음에 \"나머지를 버린다\"는 표현을 잘못 이해해서 Math.ceil()을 사용하는 실수를 했다. 하지만 정수형 나눗셈에서는 소수점 이하가 자동으로 버려지므로 단순히 /= 2만 해주면 된다. 기본적인 연산 동작에 대한 이해를 다시 한번 상기하게 된 계기였다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/17681 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 문자열 연산을 많이 해야 하니 StringBuilder 사용 arr1, arr2를 순회 각 항목을 이진수로 변환 - Integer.toBinaryStrin…","fields":{"slug":"/archive/algorithm/21/"},"frontmatter":{"date":"June 09, 2025","title":"[프로그래머스] [1차] 비밀지도 Java","description":"[1차] 비밀지도 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/17681](https://school.programmers.co.kr/learn/courses/30/lessons/17681)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 문자열 연산을 많이 해야 하니 StringBuilder 사용\n    + arr1, arr2를 순회\n        + 각 항목을 이진수로 변환 - Integer.toBinaryString\n        + 각 항목에 '1'이 하나라도 있으면 '#', 둘다 '0'이면 공백으로 표시\n    + answer 반환\n+ 소스 코드\n    ```java\n    class Solution {\n        public String[] solution(int n, int[] arr1, int[] arr2) {\n            String[] answer = new String[n];\n            \n            for (int i=0; i<arr1.length; i++) {\n                // - 각 항목을 이진수로 변환 - Integer.toBinaryString\n                String tmpNum1 = String.format(\"%\" + n + \"s\", Integer.toBinaryString(arr1[i])).replace(' ', '0');\n                String tmpNum2 = String.format(\"%\" + n + \"s\", Integer.toBinaryString(arr2[i])).replace(' ', '0');\n                // System.out.println( tmpNum );\n                \n                char[] c1 = tmpNum1.toCharArray();\n                char[] c2 = tmpNum2.toCharArray();\n                \n                // System.out.println( createStr(c1, c2) );\n                answer[i] = createStr(c1, c2);\n                \n            }\n            \n            return answer;\n        }\n        \n        private String createStr(char[] c1, char[] c2) {\n            StringBuilder sb = new StringBuilder();\n            \n            for (int i=0; i<c1.length; i++) {\n                // 각 항목에 '1'이 하나라도 있으면 '#', 둘다 '0'이면 공백으로 표시\n                if ( c1[i] == '0' && c2[i] == '0' ) {\n                    sb.append(\" \");\n                } else {\n                    sb.append(\"#\");\n                }\n            }\n            \n            return sb.toString();\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 각 항목값을 비교하여 하나라도 1이면 '#', 둘 다 0이면 공백 ' '으로 표시하면 되겠다는 아이디어가 떠올랐다. 예제를 보며 예상한 방식이 정답과 일치하는지 확인했고 해당 흐름대로 구현하기로 결정했다.\n\n+ 🛠 해결 과정\narr1, arr2 배열을 순회하며 각 요소를 십진수에서 이진수로 변환하였다. 그 후 n자리로 자릿수를 맞춘 이진수 문자열을 char[]로 비교하여 각 자릿수에서 두 값이 모두 '0'이면 공백, 그렇지 않으면 '#'을 출력하도록 처리했다.\n\n+ ✅ 잘한 점\n제한 시간 30분 내에 문제를 정확히 해결했다. 예전에는 이 문제를 보고 구현 방법이 떠오르지 않았는데 이번에는 전체 흐름을 파악하고 스스로 해결할 수 있었다는 점에서 성장을 느낄 수 있었다.\n\n+ ⚠ 개선할 점\n십진수를 이진수로 변환하는 메소드(Integer.toBinaryString)가 바로 떠오르지 않아 검색을 통해 확인했다. 변환 후 이진수의 자릿수가 n보다 짧을 경우 앞에 0을 채우는 처리가 처음엔 다소 헷갈렸다.\n추후 진법 변환이나 문자열 포맷팅 관련 문제에서 빠르게 대응할 수 있도록 관련 메서드들을 더 익숙하게 익힐 필요가 있다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/42586 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 process 라는 클래스를 생성, List 타입도 하나 생성 Stack 타입으로 생성하여 작업 진도와 개발 속도를 함께 체크 progresses 배열을 …","fields":{"slug":"/archive/algorithm/20/"},"frontmatter":{"date":"June 07, 2025","title":"[프로그래머스] 기능 개발 Java","description":"기능 개발 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/42586](https://school.programmers.co.kr/learn/courses/30/lessons/42586)\n+ 난이도 : 레벨2\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + process 라는 클래스를 생성, List<Integer> 타입도 하나 생성\n    + Stack<Process> 타입으로 생성하여 작업 진도와 개발 속도를 함께 체크\n    + progresses 배열을 스택으로 변환 \n    + 스택을 순회하면서 해당값이 100이 되면 pop()\n        + 그 다음값도 100이 되는지 체크\n    + answer 반환\n+ 문제점\n    + 문제의 진행 순서는 앞에서부터 순서대로 처리되어야 하며 `Stack`(후입선출)은 부적절하다.\n    + 선입선출(FIFO)에 해당하는 Queue 또는 일반 for 순회가 더 적절하다.\n    + 작업 완료 순서를 정확히 유지하기 어렵다.\n    + 불필요한 클래스 생성 및 자료구조 사용으로 복잡도 증가한다.\n\n### 시도2\n+ 접근 방법\n    + 각 기능이 완료되기까지 걸리는 날짜 계산 - for문\n    + 로직 처리\n        + 첫 번째 작업의 완료일을 기준 - pivot\n        + 순회하며 pivot보다 작거나 같으면 같은 날 배포\n        + 더 크면 새로운 배포 시작\n    + answer 반환\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int[] solution(int[] progresses, int[] speeds) {\n            int[] answer = {};\n            \n            int[] days = new int[progresses.length];\n            List<Integer> list = new ArrayList<>();\n            \n            // 1. 각 기능이 완료되기까지 걸리는 날짜 계산 - for문\n            for (int i=0; i<days.length; i++) {\n                days[i] = (int) Math.ceil( (100.0 - progresses[i]) / speeds[i]);\n\n            }\n            // System.out.println( Arrays.toString(days) );\n            \n            // 2. 로직 처리\n            int pivot = days[0];\n            int cnt = 1;\n\n            for (int i=1; i<days.length; i++) {\n                if (days[i] <= pivot) {\n                    // 순회하며 pivot보다 작거나 같으면 같은 날 배포\n                    cnt++;\n                } else {\n                    // 더 크면 새로운 배포 시작\n                    list.add(cnt);\n\n                    // 기준점 변경, cnt 초기화\n                    pivot = days[i];\n                    cnt = 1;\n                }\n            }\n            \n            // 마지막 배포 그룹 담기\n            list.add(cnt);\n            \n            // List -> 배열로 변환\n            answer = list.stream().mapToInt(Integer::intValue).toArray();\n            \n            // 3. answer 반환\n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n초기에는 Process 클래스를 만들고 Stack을 활용하는 구조로 설계했지만 기능이 앞에서부터 순차적으로 배포된다는 문제 조건을 간과해 적절하지 않은 선택이었다. 이후 각 작업의 완료까지 남은 일수를 미리 계산하고 앞선 작업을 기준으로 같은 날 배포할 수 있는 작업들을 묶는 방식으로 접근해 문제를 해결했다.\n\n+ 🛠 해결 과정\nMath.ceil()을 사용해 각 기능의 완료일을 정확하게 계산하고 기준일(pivot)보다 빠르거나 같은 작업은 함께 배포했다. 이후 더 늦게 완료되는 작업이 나오면 배포를 나누고 해당 작업을 새로운 기준일로 설정했다. 각 배포 그룹의 개수를 리스트에 저장한 후 최종적으로 배열로 변환해 반환했다.\n\n+ ⚠ 개선할 점\n문제의 **처리 순서(선입선출인지 후입선출인지)**를 명확히 파악한 뒤, 이에 맞는 자료구조를 선택해야 한다. 또한, 꼭 자료구조를 사용할 필요가 있는지, 단순한 반복문으로 해결 가능한지도 먼저 고려해보는 습관을 들이자. 정수 나눗셈에서는 double형으로 형 변환 후 Math.ceil()을 사용하는 방식이 정확한 계산을 위해 필요하다는 점도 주의해야 한다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/133502 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 ingredient 배열을 문자열(str)로 변환 로 치환이 될때마다 answer 증가 - while문 이용 answer 반환 문제점 테스트 케이스는 통…","fields":{"slug":"/archive/algorithm/19/"},"frontmatter":{"date":"June 05, 2025","title":"[프로그래머스] 햄버거 만들기 Java","description":"햄버거 만들기 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/133502](https://school.programmers.co.kr/learn/courses/30/lessons/133502)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + ingredient 배열을 문자열(str)로 변환\n    + `1231`로 치환이 될때마다 answer 증가 - while문 이용\n    + answer 반환\n+ 문제점\n    + 테스트 케이스는 통과 하였으나 제출까지는 통과하지 못함\n    + 문자열 치환이 비효율적이다.\n        + String.replace(\"1231\", \"\")는 내부적으로 문자열 전체를 한 번 순회한다. → O(N)\n        + \"1231\"이 많다면 위 과정을 여러 번 반복한다. → O(N * \"1231\" 등장 횟수)\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int solution(int[] ingredient) {\n            int answer = 0;\n            \n            // 1. ingredient 배열을 문자열로 변환\n            StringBuilder sb = new StringBuilder();\n            for (int n : ingredient) {\n                sb.append(String.valueOf(n));\n            }\n            \n            // System.out.println( sb );\n            \n            String str = sb.toString();\n            \n            // 2. 1231로 치환이 될때마다 answer 증가 - while문 이용\n            while (true) {\n                if (str.indexOf(\"1231\") == -1) {\n                    break;\n                }\n                str = str.replace(\"1231\", \"\");\n                answer++;\n            }\n            \n            return answer;\n        }\n    }\n    ```\n### 시도2\n+ 접근 방법\n    + 스택 생성\n    + ingredient 배열을 순회\n        + 각 원소를 넣으면서 스택의 마지막 4개의 값이 1231인지 체크하여 맞으면 pop()을 4번 수행, answer 증가\n    + answer 반환\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int solution(int[] ingredient) {\n            int answer = 0;\n            \n            // 1. 스택 생성\n            Stack<Integer> stack = new Stack<>();\n            \n            // 2. ingredient 배열을 순회\n            for (int num : ingredient) {\n                // 각 원소를 넣으면서\n                stack.push(num);\n                \n                int size = stack.size();\n                if (stack.size() >= 4) {\n                // 스택의 마지막 4개의 값이 1231인지 체크하여 맞으면\n                if ( stack.get(size-4) == 1 &&\n                        stack.get(size-3) == 2 &&\n                        stack.get(size-2) == 3 &&\n                        stack.get(size-1) == 1 ) {\n                    \n                    // pop()을 4번 수행\n                    for (int i=0; i<4; i++) {\n                        stack.pop();\n                    }\n                    // answer 증가\n                    answer++;\n                }\n                }\n            }\n            \n            // 3. answer 반환\n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 \"1231\" 패턴을 문자열로 인식해 replace()로 제거하는 방식이 떠올랐다. 효율성 면에서는 불리할 수 있다는 점을 간과했다. 테스트 케이스에서는 통과했지만 실제 제출에서는 시간 초과 또는 메모리 초과가 발생했다.\n\n+ 🛠 해결 과정\n문제의 핵심은 재료 순서가 \"1231\"인 경우를 빠르게 탐지하고 제거하는 것이다. 문자열 치환 방식이 비효율적인 이유는 replace()가 내부적으로 전체 문자열을 순회하고 새로운 문자열을 매번 생성하기 때문이다. 이를 개선하기 위해 스택을 이용한 풀이로 전환하였다. 스택을 이용하면 O(N) 시간복잡도로 모든 재료를 한 번만 순회하면서 햄버거를 만들 수 있다.\n\n+ ✅ 잘한 점\n문자열 방식과 스택 방식 두 가지 접근을 모두 시도했고, 제한 시간 내에 문제를 해결하며 효율적인 방식으로 전환한 점은 긍정적이었다.\n\n+ ⚠ 개선할 점\n문제에서 요구하는 \"효율성\" 조건을 처음부터 좀 더 면밀히 고려했어야 했다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/12909 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 스택 생성 문자열 를 char 배열로 변환해 순회 - for문 이용 로직 처리 스택이 비어있지 않고 현재 문자가 이고 스택의 top이 이면 pop() 그 …","fields":{"slug":"/archive/algorithm/18/"},"frontmatter":{"date":"June 04, 2025","title":"[프로그래머스] 올바른 괄호 Java","description":"올바른 괄호 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/12909](https://school.programmers.co.kr/learn/courses/30/lessons/12909)\n+ 난이도 : 레벨2\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 스택 생성\n    + 문자열 `s`를 char 배열로 변환해 순회 - for문 이용\n    + 로직 처리 \n        + 스택이 비어있지 않고 현재 문자가 `')'`이고 스택의 top이 `'('`이면 pop()\n        + 그 외의 경우는 push()\n    + 스택이 비어 있으면 true 아니면 false를 반환\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        boolean solution(String s) {\n            boolean answer = true;\n            \n            // 1. 스택 생성\n            Stack<Character> stack = new Stack<>();\n            // 2. 문자열 `s`를 char 배열로 변환해 순회 - for문 이용\n            char[] arr = s.toCharArray();\n            for (int i=0; i<arr.length; i++) {\n                // System.out.println(c);\n                \n                // 3. 로직 처리\n                if (!stack.isEmpty() && stack.peek() == '(' && arr[i] == ')') {\n                    // 스택이 비어있지 않고 현재 문자가 `')'`이고 스택의 top이 `'('`이면 pop()\n                    stack.pop();\n                } else {\n                    // 그 외의 경우는 push()\n                    stack.push(arr[i]);\n                }\n                \n            }\n            \n            // System.out.println(\"isEmpty = \" + stack.isEmpty());\n            \n            // 4. 스택이 비어 있으면 true 아니면 false를 반환\n            answer = stack.isEmpty();\n            \n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음 문제를 읽고 나서 스택으로 접근하는 방식이 자연스럽게 떠올랐다. 괄호의 짝을 맞추는 전형적인 문제였기 때문이다.\n\n+ 🛠 해결 과정\n처음에는 if-else 구조를 잘못 사용해서 결과가 잘못 나왔다. push()는 괄호의 짝이 맞지 않을 때 반드시 호출되어야 하는데 조건문 안에서만 처리하다 보니 예외가 발생했던 것이다. 나누었던 조건문을 하나로 합쳤더니 테스트 케이스를 모두 통과하였다.\n\n+ ✅ 잘한 점\n스택 자료구조를 이용해서 제한시간 안에 문제를 풀었다.\n\n+ ⚠ 개선할 점\n조건문 로직을 보다 명확하게 구현하는 연습이 필요하다. 다른 사람의 코드를 참고해보니 '('와 ')'의 개수를 각각 세어 합이 0이면 true를 반환하는 방식도 있었다. 스택 자료구조를 사용하지 않아 메모리 효율 면에서 더 나아 보였다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/42587 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 우선순위 큐 생성, index 변수 생성 우선순위 큐에 priorities 배열 담기 우선순위 큐를 순회하면서 index가 location과 같으면 bre…","fields":{"slug":"/archive/algorithm/17/"},"frontmatter":{"date":"June 03, 2025","title":"[프로그래머스] 프로세스 Java","description":"프로세스 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/42587](https://school.programmers.co.kr/learn/courses/30/lessons/42587)\n+ 난이도 : 레벨2\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 우선순위 큐 생성, index 변수 생성\n    + 우선순위 큐에 priorities 배열 담기\n    + 우선순위 큐를 순회하면서 index가 location과 같으면 break 다르면 answer 증가\n    + answer 반환 \n+ 문제점\n    + 우선순위 큐를 넣으면 순서가 달라진다.\n\n### 시도2\n+ 접근 방법\n    + 큐 생성\n    + 큐에 priorities 배열 담기\n    + 로직 처리\n        + 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다.\n        + 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다.\n        + 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다.\n        + 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다.\n    + answer 반환 \n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        class Process {\n            int index;\n            int priority;\n\n            public Process(int index, int priority) {\n                this.index = index;\n                this.priority = priority;\n            }\n        }\n        \n        public int solution(int[] priorities, int location) {\n            int answer = 0;\n        \n            // 1. 큐 생성 - Process를 담는 큐\n            Queue<Process> queue = new LinkedList<>();\n            \n            // 2. 큐에 priorities 배열 담기\n            for (int i=0; i<priorities.length; i++) {\n                queue.offer(new Process(i, priorities[i]));\n            }\n\n            // 3. 로직 처리\n            while (!queue.isEmpty()) {\n                // - 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다.\n                Process process = queue.poll();\n                \n                boolean isFlag = false;\n                for (Process p : queue) {\n                    if (p.priority > process.priority) {\n                        isFlag = true;\n                        break;\n                    }\n                }\n                \n                if (isFlag) {\n                    // - 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다.\n                    queue.offer(process);\n                } else {\n                    // - 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다.\n                    answer++;\n                    if (process.index == location) {\n                        return answer;\n                    }\n                }\n                \n                // - 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다.\n            }\n        \n            \n            // 해당 프로세스가 몇 번째로 실행되는지 return\n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 우선순위 큐를 떠올렸으나 우선순위 큐는 내부적으로 정렬이 되어 원래 프로세스들의 순서가 바뀌기 때문에 위치 정보를 추적하는 데 어려움이 있었다. 이로 인해 정확한 실행 순서를 알기 어려웠다.\n\n+ 🛠 해결 과정\n원래 순서와 우선순위를 모두 고려하기 위해 Process라는 클래스를 만들어 인덱스와 우선순위를 멤버변수로 추가하였다. 그리고 큐를 사용해 프로세스들을 순서대로 처리하면서 큐 안에 더 높은 우선순위를 가진 프로세스가 있는지 매번 확인하는 방법을 적용하였다. 이렇게 하니 문제에서 요구하는 실행 순서대로 프로세스를 처리할 수 있었다.\n\n+ ⚠ 개선할 점\n현재 구현은 매번 큐를 순회하면서 우선순위가 더 높은 프로세스가 있는지 확인하는데 시간복잡도에 문제가 있는지 확인해보면 좋을 것 같다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/131704 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 현재 박스 번호를 나타내는 nowBoxNum 변수, 보조 컨테이너 벨트 생성 - stack 이용 while문 이용 로직 처리 case1) 메인 컨테이너 …","fields":{"slug":"/archive/algorithm/16/"},"frontmatter":{"date":"May 31, 2025","title":"[프로그래머스] 택배 상자 Java","description":"택배 상자 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/131704](https://school.programmers.co.kr/learn/courses/30/lessons/131704)\n+ 난이도 : 레벨2\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 현재 박스 번호를 나타내는 nowBoxNum 변수, 보조 컨테이너 벨트 생성 - stack 이용\n    + while문 이용\n    + 로직 처리\n        + case1) 메인 컨테이너 벨트에서 박스를 꺼낼 수 있고 그 박스가 order[i]보다 작거나 같을 때 \n            + order와 현재 박스 번호가 같으면 트럭에 바로 싣고 다음 order로 이동\n            + 그렇지 않으면 보조 컨테이너 벨트에 보관하고 다음 박스로 이동\n        + case2) 메인 벨트에서 꺼낼 수 없거나 order[i]가 현재보다 작은 경우  \n            + 보조 컨테이너 벨트의 맨 위 박스가 실어야 할 박스면 트럭에 싣기\n            + 아니면 더 이상 실을 수 없으므로 종료 - break\n    + 위의 과정을 반복하며 order 배열의 끝까지 처리\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int solution(int[] order) {\n            int answer = 0;\n            \n            // 1. 현재 박스 번호를 나타내는 nowBoxNum 변수, 보조 컨테이너 벨트 생성 - stack 이용\n            // 보조 컨테이너 벨트\n            Stack<Integer> stack = new Stack<>();\n            \n            int nowBoxNum = 1; // 현재 박스 번호\n            int i = 0;     // order 배열 인덱스\n\n            // 2. while문 이용\n            while (true) {\n                // case1) 메인 컨테이너 벨트에서 박스를 꺼낼 수 있고 그 박스가 order[i]보다 작거나 같을 때 \n                if (nowBoxNum <= order.length && order[i] >= nowBoxNum) {\n                    if (order[i] == nowBoxNum) {\n                        // order와 현재 박스 번호가 같으면 트럭에 바로 싣고 다음 order로 이동\n                        answer++;\n                        i++;\n                        nowBoxNum++;\n                    } else {\n                        // 그렇지 않으면 보조 컨테이너 벨트에 보관하고 다음 박스로 이동\n                        stack.push(nowBoxNum++);\n                    }\n                }\n                // case2) 메인 벨트에서 꺼낼 수 없거나 order[i]가 현재보다 작은 경우  \n                else {\n                    if (!stack.isEmpty() && stack.peek() == order[i]) {\n                        // 보조 컨테이너 벨트의 맨 위 박스가 실어야 할 박스면 트럭에 싣기\n                        stack.pop();\n                        answer++;\n                        i++;\n                    } else {\n                        // 위의 어떤 조건에도 해당하지 않으면 더 이상 실을 수 없음 \n                        break;\n                    }\n                }\n            }\n\n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n보조 컨테이너 벨트을 보고 자연스럽게 스택 자료구조를 떠올랐다. 메인 벨트에서는 1번부터 순서대로 박스를 꺼낼 수 있다는 점에서 nowBoxNum 변수를 도입해 접근하였다.\n\n+ 🛠 해결 과정\norder 배열의 현재 인덱스 값과 nowBoxNum을 비교하면서 일치하면 바로 트럭에 싣고, 더 크면 보조 벨트에 쌓고,\n더 작거나 꺼낼 수 없을 경우에는 보조 벨트에서 확인하는 흐름으로 처리하였다.\n\n+ ⚠ 개선할 점\n처음 설계 흐름을 파악하고 코드 구조를 잡는 데 시간이 오래 걸려 제한 시간 내에 문제를 해결하지 못했다. 특히 조건 분기를 세밀하게 구현하는 과정에서 매끄럽지 못한 부분이 있었다. 다른 사람의 풀이를 참고하니 메인 벨트를 큐, 보조 벨트를 스택으로 구현하여 더 직관적이고 깔끔하게 표현한 코드를 확인할 수 있었다. 이러한 구현 방식도 익혀두면 유사 문제에서 보다 유연하게 접근할 수 있을 것으로 생각된다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/64061 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 바구니 생성 - 스택 이용 moves 배열을 순회 - for문 이용 각 항목을 순회하면서 해당 열에 맨 첫번째 값을 찾기 찾은값이 스택의 첫번째값이랑 같으…","fields":{"slug":"/archive/algorithm/15/"},"frontmatter":{"date":"May 28, 2025","title":"[프로그래머스] 크레인 인형뽑기 게임 Java","description":"크레인 인형뽑기 게임 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/64061](https://school.programmers.co.kr/learn/courses/30/lessons/64061)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 바구니 생성 - 스택 이용\n    + moves 배열을 순회 - for문 이용\n    + 각 항목을 순회하면서 해당 열에 맨 첫번째 값을 찾기\n    + 찾은값이 스택의 첫번째값이랑 같으면 pop() 아니면 push()\n    + answer return\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int solution(int[][] board, int[] moves) {\n            int answer = 0;\n            // 0. 바구니 생성 - 스택 이용\n            Stack<Integer> stack = new Stack<>();\n            // 1. moves 배열을 순회 - for문 이용\n            for (int i=0; i<moves.length; i++) {\n                int col = moves[i] - 1;\n                // 2. 각 행을 순회하면서 해당 열에 맨 첫번째 값을 찾기\n                for (int row=0; row<board.length; row++) {\n                    int now = board[row][col];\n                    if (now != 0) {\n                        // 3. 찾은값이 스택의 첫번째값이랑 같으면 pop() 아니면 push()\n                        if (!stack.isEmpty() && stack.peek() == now) {\n                            stack.pop();  // 기존 인형 제거 \n                            answer += 2;  // 두 인형이 없어짐 (2개 터짐)\n                        } else {\n                            stack.push(now);\n                        }\n                        // 인형 뽑았다는 표시\n                        board[row][col] = 0;\n                        break;\n                    } \n                }\n            }\n            \n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음 문제를 보고 인형을 하나씩 꺼내 바구니에 담는 구조가 스택과 유사하다고 판단했다. 그래서 바구니를 Stack으로 구현하고 인형이 두 개 연속으로 겹칠 경우 제거되는 로직을 중심으로 설계를 시작했다.\n\n+ 🛠 해결 과정\nmoves 배열을 순회하면서 각 열에서 인형을 하나씩 꺼낸다. 꺼낸 인형이 바구니의 맨 위 인형과 같으면 두 인형을 제거하고 answer를 추가한다. 그렇지 않으면 바구니에 인형을 넣는다.\n\n+ ✅ 잘한 점\n문제를 보고 스택을 활용해야겠다는 구조적 접근이 적절하였고 생각한대로 코드로 구현했을때 별다른 오류없이 바로 테스트 케이스를 통과하였다.\n\n+ ⚠ 개선할 점\n설계 흐름을 생각하는데 시간을 많이 지체하여 제한 시간 30분 안에 풀지 못하였다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/150370 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 약관 정보(terms) 배열을 Map 형태로 변환 각 약관명을 key로 유효기간을 일단위로 환산한 값을 value로 하여 형태로 변환한다. 예) \"A 6…","fields":{"slug":"/archive/algorithm/14/"},"frontmatter":{"date":"May 27, 2025","title":"[프로그래머스] 개인정보 수집 유효기간 Java","description":"개인정보 수집 유효기간 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/150370](https://school.programmers.co.kr/learn/courses/30/lessons/150370)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 약관 정보(terms) 배열을 Map 형태로 변환\n        + 각 약관명을 key로 유효기간을 일단위로 환산한 값을 value로 하여 형태로 변환한다.   \n          예) \"A 6\" => map.put(\"A\", 6 * 28);\n    + 개인정보 수집 내역(privacies) 배열 순회 - for문 이용\n    + 파기 대상 여부 판단\n        + 개인정보 수집일자를 LocalDate로 변환한다.\n        + 해당 항목의 약관 유형을 기준으로 유효기간을 더해 파기 예정일을 계산한다.\n        + 파기 예정일 = 개인정보 수집일 + 유효기간(일) - 1\n        + 오늘 날짜와 파기 예정일을 비교한다. - isBefore() 이용\n    + answer return\n+ 문제점\n    + 테스트 케이스를 통과하지 못해서 파기예정일을 출력해보았더니 예제와 맞지 않았다.\n    + **문제처럼 \"모든 달이 28일\" 이라는 가상의 조건에서는 `LocalDate`를 쓰면 오히려 파기 예정일이 달라지는 버그가 발생한다.**\n+ 소스 코드\n    ```java\n    import java.time.*;\n    import java.time.format.*;\n    import java.util.*;\n\n    class Solution {\n        public int[] solution(String today, String[] terms, String[] privacies) {\n            int[] answer = {};\n            List<Integer> result = new ArrayList<>();\n            \n            String[] tmpArr = null;\n            int day = 0;\n            \n            LocalDate todayDate = parseDate(today);\n            \n            // 0. 약관 정보(terms) 배열을 Map 형태로 변환\n            Map<String, Integer> termsMap = new HashMap<>();\n            for (String str : terms) {\n                tmpArr = str.split(\" \");\n                day = Integer.parseInt(tmpArr[1]) * 28; // 모든 달은 28일까지 있다고 가정합니다.\n                // 각 약관명을 key로 유효기간을 일단위로 환산한 값을 value로 하여 형태로 변환한다.\n                termsMap.put(tmpArr[0], day);\n            }\n            \n            // 1. 개인정보 수집 내역(privacies) 배열 순회 - for문 이용\n            for (int i=0; i<privacies.length; i++) {\n                // 2. 파기 대상 여부 판단\n                tmpArr = privacies[i].split(\" \");\n            \n                // 개인정보 수집일자를 LocalDate로 변환한다.\n                LocalDate tmpDate = parseDate(tmpArr[0]);\n                // 유효기간(일)\n                day = termsMap.get(tmpArr[1]);          \n                \n                // 해당 항목의 약관 유형을 기준으로 유효기간을 더해 파기 예정일을 계산한다.\n                // 파기 예정일 = 개인정보 수집일 + 유효기간(일) - 1\n                LocalDate expiredDate = tmpDate.plusDays(day).minusDays(1);\n\n                //System.out.println(\"개인정보 수집일: \" + tmpDate);\n                //System.out.println(\"파기 예정일: \" + expiredDate);\n                //System.out.println(\"오늘: \" + todayDate);\n                \n                // 오늘 날짜와 파기 예정일을 비교한다.\n                if (expiredDate.isBefore(todayDate)) {\n                    // 파기 대상\n                    result.add(i);\n                }\n            }\n            \n            // result.forEach(System.out::println);\n            \n            // List -> 배열로 변환\n            answer = result.stream().mapToInt(i -> i + 1).toArray();\n            \n            return answer;\n        }\n        \n        private LocalDate parseDate(String date) {\n            return LocalDate.parse(date, DateTimeFormatter.ofPattern(\"yyyy.MM.dd\")); \n        }\n    }\n    ```\n### 시도2\n+ 접근 방법\n    + 약관 정보(terms) 배열을 Map 형태로 변환\n    + 오늘 날짜를 모든 달이 28일인 가상의 달력을 기준으로 변환\n    + 개인정보 수집 내역(privacies) 배열 순회 - for문 이용\n    + 파기 대상 여부 판단\n        + 개인정보 수집일자를 모든 달이 28일인 가상의 달력을 기준으로 변환한다.\n        + 해당 항목의 약관 유형을 기준으로 유효기간을 더해 파기 예정일을 계산한다.\n        + 파기 예정일 = 개인정보 수집일 + 유효기간(일) - 1\n        + 오늘 날짜와 파기 예정일을 비교한다. \n    + List -> 배열로 변환하여 return - mapToInt() 이용\n+ 소스 코드\n    ```java\n    import java.time.*;\n    import java.time.format.*;\n    import java.util.*;\n\n    class Solution {\n        public int[] solution(String today, String[] terms, String[] privacies) {\n            int[] answer = {};\n            List<Integer> result = new ArrayList<>();\n            \n            String[] tmpArr = null;\n            \n            // 0. 약관 정보(terms) 배열을 Map 형태로 변환\n            Map<String, Integer> termsMap = new HashMap<>();\n            for (String str : terms) {\n                tmpArr = str.split(\" \");\n                termsMap.put(tmpArr[0], Integer.parseInt(tmpArr[1]));\n            }\n            \n            // 1. 오늘 날짜를 모든 달이 28일인 가상의 달력을 기준으로 변환\n            int convertToDay = convertDate(today);\n            \n            // 2. 개인정보 수집 내역(privacies) 배열 순회 - for문 이용\n            for (int i=0; i<privacies.length; i++) {\n                // 3. 파기 대상 여부 판단\n                tmpArr = privacies[i].split(\" \");\n            \n                // 개인정보 수집일자를 모든 달이 28일인 가상의 달력을 기준으로 변환한다.\n                int tmpDate = convertDate(tmpArr[0]);\n                // 유효기간(월)\n                int month = termsMap.get(tmpArr[1]);\n                \n                // 해당 항목의 약관 유형을 기준으로 유효기간을 더해 파기 예정일을 계산한다.\n                // 파기 예정일 = 개인정보 수집일자 + (해당 약관 유효기간 * 28) - 1 \n                int calcDate = tmpDate + (month * 28) - 1;\n                \n                // 오늘 날짜와 파기 예정일을 비교한다. \n                if (convertToDay > calcDate) {\n                    // 파기 대상\n                    result.add(i+1);\n                }\n            }\n            \n            // result.forEach(System.out::println);\n            \n            // 4. answer return - List -> 배열로 변환\n            answer = result.stream().mapToInt(i -> i).toArray();\n            \n            return answer;\n        }\n        \n        // 모든 달이 28일인 가상의 달력 형태로 변환\n        private int convertDate(String date) {\n            String[] tmp = date.split(\"\\\\.\");\n            int year = Integer.parseInt(tmp[0]) * 12 * 28;\n            int month = Integer.parseInt(tmp[1]) * 28;\n            int day = Integer.parseInt(tmp[2]);\n            \n            return year + month + day;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음에는 Java의 LocalDate 클래스를 사용해 날짜 계산을 시도했지만 문제에서 주어진 \"모든 달은 28일까지 존재한다\"는 가상 조건으로 인해 테스트 케이스를 통과하지 못하였다. 이로 인해 날짜 계산 방식 자체를 변경하였다.\n\n+ 🛠 해결 과정\n모든 날짜를 일단위로 변환하여 처리하는 방식으로 구현하였다. yyyy.MM.dd 형식의 날짜를 (연 * 12 * 28) + (월 * 28) + 일의 총 일수로 변환하여 계산함으로써 문제에서 요구하는 28일 달력을 완벽하게 반영할 수 있었다. 이 방식으로 파기 예정일을 정확히 계산할 수 있었고 모든 테스트 케이스를 통과할 수 있었다.\n\n+ ⚠ 개선할 점\nLocalDate 사용이 적절하다고 판단했지만 문제 조건과 맞지 않아 테스트를 통과하지 못했고 제한 시간 30분을 초과했다. 수동으로 날짜를 계산하는 방법이 떠오르지 않아 GPT의 도움을 받았다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/176963 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 name 배열과 yearning 배열을 기반으로 이름별 그리움 점수를 조회할 수 있도록 Map 형태로 변환 photo 배열을 순회 - for문 이용 이름…","fields":{"slug":"/archive/algorithm/13/"},"frontmatter":{"date":"May 26, 2025","title":"[프로그래머스] 추억점수 Java","description":"추억점수 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/176963](https://school.programmers.co.kr/learn/courses/30/lessons/176963)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + name 배열과 yearning 배열을 기반으로 이름별 그리움 점수를 조회할 수 있도록 Map 형태로 변환\n    + photo 배열을 순회 - for문 이용\n    + 이름이 map에 존재하는 경우 해당 점수를 더하고 존재하지 않으면 0을 더한다 - getOrDefault()\n    + answer 반환\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int[] solution(String[] name, int[] yearning, String[][] photo) {\n            int[] answer = new int[photo.length];\n            \n            // 1. name 배열과 yearning 배열을 기반으로 이름별 그리움 점수를 조회할 수 있도록 Map 형태로 변환\n            Map<String, Integer> map = new HashMap<>();\n            for (int i=0; i<name.length; i++) {\n                map.put(name[i], yearning[i]);\n            }\n            // 2. photo 배열을 순회 - for문 이용\n            for (int i=0; i<photo.length; i++) {\n                for (int j=0; j<photo[i].length; j++) {\n                    // 3. 이름이 map에 존재하는 경우 해당 점수를 더하고 존재하지 않으면 0을 더한다 - getOrDefault\n                    answer[i] += map.getOrDefault(photo[i][j], 0);\n                }\n                // System.out.println(\"answer = \" + answer[i]);\n            }\n            \n            // 4. answer 반환\n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 처음 접했을 때  name 배열과 yearning 배열을 Map으로 변환하는 방식으로 하면 빠르게 풀 수 있을것같았다.\n\n+ 🛠 해결 과정\nname과 yearning 배열을 순회하며 이름별 점수를 `Map<String, Integer>` 형태로 구성하였다. 각 photo마다 등장하는 이름들을 순회하면서 getOrDefault()로 점수를 누적하였고 사진별 총 점수를 answer 배열에 저장 후 반환하였다.\n\n+ ✅ 잘한 점\n문제의 조건이 복잡하지 않아 빠르게 구현이 가능했고 자료구조 선택만 잘하면 효율적으로 해결할 수 있는 문제였다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/159994 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 cards1, cards2 배열을 큐로 변환 goal 배열 순회 - for문 이용 현재 단어가 queue1.peek()이면 queue1.poll() 아니…","fields":{"slug":"/archive/algorithm/12/"},"frontmatter":{"date":"May 25, 2025","title":"[프로그래머스] 카드뭉치 Java","description":"카드뭉치 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/159994](https://school.programmers.co.kr/learn/courses/30/lessons/159994)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + cards1, cards2 배열을 큐로 변환\n    + goal 배열 순회 - for문 이용\n    + 현재 단어가 queue1.peek()이면 queue1.poll() 아니고 queue2.peek()이면 queue2.poll() 둘 다 아니면 return \"No\"\n    + 끝까지 다 순회했다면 return \"Yes\"\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public String solution(String[] cards1, String[] cards2, String[] goal) {\n            String answer = \"Yes\";\n            \n            // 한 번 사용한 카드는 다시 사용할 수 없습니다. => 먼저 들어온 순서대로 꺼내야함(FIFO) => 큐\n            // 1. cards1, cards2 배열을 큐로 변환\n            Queue<String> queue1 = new LinkedList<>();\n            for (String str : cards1) {\n                queue1.add(str);\n            }\n            \n            Queue<String> queue2 = new LinkedList<>();\n            for (String str : cards2) {\n                queue2.add(str);\n            }\n            \n            // 2. goal 배열 순회 - for문 이용\n            for (String word : goal) {\n                // cards1과 cards2에는 서로 다른 단어만 존재합니다. => 항상 둘 다 없거나, 둘중에 하나만 있다.\n                // 3. 현재 단어가 queue1.peek()이면 queue1.poll() 아니고 queue2.peek()이면 queue2.poll() 둘 다 아니면 return \"No\"\n                \n                //System.out.println( \"word =>\" + word );\n                //System.out.println( \"queue1 =>\" + queue1.peek() );\n                //System.out.println( \"queue2 =>\" + queue2.peek() );\n                \n                if ( word.equals(queue1.peek()) ) {\n                    queue1.poll();\n                    //System.out.println( \"queue1.poll\" );\n                } else if ( word.equals(queue2.peek()) ) {\n                    // queue2.peek()이면 queue2.poll()\n                    queue2.poll();\n                    //System.out.println( \"queue2.poll\" );\n                } else {\n                    // 둘 다 아니면 return \"No\"\n                    answer = \"No\";\n                    break;\n                }\n            }\n            \n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 `\"한 번 사용한 카드는 다시 사용할 수 없다\"`는 조건과 `\"순서를 지켜야 한다\"`는 조건에 주목했다. 이 조건을 보고 FIFO 구조인 Queue를 사용하면 적절하겠다고 판단했다.\n\n+ 🛠 해결 과정\ncards1과 cards2를 각각 Queue로 변환한 후 goal 배열을 순차적으로 순회하며 각 단어가 어떤 큐의 맨 앞에 있는지 확인했다.\nqueue1.peek()과 queue2.peek()를 비교해서 일치하면 poll()로 제거하고 둘 다 일치하지 않으면 목표 단어 순서를 만들 수 없으므로 \"No\"를 반환했다.\n\n+ ✅ 잘한 점\n문제 조건을 정확히 이해하고 적절한 자료구조를 떠올려 해결한 점이 좋았다.\n\n+ ⚠ 개선할 점\ncards1과 cards2를 큐로 변환할 때 반복문 대신 `Collections.addAll(queue, array)`를 사용하면 코드가 더 간결해진다.\n```java\nQueue<String> queue1 = new LinkedList<>();\nfor (String str : cards1) {\n    queue1.add(str);\n}\n// Collections.addAll() 사용\nQueue<String> queue1 = new LinkedList<>();\nCollections.addAll(queue1, cards1);\n```\n또한, 다른 사람의 코드를 참고해 보니 큐 대신 배열의 인덱스를 사용하는 방법도 있었다. 이 방법이 큐를 사용하는 것보다 메모리와 성능 면에서 더 효율적일 수 있다.\n앞으로는 상황에 따라 더 효율적인 방법을 선택하는 습관을 들여야겠다.\n```java\n// 인덱스 사용 방식\nint i = 0, j = 0;\nfor (String word : goal) {\n    if (i < cards1.length && word.equals(cards1[i])) {\n        i++;\n    } else if (j < cards2.length && word.equals(cards2[j])) {\n        j++;\n    } else {\n        return \"No\";\n    }\n}\nreturn \"Yes\";\n```\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/136798 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 1부터 number까지 약수의 개수 구하기 number까지의 약수들 중 limit를 초과하는 값들은 power로 값 변경하여 합계 구하기 answer r…","fields":{"slug":"/archive/algorithm/11/"},"frontmatter":{"date":"May 24, 2025","title":"[프로그래머스] 기사단원의 무기 Java","description":"기사단원의 무기 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/136798](https://school.programmers.co.kr/learn/courses/30/lessons/136798)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + 1부터 number까지 약수의 개수 구하기\n    + number까지의 약수들 중 limit를 초과하는 값들은 power로 값 변경하여 합계 구하기\n    + answer return\n+ 소스 코드\n    ```java\n    class Solution {\n        public int solution(int number, int limit, int power) {\n            int answer = 0;\n            // 1. 1부터 number까지 약수의 개수 구하기\n            for (int i=1; i<=number; i++) {    \n                int cnt = calcCnt(i);\n                \n                // 2.number까지의 약수들 중 limit를 초과하는 값들은 power로 값 변경하여 합계 구하기\n                if (cnt > limit) {\n                    answer += power;\n                } else {\n                    answer += cnt;\n                }\n            }\n            \n            // 3. answer return\n            return answer;\n        }\n        \n        private int calcCnt(int n) {\n            int cnt = 0;\n            \n            for (int i=1; i*i<=n; i++) {\n                if (n % i == 0) {\n                    cnt++;\n                    \n                    // 중복 계산을 방지하기 위해서\n                    if (i != n / i) {\n                        cnt++;\n                    }\n                }\n            }\n            \n            return cnt;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n1부터 number까지 각 숫자의 약수 개수를 구한 후 그 개수가 limit을 초과하면 power로 대체하여 누적합(answer)을 계산하는 방식으로 문제를 해결하고자 했다.\n\n+ 🛠 해결 과정\n약수 개수를 효율적으로 구하기 위해 제곱근까지만 순회하면서 중복 약수 계산을 방지하는 방식으로 calcCnt() 메서드를 구현했다.\n\n+ ✅ 잘한 점\n문제의 구현 로직 자체는 복잡하지 않아 구조를 빠르게 설계할 수 있었고 약수 개수를 구할 때 중복을 방지하는 최적화도 잘 적용했다.\n\n+ ⚠ 개선할 점\n초기 문제 해석을 잘못해 풀이 방향을 잡는 데 시간이 오래 걸렸고 이로 인해 제한 시간 30분 내에 문제를 해결하지 못했다. 앞으로는 문제를 꼼꼼히 읽고 요구사항을 명확히 이해한 후에 구현을 시작해야겠다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/161990 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 wallpaper 순회 - for문 이용 lux, luy, rdx, rdy 값 갱신 answer 배열에 lux, luy, rdx, rdy 값 저장 소스 …","fields":{"slug":"/archive/algorithm/10/"},"frontmatter":{"date":"May 23, 2025","title":"[프로그래머스] 바탕화면 정리 Java","description":"바탕화면 정리 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/161990](https://school.programmers.co.kr/learn/courses/30/lessons/161990)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + wallpaper 순회 - for문 이용\n    + lux, luy, rdx, rdy 값 갱신\n    + answer 배열에 lux, luy, rdx, rdy 값 저장\n+ 소스 코드\n    ```java\n    class Solution {\n        public int[] solution(String[] wallpaper) {\n        int lux = Integer.MAX_VALUE;\n            int luy = Integer.MAX_VALUE;\n            int rdx = Integer.MIN_VALUE;\n            int rdy = Integer.MIN_VALUE;\n            int[] answer = new int[4];\n            \n            // 1. wallpaper 순회 - for문 이용\n            for (int i=0; i<wallpaper.length; i++) {\n                char[] arr = wallpaper[i].toCharArray();\n                for (int j=0; j<arr.length; j++) {\n                    if ( '#' == arr[j] ) {\n                        //System.out.println(\"i = \" + i);\n                        //System.out.println(\"j = \" + j);\n                        \n                        // 2. lux, luy, rdx, rdy 값 갱신 - Math.min(), Math.max() 이용\n                        lux = Math.min(lux, i);\n                        luy = Math.min(luy, j);\n                        \n                        rdx = Math.max(rdx, i+1);\n                        rdy = Math.max(rdy, j+1);\n                        \n                        /*\n                        System.out.println(\"lux = \" + lux);\n                        System.out.println(\"luy = \" + luy);\n                        System.out.println(\"rdx = \" + rdx);\n                        System.out.println(\"rdy = \" + rdy);\n                        */\n                    }\n                }\n            }\n            \n            /*\n            System.out.println(\"lux = \" + lux);\n            System.out.println(\"luy = \" + luy);\n            System.out.println(\"rdx = \" + rdx);\n            System.out.println(\"rdy = \" + rdy);\n            */\n            \n            answer[0] = lux;\n            answer[1] = luy;\n            answer[2] = rdx;\n            answer[3] = rdy;\n            \n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음에는 단순히 이차원 배열을 순회하면서 #의 위치를 파악하고자 했다. 좌표의 최소값, 최대값을 추적하는 방식으로 접근하면 된다는 생각이이 바로 떠올랐다.\n\n+ 🛠 해결 과정\n각 줄을 char[]로 변환해 이중 반복문으로 탐색하며 # 문자의 좌표를 확인하고 그에 따라 lux, luy, rdx, rdy 값을 실시간으로 갱신했다. Math.min()과 Math.max()를 이용해 깔끔하게 최소,최대 좌표를 계산할 수 있었다.\n\n+ ✅ 잘한 점\n불필요한 자료구조 없이 최소,최대 좌표만 추적하는 방식으로 효율적으로 구현했다. 좌표 계산 시 오른쪽 아래 끝 점을 +1 처리한 것도 문제 조건을 정확히 반영한 부분이다.\n\n+ ⚠ 개선할 점\n단순 구현 문제였지만 조건 중 \"드래그 시 (rdx, rdy)는 파일이 포함되는 좌표의 다음 칸까지 포함해야 함\"을 처음에 놓칠 뻔했다. 문제 설명을 끝까지 꼼꼼히 읽는 습관을 유지해야겠다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/138477 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 k길이 만큼 배열 생성 score 순회 - for문 이용 score값을 받아서 만든 배열 정렬 answer 배열에 k번째 값 저장 문제점 정렬을 매번 수…","fields":{"slug":"/archive/algorithm/9/"},"frontmatter":{"date":"May 20, 2025","title":"[프로그래머스] 프로그래머스 명예의 전당1 Java","description":"명예의 전당1 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/138477](https://school.programmers.co.kr/learn/courses/30/lessons/138477)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + k길이 만큼 배열 생성\n    + score 순회 - for문 이용\n    + score값을 받아서 만든 배열 정렬\n    + answer 배열에 k번째 값 저장\n+ 문제점\n    + 정렬을 매번 수행하면 시간복잡도가 올라간다.\n\n### 시도2\n+ 접근 방법\n    + 우선순위 큐 생성\n    + score 순회 - for문 이용\n    + 현재 점수를 우선순위 큐에 추가\n    + 큐의 길이가 k를 초과하면 가장 낮은 점수 제거 - poll()\n    + 현재 우선순위 큐에서 가장 낮은 점수를 answer에 저장 - peek()\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public int[] solution(int k, int[] score) {\n            int[] answer = new int[score.length];\n            \n            // 1. 우선순위 큐 생성\n            PriorityQueue<Integer> queue = new PriorityQueue<>();\n            \n            // 2. score 순회 - for문 이용\n            for (int i=0; i<score.length; i++) {\n                // 3. 현재 점수를 우선순위 큐에 추가\n                queue.add(score[i]);\n                \n                // 4. 큐의 길이가 k를 초과하면 가장 낮은 점수 제거 - poll()\n                if (queue.size() > k) {\n                    queue.poll();\n                }\n                \n                // 5. 현재 우선순위 큐에서 가장 낮은 점수를 answer에 저장 - peek()\n                answer[i] = queue.peek();\n            }\n            \n            // 매일 발표된 명예의 전당의 최하위 점수 \n            return answer;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음에는 배열을 정렬하면 되지 않을까 생각하였으나 매번 정렬을 수행하면 시간복잡도에 문제가 있지 않을까 생각이 들었다.\n\n+ 🛠 해결 과정\n우선순위 큐를 사용하여 항상 가장 낮은 점수를 유지하는 방식으로 문제를 해결했다. 큐에 점수를 넣고 사이즈가 k를 초과할 경우 가장 낮은 점수를 제거하면 자연스럽게 상위 k개의 점수만 유지할 수 있다. 현재 큐의 최소값을 peek()으로 꺼내 answer에 저장하면 매일 발표된 명예의 전당의 최하위 점수를 쉽게 구할 수 있었다.\n\n+ ✅ 잘한 점\n단순 정렬 대신 우선순위 큐를 활용하여 효율적인 방식으로 문제를 해결하였다. Java에서 PriorityQueue의 특성을 이해하고 적절히 활용한 점이 좋았다.\n\n+ ⚠ 개선할 점\n이 문제는 본질적으로 최소 힙(min-heap) 을 활용하는 문제였다. 처음 지문을 읽었을 때 이를 바로 떠올리지 못했다. 백준 등에서 최소힙/최대힙 문제를 여러 번 풀어봤음에도 불구하고 우선순위 큐를 떠올리지 못한 점이 아쉬웠다. 지문을 읽고 빠르게 판단할 수 있도록 사고력을 더 키워야겠다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/12915 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 strings 순회 - for문 이용 strings 정렬시 n번째 글자순으로 - Arrays.sort() 문제점 이렇게 하면 for문을 할 필요가 없어진다…","fields":{"slug":"/archive/algorithm/8/"},"frontmatter":{"date":"May 19, 2025","title":"[프로그래머스] 프로그래머스 문자열 내 마음대로 정렬하기 Java","description":"문자열 내 마음대로 정렬하기 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/12915](https://school.programmers.co.kr/learn/courses/30/lessons/12915)\n+ 난이도 : 레벨1\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + strings 순회 - for문 이용\n    + strings 정렬시 n번째 글자순으로 - Arrays.sort() \n+ 문제점\n    + 이렇게 하면 for문을 할 필요가 없어진다.\n\n### 시도2\n+ 접근 방법\n    + n번재 글자순으로 정렬되게 - Arrays.sort() 이용\n    + Comparator를 재정의하여 n번재 글자를 비교 같으면 글자를 비교 => 시간복잡도 O(n log n)\n+ 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        public String[] solution(String[] strings, int n) {\n            /*\n            방법2)\n            1. n번재 글자순으로 정렬되게 - Arrays.sort() 이용\n            2. Comparator를 재정의하여 n번재 글자를 비교 같으면 글자를 비교\n            => 시간복잡도 O(n log n)\n            */\n            \n            Arrays.sort(strings, (s1, s2) -> {\n                // 음수 s1 < s2\n                // 같다(0) s1 = s2\n                // 양수 s1 > s2\n                // 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.\n                if (s1.charAt(n) == s2.charAt(n)) {\n                    return s1.compareTo(s2);\n                } else {\n                    return Character.compare(s1.charAt(n), s2.charAt(n));\n                }\n            });\n            \n            // 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬\n            return strings;\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n처음에는 for문으로 순회하며 정렬을 직접 구현하려 했지만 Java의 Arrays.sort()와 Comparator를 활용하면 훨씬 간단하고 효율적으로 문제를 해결할 수 있음을 알게 되었다.\n\n+ 🛠 해결 과정\nComparator를 람다식을 이용해서 재정의하여 n번째 문자를 기준으로 정렬하고 만약 두 문자의 값이 같을 경우 전체 문자열을 compareTo()로 비교하여 사전순 정렬을 구현하였다.\n\n+ ✅ 잘한 점\n불필요한 반복문 없이 Java의 내장 정렬 기능을 적극 활용하여 깔끔하고 가독성 있는 코드로 작성하였다. 문제 조건을 정확히 반영해 정렬 기준을 적절히 적용하였다.\n\n+ ⚠ 개선할 점\nComparator에 대한 이해가 부족한 부분이 있었으므로 직접 여러 케이스를 만들어 보며 다양한 정렬 기준을 구현해보는 연습이 필요하다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11720 난이도 : 브론즈4 문제 내용 : N개의 숫자가 공백 없이 문자열 형태로 주어질 때 이 숫자들의 합을 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법  문자열을 한 글자씩 분리한 후 각 문자를 정수로 변환하여 합산한다. 문제점 정답은 맞지만 spli…","fields":{"slug":"/archive/algorithm/7/"},"frontmatter":{"date":"May 07, 2025","title":"[BOJ] 백준 11720 숫자의 합 Java","description":"백준 11720 숫자의 합 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/11720](https://www.acmicpc.net/problem/11720)\n+ 난이도 : 브론즈4\n+ 문제 내용 : N개의 숫자가 공백 없이 문자열 형태로 주어질 때 이 숫자들의 합을 구하는 문제이다.\n\n## 2. 내 풀이 방법\n\n### 시도1\n+ 접근 방법\n    + `split(\"\") + Integer.parseInt()`\n    + 문자열을 한 글자씩 분리한 후 각 문자를 정수로 변환하여 합산한다.\n+ 문제점\n    + 정답은 맞지만 split()은 내부적으로 정규식을 사용하기 때문에 속도가 느리다.\n+ 소스 코드\n    ```java\n    import java.io.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            \n            String[] input = br.readLine().split(\"\");\n            \n            int sum = 0;\n            for (int i=0; i<n; i++) {\n                sum += Integer.parseInt(input[i]);\n            }\n            \n            // 출력\n            // : 입력으로 주어진 숫자 N개의 합\n            System.out.println(sum);\n        }\n    }\n    ```\n### 시도2\n+ 접근 방법\n    + `toCharArray() + 아스키 코드`\n    + String.toCharArray()로 문자 배열을 만든 뒤 각 문자를 '0'과의 차이로 정수로 변환하여 합산한다.\n+ 문제점\n    + char 배열을 복사해서 반환하기 때문에 String.charAt() 보다 속도가 느리다.\n### 시도3\n+ 접근 방법\n    + `charAt(i) + 아스키 코드`\n    + charAt(i)을 사용하여 각 문자를 직접 접근하고 '0'을 빼서 정수로 변환한다.\n    + 별도의 배열을 만들지 않기 때문에 가장 빠른 방식이다.\n\n\n### 각 방법들 성능 비교\n\n위에 시도한 방법들은 모두 제출시 정답이다. 하지만 실제 코딩테스트에서 시간복잡도뿐만 아니라 메모리, 실행시간 또한 고려해야 한다. 문제를 완벽하게 이해하고 구현을 해야 하기 때문에 이러한 요소들도 같이 생각해서 코딩하는 것이 좋다.\n\n3가지 방법을 100만 자리 숫자 문자열에 대해 비교한 결과이다.\n```java\npublic static void main(String[] args) throws IOException {\n    int n = 1_000_000; // 100만 자짜리 숫자 문자열 생성\n    StringBuilder sb = new StringBuilder(n);\n    Random rand = new Random();\n\n    for (int i = 0; i < n; i++) {\n        sb.append(rand.nextInt(10));\n    }\n    String numberString = sb.toString();\n\n    // 1. split(\"\") + Integer.parseInt()\n    long start1 = System.currentTimeMillis();\n    String[] arr = numberString.split(\"\");\n    int sum1 = 0;\n    for (int i = 0; i < arr.length; i++) {\n        sum1 += Integer.parseInt(arr[i]);\n    }\n    long end1 = System.currentTimeMillis();\n    System.out.println(\"1. split + parseInt 방식: \" + (end1 - start1) + \"ms, sum = \" + sum1);\n\n    // 2. toCharArray() + (c - '0')\n    // 방법 2: toCharArray() + (c - '0')\n    long start2 = System.currentTimeMillis();\n    char[] chars = numberString.toCharArray();\n    int sum2 = 0;\n    for (char c : chars) {\n        // char 타입끼리 연산을 하면 내부적으로 숫자로 처리되어 int형 타입으로 결과가 나온다.\n        // 자바에서 '1' 같은 문자는 char으로 저장되지만 내부적으로는 유니코드(또는 ASCII) 숫자값으로 저장되기 때문에 산술 연산이 가능하다.\n        sum2 += c - '0';\n    }\n    long end2 = System.currentTimeMillis();\n    System.out.println(\"2. toCharArray + 아스키코드 방식: \" + (end2 - start2) + \"ms, 합계 = \" + sum2);\n\n    // 3. charAt(i) + (c - '0')\n    long start3 = System.currentTimeMillis();\n    int sum3 = 0;\n    for (int i = 0; i < n; i++) {\n        // char 타입끼리 연산을 하면 내부적으로 숫자로 처리되어 int형 타입으로 결과가 나온다.\n        // 자바에서 '1' 같은 문자는 char으로 저장되지만 내부적으로는 유니코드(또는 ASCII) 숫자값으로 저장되기 때문에 산술 연산이 가능하다.\n        sum3 += numberString.charAt(i) - '0';\n    }\n    long end3 = System.currentTimeMillis();\n    System.out.println(\"3. charAt + 아스키코드 방식: \" + (end3 - start3) + \"ms, sum = \" + sum3);\n}\n[결과]\n1. split + parseInt 방식: 165ms, sum = 4497022\n2. toCharArray + 아스키코드 방식: 18ms, 합계 = 4497022\n3. charAt + 아스키코드 방식: 5ms, sum = 4497022\n```\n\n| 방법               | 설명             | 실행 시간       |\n| ---------------- | -------------- | ----------- |\n| split + parseInt | 문자열 분리 후 정수 변환 | 느림 (정규식 사용) |\n| toCharArray      | 문자 배열로 변환 후 계산 | 중간          |\n| charAt           | 직접 문자 접근 후 계산  | 가장 빠름       |\n\n## 3. 문제 회고\n+ 🔍 시도\n브론즈 문제로 난이도가 낮아 바로 구현할 수 있었다.\n\n+ 🛠 해결 과정\n아스키 코드를 이용한 방식도 있다는걸 알게되었다. 그래서 각 방법의 실행시간을 비교해보았다.\n\n+ ✅ 잘한 점\n다양한 접근 방식(총 3가지)을 직접 구현하고 비교 분석하였고 그로 인해 아스키코드 기반 처리 방식이 성능상 더 우수하다는 점을 직접 검증하였다. \n\n+ ⚠ 개선할 점\n아스키 코드 방식에서 `charAt()`과 `toCharArray()` 차이에 대한 근거를 조금 더 구체화하면 설득력이 높아질 것 같다.\n\n## 참조\n+ [String.split()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-)\n+ [String.toCharArray()](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#toCharArray--)\n"},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/67256 난이도 : Lv.1 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 문제의 설명대로 구현하였으며 2, 5, 8, 0과 같은 번호에 대해 거리를 계산해야 한다는 점을 고려하였다. 손의 위치를 갱신하며 각 번호…","fields":{"slug":"/archive/algorithm/6/"},"frontmatter":{"date":"May 04, 2025","title":"[프로그래머스] 프로그래머스 [카카오 인턴] 키패드 누르기 Java","description":"프로그래머스 [카카오 인턴] 키패드 누르기 Java","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://school.programmers.co.kr/learn/courses/30/lessons/67256](https://school.programmers.co.kr/learn/courses/30/lessons/67256)\n+ 난이도 : Lv.1\n+ 문제 내용 : \n\n## 2. 내 풀이 방법\n\n+ 시도1\n    + 접근 방법\n        + 문제의 설명대로 구현하였으며 2, 5, 8, 0과 같은 번호에 대해 거리를 계산해야 한다는 점을 고려하였다.\n        + 손의 위치를 갱신하며 각 번호의 거리 계산을 통해 더 가까운 손을 결정한다.\n        + 4방향 이동이 가능한 격자형 문제이므로 **맨해튼 거리**를 사용하여 두 손의 거리를 비교하였다.\n    \n    > 맨해튼 거리(Manhattan Distance)란?\n    > + 두 점 사이의 \"직선 거리\"가 아닌 격자 형태로 이동하는 거리를 나타내는 방식이다.\n    > + 격자형 평면에서 두 점이 있을 때 각 점의 x 좌표와 y 좌표를 이용하여 이동하는 데 드는 최소 거리를 계산하는 방법을 말한다.\n    > + 두 점 (x1, y1) , (x2, y2)가 있을때 맨해튼 거리는 다음과 같이 계산된다.\n    >   + x1-x2 + y1-y2\n\n    + 소스 코드\n    ```java\n    import java.util.*;\n    class Solution {\n        static Map<String, int[]> map = null;\n        \n        public String solution(int[] numbers, String hand) {\n            StringBuilder answer = new StringBuilder();\n            \n            map = new HashMap<>();\n            map.put(\"1\", new int[]{0, 0});\n            map.put(\"2\", new int[]{0, 1});\n            map.put(\"3\", new int[]{0, 2});\n            map.put(\"4\", new int[]{1, 0});\n            map.put(\"5\", new int[]{1, 1});\n            map.put(\"6\", new int[]{1, 2});\n            map.put(\"7\", new int[]{2, 0});\n            map.put(\"8\", new int[]{2, 1});\n            map.put(\"9\", new int[]{2, 2});\n            map.put(\"*\", new int[]{3, 0});\n            map.put(\"0\", new int[]{3, 1});\n            map.put(\"#\", new int[]{3, 2});\n            \n            String preL = \"*\";\n            String preR = \"#\";\n            \n            for (int num : numbers) {\n            if (num == 1 || num == 4 || num == 7) {\n                answer.append(\"L\");\n                preL = String.valueOf(num);\n            } else if (num == 3 || num == 6 || num == 9) {\n                answer.append(\"R\");\n                preR = String.valueOf(num);\n            } else {\n                // 거리 판단\n                String tmp = calcDist(preL, preR, String.valueOf(num), hand);\n                answer.append(tmp);\n                // 왼손, 오른손 위치 갱신\n                if (tmp.equals(\"L\")) {\n                        preL = String.valueOf(num);\n                } else {\n                    preR = String.valueOf(num);\n                }\n            }\n            }\n            \n            return answer.toString();\n        }\n        \n        // 거리 판단\n        private String calcDist(String preL, String preR, String target, String hand) {\n            int[] posTarget = map.get(target);\n            int[] posLeft = map.get(preL);\n            int[] posRight = map.get(preR);\n\n            int distL = Math.abs(posTarget[0] - posLeft[0]) + Math.abs(posTarget[1] - posLeft[1]);\n            int distR = Math.abs(posTarget[0] - posRight[0]) + Math.abs(posTarget[1] - posRight[1]);\n\n            if (distL < distR) {\n                return \"L\";\n            } else if (distR < distL) {\n                return \"R\";\n            } else {\n                return hand.equals(\"left\") ? \"L\" : \"R\";\n            }\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 해결을 위해 필요한 알고리즘을 떠올리기 어려웠다. 하지만 문제에서 요구하는 동작을 그대로 구현하자는 접근으로 시작했다.\n\n+ 🛠 해결 과정\n문제에서 주어진 키패드에 대한 정보와 거리를 계산하는 방법에 대해 고민하였다. 처음에는 BFS를 생각했으나 격자 형식이므로 맨해튼 거리로 해결 가능하다는 판단을 내렸다.\n2, 5, 8, 0 등 중간에 있는 숫자에 대해 거리 계산을 하는 부분이 중요했으며 이를 위해 각 손의 현재 위치를 갱신하며 계산하였다.\n\n+ ✅ 잘한 점\n문제를 직관적으로 풀면서 문제의 핵심 구조를 빠르게 파악했다.\n\n+ ⚠ 개선할 점\n처음에는 40분 이내에 풀기 목표를 설정했으나 예상보다 시간이 걸렸다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/9095 난이도 : 실버3 문제 내용 :  이 주어졌을 때, 정수 1, 2, 3을 더해서 을 만드는 모든 방법의 수를 구하는 문제이다. 순서가 다른 경우는 다른 방법으로 취급한다. 2. 내 풀이 방법 시도1 접근 방법 DP (Dynamic Programming) 이용…","fields":{"slug":"/archive/algorithm/4/"},"frontmatter":{"date":"May 02, 2025","title":"[BOJ] 백준 9095 1, 2, 3 더하기 Java","description":"백준 9095 1, 2, 3 더하기 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/9095](https://www.acmicpc.net/problem/9095)\n+ 난이도 : 실버3\n+ 문제 내용 :  `n`이 주어졌을 때, 정수 1, 2, 3을 더해서 `n`을 만드는 모든 방법의 수를 구하는 문제이다. 순서가 다른 경우는 다른 방법으로 취급한다.\n\n## 2. 내 풀이 방법\n\n+ 시도1\n    + 접근 방법\n        + **DP (Dynamic Programming)** 이용하였다.\n        + 점화식 계산 방법\n        | n   | 방법의 개수 |\n        |-----|------|\n        | 1   | 1   |\n        | 2   | 1+1, 2 => 2   |\n        | 3   | 1+1+1, 1+2, 2+1 => 3   |\n        | 4   | 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1 => 7 = 4 + 2 + 1   |\n        | 5   | 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+1+3, 1+2+1+1, 1+2+2, 1+3+1,2+1+1+1, 2+1+2, 2+2+1, 2+3, 3+1+1, 3+2 => 13 = 7 + 4 + 2   |\n    + 소스 코드\n    ```java\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) {\n            // n은 최대 10\n            int[] dp = new int[11];\n\n            // 초기값\n            dp[1] = 1;\n            dp[2] = 2;\n            dp[3] = 4;\n\n            // DP 계산\n            /**\n            * n   방법의 수\n            * 1   1\n            * 2   1+1, 2 => 2\n            * 3   1+1+1, 1+2, 2+1 => 3\n            * 4   1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1 => 7 = 4 + 2 + 1\n            * 5   1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+1+3, 1+2+1+1, 1+2+2, 1+3+1,2+1+1+1, 2+1+2, 2+2+1, 2+3, 3+1+1, 3+2 => 13 = 7 + 4 + 2\n            */\n            for (int i=4; i<=10; i++) {\n                /**\n                * dp[4] = dp[3] + dp[2] + dp[1]\n                * dp[4] = 4 + 2 + 1\n                * dp[4] = 7\n                */\n                dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\n    //            System.out.println(dp[i]);\n            }\n\n            // 입력\n            Scanner sc = new Scanner(System.in);\n            int t = sc.nextInt();\n            for (int i=0; i<t; i++) {\n                int n = sc.nextInt();\n                // 출력\n                System.out.println(dp[n]);\n            }\n        }\n    }\n    ```\n\n## 3. 문제 회고\n+ 🔍 시도\n1,2,3을 이용해서 n을 만들어야 한다는 문제의 조건을 보고 DP 알고리즘을 떠올렸다.\n\n+ 🛠 해결 과정\n점화식을 어떻게 세울지 고민하면서 여러 값을 직접 계산해보며 유도하였다.\n\n+ ✅ 잘한 점\n문제를 읽고 적절한 알고리즘을 바로 떠올렸다는 점이 잘했다.\n\n+ ⚠ 개선할 점\n점화식을 유도하는 과정에서 시간이 오래 걸렸다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1912 난이도 : 실버2 문제 내용 : 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구한다. 단, 수는 한 개 이상 선택해야 한다. 2. 내 풀이 방법 시도1 접근 방법 완전탐색(= 브루트포스)를 이용하였다. 문제점 완전탐색의 시간복잡도는  이…","fields":{"slug":"/archive/algorithm/5/"},"frontmatter":{"date":"May 02, 2025","title":"[BOJ] 백준 1912 연속합 Java","description":"백준 1912 연속합 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/1912](https://www.acmicpc.net/problem/1912)\n+ 난이도 : 실버2\n+ 문제 내용 : 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구한다. 단, 수는 한 개 이상 선택해야 한다.\n\n## 2. 내 풀이 방법\n\n+ 시도1\n    + 접근 방법\n        + 완전탐색(= 브루트포스)를 이용하였다.\n    + 문제점\n        + 완전탐색의 시간복잡도는 `O(n²)` 이다.\n        + n = 100,000이라면 O(n²) → 10⁵ * 10⁵ → **100억 × 100억 = 1조** 연산을 하게 되며 1초에 약 1억 연산 가능하기 때문에 시간 초과가 발생한다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n\n            int[] arr = new int[n];\n            for (int i=0; i<n; i++) {\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // 방법1) 완전탐색 = 브루트 포스\n            // 시간 초과 발생\n            long max = arr[0];\n            for (int i=0; i<n; i++) {\n                long sum = 0;\n                for (int j=i; j<n; j++) {\n                    sum += arr[j];\n                    max = Math.max(max, sum);\n                }\n            }\n            // 출력\n            System.out.println(max);\n        }\n    }\n    ```\n+ 시도2\n    + 접근 방법\n        + 누적합 기법을 이용하였다.\n        + 계산 방법\n        | i | arr| sum | max  |\n        | - | ----| ------------------------------------------ | ----------------------- |\n        | 1 | -4  | max(-4, 10 + (-4)) = max(-4, 6) = 6        | max(10, 6) = 10         |\n        | 2 | 3   | max(3, 6 + 3) = max(3, 9) = 9              | max(10, 9) = 10         |\n        | 3 | 1   | max(1, 9 + 1) = 10                         | max(10, 10) = 10        |\n        | 4 | 5   | max(5, 10 + 5) = 15                        | max(10, 15) = 15        |\n        | 5 | 6   | max(6, 15 + 6) = 21                        | max(15, 21) = 21        |\n        | 6 | -35 | max(-35, 21 + (-35)) = max(-35, -14) = -14 | max(21, -14) = 21       |\n        | 7 | 12  | max(12, -14 + 12) = max(12, -2) = 12       | max(21, 12) = 21        |\n        | 8 | 21  | max(21, 12 + 21) = 33                      | max(21, 33) = 33        |\n        | 9 | -1  | max(-1, 33 - 1) = 32                       | max(33, 32) = 33        |\n\n    > 누적합(prefix sum)이란?\n    > + 배열의 앞에서부터 차례로 합을 계산해서 저장해두는 방식이다.\n    > + 이렇게 하면 시간복잡도가 O(1) = 1회 연산 수행하게 된다.\n\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            StringTokenizer st = new StringTokenizer(br.readLine());\n\n            int[] arr = new int[n];\n            for (int i=0; i<n; i++) {\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // 방법2) 누적합 이용\n            long max = arr[0];\n            long sum = arr[0];\n\n            /**\n            * arr = [10 -4 3 1 5 6 -35 12 21 -1]\n            *\n            * sum = 10, max = 10\n            *\n            * arr[1] = -4 → sum = max(-4, 10 + (-4)) = max(-4, 6) = 6 → max = max(10, 6) = 10\n            * arr[2] =  3 → sum = max(3, 6 + 3) = max(3, 9) = 9     → max = max(10, 9) = 10\n            * arr[3] =  1 → sum = max(1, 9 + 1) = max(1, 10) = 10   → max = max(10, 10) = 10\n            * arr[4] =  5 → sum = max(5, 10 + 5) = max(5, 15) = 15  → max = max(10, 15) = 15\n            */\n            for (int i=1; i<n; i++) {\n                sum = Math.max(arr[i], sum + arr[i]);\n                max = Math.max(max, sum);\n            }\n\n            // 출력\n            System.out.println(max);\n        }\n    }\n    ```\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 생각나는대로 구현을 하였는데 의도치 않게 완전탐색 방식으로 구현하게 되었다.\n\n+ 🛠 해결 과정\n시간 초과가 발생하여 효율적인 누적합 계산 방법을 찾아보았고 그 과정에서 prefix sum(누적합) 기법을 적용하여 문제를 해결할 수 있었다.\n\n+ ✅ 잘한 점\n직관적인 방식으로 먼저 접근하면서 문제의 구조를 빠르게 파악했다.\n\n+ ⚠ 개선할 점\n문제를 처음 읽을 때 시간 복잡도를 고려하지 못했다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/2805 난이도 : 실버2 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 이분탐색 방법을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제에 맞는 알고리즘을 생각하지 못하였다. 🛠 해결 과정 문제 유형을 참고하여 이분 탐색 알고리즘을 적용해야 한다는 것을 알…","fields":{"slug":"/archive/algorithm/3/"},"frontmatter":{"date":"April 27, 2025","title":"[BOJ] 백준 2805 나무 자르기 Java","description":"백준 2805 나무 자르기 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/2805](https://www.acmicpc.net/problem/2805)\n+ 난이도 : 실버2 \n+ 문제 내용 : \n\n## 2. 내 풀이 방법\n+ 시도1\n    + 접근 방법\n        + 이분탐색 방법을 이용하였다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 1. 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            // 나무의 수\n            int n = Integer.parseInt(st.nextToken());\n            // 나무의 길이\n            int m = Integer.parseInt(st.nextToken());\n\n            int[] arr = new int[n];\n            int high = 0;\n            int low = 0;\n\n            st = new StringTokenizer(br.readLine());\n            for (int i=0; i<n; i++) {\n                arr[i] = Integer.parseInt(st.nextToken());\n                high = Math.max(high, arr[i]);\n            }\n\n            // 2. 이분 탐색\n            int result = 0;\n\n            while (high >= low) {\n                int mid = (high + low) / 2;\n                long sum = 0;\n\n                // 현재 높이(mid)로 잘랐을 때 얻는 나무 길이 합 구하기\n                for (int num : arr) {\n                    if (num > mid) {\n                        sum += (num - mid);\n                    }\n                }\n\n                if (sum >= m) {\n                    result = mid;       // 조건을 만족했으니 일단 기록\n                    low = mid + 1;      // 절단기 높이를 더 높여본다\n                } else {\n                    high = mid - 1;     // 절단기 높이를 낮춰야 함\n                }\n            }\n\n            System.out.println(result);\n        }\n    }\n    ```\n\n## 3. 문제 회고\n+ 🔍 시도\n문제에 맞는 알고리즘을 생각하지 못하였다.\n\n+ 🛠 해결 과정\n문제 유형을 참고하여 이분 탐색 알고리즘을 적용해야 한다는 것을 알게 되었고 이를 기반으로 문제를 해결할 수 있었다.\n\n+ ✅ 잘한 점\n\n+ ⚠ 개선할 점\n이분 탐색 유형 문제를 많이 풀어봐야겠다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1012 난이도 : 실버2 문제 내용 : 배추가 심어진 곳끼리 연결되어 있으면 하나의 \"덩어리\"로 보고 총 몇 개의 덩어리가 있는지 세는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 BFS 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 B…","fields":{"slug":"/archive/algorithm/1/"},"frontmatter":{"date":"April 26, 2025","title":"[BOJ] 백준 1012 유기농 배추 Java","description":"백준 1012 유기농 배추 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/1012](https://www.acmicpc.net/problem/1012)\n+ 난이도 : 실버2 \n+ 문제 내용 : 배추가 심어진 곳끼리 연결되어 있으면 하나의 \"덩어리\"로 보고 총 몇 개의 덩어리가 있는지 세는 문제이다.\n\n## 2. 내 풀이 방법\n+ 시도1\n    + 접근 방법\n        + BFS 알고리즘을 이용하였다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n\n    public class Main {\n        static int[][] arr = null;\n        static boolean[][] visited = null;\n        static int result = 0;\n\n        static int m = 0;\n        static int n = 0;\n\n        // 상하좌우 이동\n        static int[] dx = {-1, 1, 0, 0};\n        static int[] dy = {0, 0, -1, 1};\n\n        public static void main(String[] args) throws IOException {\n            String[] tmpArr = null;\n\n            // 1. 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            // 테스트케이스\n            int t = Integer.parseInt(br.readLine());\n\n            for (int index=0; index<t; index++) {\n                tmpArr = br.readLine().split(\" \");\n                // 배추밭의 가로길이 M\n                m = Integer.parseInt(tmpArr[0]);\n                // 배추밭의 세로길이 N\n                n = Integer.parseInt(tmpArr[1]);\n                // 배추가 심어져 있는 위치의 개수 K\n                int k = Integer.parseInt(tmpArr[2]);\n\n                // 2. 인접행렬 만들기\n                arr = new int[m][n];\n\n                for (int i=0; i<k; i++) {\n                    tmpArr = br.readLine().split(\" \");\n                    int a = Integer.parseInt(tmpArr[0]);\n                    int b = Integer.parseInt(tmpArr[1]);\n\n    //                System.out.println(a + \" / \" + b);\n\n                    arr[a][b] = 1;\n                }\n\n                // 3. 방문배열 만들기\n                visited = new boolean[m][n];\n\n                result = 0;\n\n                // 4. 탐색\n                for (int i=0; i<m; i++) {\n                    for (int j=0; j<n; j++) {\n                        if (arr[i][j] == 1 && !visited[i][j]) {\n                            bfs(i, j);\n                            result++;\n                        }\n                    }\n                }\n\n                // 5. 출력\n                System.out.println(result);\n            }\n        }\n\n        static void bfs (int x, int y) {\n            visited[x][y] = true;\n\n            Queue<int[]> queue = new LinkedList<>();\n            queue.add(new int[] {x, y});\n\n            while(!queue.isEmpty()) {\n                int[] node = queue.poll();\n\n                int nowX = node[0];\n                int nowY = node[1];\n\n                for (int i=0; i<4; i++) {\n                    int nx = nowX + dx[i];\n                    int ny = nowY + dy[i];\n\n                    if (nx >= 0 && ny >= 0 && nx < m && ny < n) {\n                        if (arr[nx][ny] == 1 && !visited[nx][ny]) {\n                            queue.add(new int[] {nx, ny});\n                            visited[nx][ny] = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    ``` \n\n## 3. 문제 회고\n+ 🔍 시도\n문제를 읽고 BFS 알고리즘과 4방향 탐색(상하좌우)이 필요하다고 빠르게 판단했다.\n`(0,0)` 위치에서만 BFS 탐색을 시도했다.\n\n+ 🛠 해결 과정\n`(0,0)`만 탐색하면 전체 영역을 탐색하지 못하는 문제를 발견했다.\n이후 배열 전체를 순회하며 방문하지 않은 영역마다 BFS를 수행하는 방식으로 접근을 수정했다.\n\n+ ✅ 잘한 점\n문제를 읽자마자 BFS로 해결해야 한다는 판단을 빠르게 내렸다.\nDFS/BFS 문제를 여러 번 풀어본 경험이 도움이 되었다.\n\n+ ⚠ 개선할 점\nBFS + 4방향 탐색까진 좋았지만 \"전체 배열을 순회하며 시작점을 찾아야 한다\"는 기본적인 접근을 처음부터 놓쳤다.\n\n## 참조"},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11053 난이도 : 실버2 문제 내용 : 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 TreeSet에 이용해서 중복제거 + 정렬을 하였다. 문제점 TreeSet에 넣어서 중복제거 + 정렬하고 input.size 를 출…","fields":{"slug":"/archive/algorithm/2/"},"frontmatter":{"date":"April 26, 2025","title":"[BOJ] 백준 11053 가장 긴 증가하는 부분 수열 Java","description":"백준 11053 가장 긴 증가하는 부분 수열 Java","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 문제 요약\n+ 문제 URL : [https://www.acmicpc.net/problem/11053](https://www.acmicpc.net/problem/11053)\n+ 난이도 : 실버2 \n+ 문제 내용 : 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다.\n\n## 2. 내 풀이 방법\n+ 시도1\n    + 접근 방법\n        + TreeSet에 이용해서 중복제거 + 정렬을 하였다.\n    + 문제점\n        + TreeSet에 넣어서 중복제거 + 정렬하고 input.size 를 출력하고 있는데\n          이건 서로 다른 수의 개수를 구하는 것이지 문제의 핵심인 **가장 긴 증가하는 부분 수열**을 구하게 아니다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 1. 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n            int n = Integer.parseInt(br.readLine());\n            String[] tmp = br.readLine().split(\" \");\n\n            // 2. 구현\n            // TreeSet : 중복제거 및 자동정렬이 된다.\n            Set<Integer> input = new TreeSet<>();\n            for (int i=0; i<n; i++) {\n                input.add(Integer.parseInt(tmp[i]));\n            }\n\n            // System.out.println(input);\n\n            // 3. 출력\n            System.out.println(input.size());\n        }\n    }\n    ```\n+ 시도2\n    + 접근 방법\n        + DP 알고리즘을 이용하였다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 1. 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n            int n = Integer.parseInt(br.readLine());\n\n            int[] arr = new int[n];\n            StringTokenizer st = new StringTokenizer(br.readLine());\n\n            for (int i=0; i<n; i++) {\n                arr[i] = Integer.parseInt(st.nextToken());\n            }\n\n            // 2. dp 배열 생성\n            int[] dp = new int[n];\n            Arrays.fill(dp, 1);  // 자기 자신만 있는 경우 길이 1\n\n            for (int i=0; i<n; i++) {\n                for (int j=0; j<i; j++) {\n                    if (arr[j] < arr[i]) {\n                        dp[i] = Math.max(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n\n            // 3. 출력\n            int result = 0;\n            for (int i=0; i<n; i++) {\n                result = Math.max(result, dp[i]);\n            }\n\n            System.out.println(result);\n        }\n    }\n    ``` \n\n## 3. 문제 회고\n+ 🔍 시도\n처음에는 TreeSet을 사용해서 정렬과 중복 제거를 통해 문제를 풀려고 했지만 이는 문제의 의도와 맞지 않았다.\n문제 밑에 있는 알고리즘의 분류를 보고 동적 계획법(DP)을 이용해서 풀었다.\n\n+ 🛠 해결 과정\ndp[i] = i번째 숫자를 마지막으로 했을 때의 LIS 길이라고 정의하고 i번째 수를 기준으로 0부터 i-1까지 순회하면서\narr[j] < arr[i] 이면 dp[i] = Math.max(dp[i], dp[j] + 1)로 갱신했다. (DP bottom-up형식)\n\n+ ✅ 잘한 점\n\n+ ⚠ 개선할 점\nDP 문제 유형에 대해 좀 더 풀어봐야겠다.\n\n\n## 참조"},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 DFS/BFS 문제 URL : https://www.acmicpc.net/problem/18126 2. 공부한 내용 본인의 언어로 정리하기 시도1(틀림) 접근 방법 인접행렬을 이용해서 가장 먼 거리를 구했으나 틀렸다. 시도2(틀림) 접근 방법 인접 리스트를 이용해서 풀어보았다. 시도3(맞음) 접근 방법 구글링…","fields":{"slug":"/archive/study/99클럽코테스터디/17/"},"frontmatter":{"date":"April 22, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 17일차 TIL + DFS/BFS","description":"99클럽 코테 스터디 17일차 TIL + DFS/BFS","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ DFS/BFS\n+ 문제 URL : https://www.acmicpc.net/problem/18126\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1(틀림)\n    + 접근 방법 \n        + 인접행렬을 이용해서 가장 먼 거리를 구했으나 틀렸다.\n+ 시도2(틀림)\n    + 접근 방법\n        + 인접 리스트를 이용해서 풀어보았다.\n+ 시도3(맞음)\n    + 접근 방법\n        + 구글링도 해보고 GPT한테도 반례를 찾아보았으나 무엇때문에 틀린지 몰랐으나.. 자료형의 문제였다.\n    + 소스코드\n    ```java\n    import java.io.*;\n    public class Main {\n        static int[][] arr = null;  // 인접행렬\n        static boolean[] visited = null;    // 방문배열\n\n        static long result = 0;\n\n        public static void main(String[] args) throws IOException {\n            // 1. 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n\n            // 2. 인접행렬 만들기\n            arr = new int[n+1][n+1];\n            for (int i=0; i<n-1; i++) {\n                String[] tmp = br.readLine().split(\" \");\n                int a = Integer.parseInt(tmp[0]);\n                int b = Integer.parseInt(tmp[1]);\n                int c = Integer.parseInt(tmp[2]);\n                // A번 방과 B번 방 사이를 양방향으로 연결하는 길의 길이가 C임을 의미한다.\n                arr[a][b] = c;\n                arr[b][a] = c;\n            }\n            // 3. 방문배열 만들기\n            visited = new boolean[n+1];\n            // 4. 탐색\n            dfs(1, 0);\n\n            // 5. 출력\n            System.out.println(result);\n        }\n\n        private static void dfs(int node, long dist) {\n            // 방문여부 표시\n            visited[node] = true;\n\n            // 최대 거리 갱신\n            if (dist > result) {\n                result = dist;\n            }\n            // System.out.println(\"dist = \" +dist);\n\n            // 재귀\n            for (int i=1; i<arr.length; i++) {\n                if (arr[node][i] != 0 && !visited[i]) {\n                    // System.out.println(\"출력 = \" + (dist + arr[node][i]));\n                    dfs(i, dist + arr[node][i]);\n                }\n            }\n        }\n    }\n    ```\n    \n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n\"양방향\"이라는 단어와 가장 먼 거리를 구하는 문제로 판단했다. DFS 또는 BFS를 활용하면 풀 수 있겠다고 생각했고 그 방향으로 접근했다.\n\n+ 해결 과정   \n문제 자체는 잘 파악했지만 int형 오버플로우는 전혀 예상하지 못했다. long형으로 변경하니 정답이 나와서 허무한 느낌이 들었다. ㅠㅠ\n\n+ 배운 점   \n문제를 읽고 적절한 알고리즘을 떠올린 점은 잘했다. 하지만 큰 수가 나올 수 있는 경우를 항상 염두에 두고 웬만하면 int보다는 long을 사용하는 습관을 들이자."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 시뮬레이션 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/72410 2. 공부한 내용 본인의 언어로 정리하기 시도1(맞음) 접근 방법 문제를 읽고 단계별로 구현을 하였다. 소스 코드 3. 오늘의 회고 문제 상황과 시도 문제를 읽고 단계별…","fields":{"slug":"/archive/study/99클럽코테스터디/16/"},"frontmatter":{"date":"April 21, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 16일차 TIL + 시뮬레이션","description":"99클럽 코테 스터디 16일차 TIL + 시뮬레이션","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 시뮬레이션\n+ 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/72410\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1(맞음)\n    + 접근 방법 \n        + 문제를 읽고 단계별로 구현을 하였다.\n    + 소스 코드\n    ```java\n    class Solution {\n        public String solution(String new_id) {\n            String answer = \"\";\n            // 1단계 new_id의 모든 대문자를 대응되는 소문자로 치환합니다.\n            answer = new_id.toLowerCase(); \n            // 2단계 new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.\n            answer = answer.replaceAll(\"[^a-z0-9._-]\", \"\");\n            //System.out.println(\"[2] -> \" + answer);\n            // 3단계 new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.\n            answer = answer.replaceAll(\"\\\\.+\", \".\");\n            // 4단계: new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.\n            if (answer.startsWith(\".\")) {\n                answer = answer.substring(1);\n            }\n            if (answer.endsWith(\".\")) {\n                answer = answer.substring(0, answer.length() - 1);\n            }\n            // 5단계 new_id가 빈 문자열이라면, new_id에 \"a\"를 대입합니다.\n            if ( answer.isEmpty() ) {\n                answer = \"a\";\n            }\n            // 6단계 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.\n            if ( answer.length() >= 16 ) {\n                answer = answer.substring(0, 15);\n                if (answer.endsWith(\".\")) {\n                    answer = answer.substring(0, answer.length() - 1);\n                }\n            }\n            System.out.println(\"[6] -> \" + answer);\n            // 만약 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.\n            // 7단계 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.\n            if ( answer.length() <= 2 ) {\n                //System.out.println(\"[7] -> \" + answer);\n                String last = String.valueOf(answer.charAt(answer.length() - 1));\n                //System.out.println(\"[7] -> last : \" + last);\n                while (true) {\n                    if (answer.length() == 3) {\n                        break;\n                    }\n                    answer += last;\n\n                // System.out.println(\"[7] -> answer : \" + answer);\n                }\n            }\n            return answer;\n        }\n    }\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n문제를 읽고 단계별로 풀어보면 되겠다고 생각하였다.\n\n+ 해결 과정   \n문자열 관련 문제라고 생각했는데 풀고 나서 힌트를 보니 시뮬레이션 문제였다.\n\n+ 배운 점   \n문자열 함수와 정규표현식을 알고있다면 쉽게 풀 수 있는 문제였다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 동적계획법 문제 URL : https://www.acmicpc.net/problem/17484 2. 공부한 내용 본인의 언어로 정리하기 시도1(맞음) 접근 방법 대문자여부를 체크하여 대문자로 변환 소스 코드 3. 오늘의 회고 문제 상황과 시도 해결 과정 배운 점","fields":{"slug":"/archive/study/99클럽코테스터디/14/"},"frontmatter":{"date":"April 20, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 14일차 TIL + 문자열","description":"99클럽 코테 스터디 14일차 TIL + 문자열","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":true},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 동적계획법\n+ 문제 URL : https://www.acmicpc.net/problem/17484\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1(맞음)\n    + 접근 방법 \n        + 대문자여부를 체크하여 대문자로 변환\n    + 소스 코드\n    ```java\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n\n+ 해결 과정   \n\n+ 배운 점   \n"},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 동적계획법 문제 URL : https://www.acmicpc.net/problem/17271 2. 공부한 내용 본인의 언어로 정리하기 시도1 접근 방법 이 10000 이하의 자연수이니까 완전탐색으로 하면 시간초과가 날 수 있음 n분 동안의 모든 조합을 찾는 방법으로 풀어야겠다고 생각했음 소스 코드 3. 오늘…","fields":{"slug":"/archive/study/99클럽코테스터디/15/"},"frontmatter":{"date":"April 20, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 15일차 TIL + 동적계획법","description":"99클럽 코테 스터디 15일차 TIL + 동적계획법","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 동적계획법\n+ 문제 URL : https://www.acmicpc.net/problem/17271\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1\n    + 접근 방법 \n        + `n`이 10000 이하의 자연수이니까 완전탐색으로 하면 시간초과가 날 수 있음\n        + n분 동안의 모든 조합을 찾는 방법으로 풀어야겠다고 생각했음\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int n = Integer.parseInt(st.nextToken());  // 총 싸움시간\n            int m = Integer.parseInt(st.nextToken());  // B스킬 시전 시간\n\n            int mod = 1_000_000_007;\n\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n\n            for (int i = 1; i <= n; i++) {\n                // 스킬 A (1분) 사용: 이전 시간(i-1분)에 A 하나 붙이면 i분 가능\n                dp[i] = dp[i - 1];\n                // 스킬 B (m분) 사용: i가 m 이상일 때만 가능\n                // 이전 시간(i - m분)에 B 하나 붙이면 i분 가능\n                if (i >= m) {\n                    dp[i] = (dp[i] + dp[i - m]) % mod;\n                }\n            }\n\n            // 출력\n            System.out.println(dp[n]);\n        }\n    }\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n문제를 읽고, 처음에는 n분 동안의 모든 경우의 수를 찾아야겠다고 판단했다.\n\n+ 해결 과정   \n처음에는 동적 계획법 문제라는 생각을 하지 못하고 접근하였다.\n\n+ 배운 점   \n최근 여러 문제에서 동적 계획법 유형이 반복해서 등장하고 있지만, 아직 구현에 익숙하지 않다. DP가 가장 취약한 부분이라는 점을 다시금 느꼈고, 보다 집중적으로 연습할 필요가 있음을 깨달았다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 문자열 문제 URL : https://www.acmicpc.net/problem/2156 2. 공부한 내용 본인의 언어로 정리하기 시도1(맞음) 접근 방법 대문자여부를 체크하여 대문자로 변환 소스 코드 3. 오늘의 회고 문제 상황과 시도 오늘의 문제는 쉬어서 별다른 문제가 없었다. 해결 과정 String보다 …","fields":{"slug":"/archive/study/99클럽코테스터디/13/"},"frontmatter":{"date":"April 16, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 13일차 TIL + 문자열","description":"99클럽 코테 스터디 13일차 TIL + 문자열","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 문자열\n+ 문제 URL : https://www.acmicpc.net/problem/2156\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1(맞음)\n    + 접근 방법 \n        + 대문자여부를 체크하여 대문자로 변환\n    + 소스 코드\n    ```java\n    class Solution {\n        public String solution(String s) {\n            StringBuilder sb = new StringBuilder();\n            char[] arr = s.toCharArray();\n            boolean isUpper = true;  // 첫글자는 무조건 대문자여야 하니까 \n\n            for (int i=0; i<arr.length; i++) {\n                if (arr[i] == ' ') {\n                    sb.append(arr[i]);\n                    isUpper = true;\n                } else {\n                    if (isUpper) {\n                        // 대문자로 변환\n                        sb.append(Character.toUpperCase(arr[i]));\n                    } else {\n                        // 소문자로 변환\n                        sb.append(Character.toLowerCase(arr[i]));\n                    }\n                    isUpper = false;\n                }\n            }\n\n            return sb.toString();\n        }\n    }\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n오늘의 문제는 쉬어서 별다른 문제가 없었다.\n\n+ 해결 과정   \nString보다 char타입이 더 속도가 빠르다고 생각이 들어서 char[] 타입으로 변경하였고 문자열 조작시 불변객체인 String을 그대로 사용하는 것보다 StringBuilder를 이용해서 최적화를 하였다.\n\n+ 배운 점   \n"},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 동적계획법 문제 URL : https://www.acmicpc.net/problem/2156 2. 공부한 내용 본인의 언어로 정리하기 시도1 접근 방법 배열을 순회하면서 큰 수끼리 더해보며 어떨까? 문제점 연속적으로 포도잔을 마실수 없으므로 문제에 부합하지 않는다. 시도2 접근 방법 모든 경우를 탐색하면서 연…","fields":{"slug":"/archive/study/99클럽코테스터디/12/"},"frontmatter":{"date":"April 15, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 12일차 TIL + 동적계획법","description":"99클럽 코테 스터디 12일차 TIL + 동적계획법","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 동적계획법\n+ 문제 URL : https://www.acmicpc.net/problem/2156\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1\n    + 접근 방법 \n        + 배열을 순회하면서 큰 수끼리 더해보며 어떨까?\n    + 문제점\n        + **연속적으로 포도잔을 마실수 없으므로 문제에 부합하지 않는다.**\n+ 시도2\n    + 접근 방법\n        + 모든 경우를 탐색하면서 연속된 3잔을 막는 방식 => 완전탐색\n    + 문제점\n        + 완전탐색의 최악의 경우 시간복잡도는 O(2^n)으로 보고 n이 20만 넘어도 너무 커진다.\n        + `2^20 = 1,048,576`\n        + 그래서 시간 초과가 발생할 가능성이 높다.\n+ 시도3\n    + 접근 방법\n        + 다이나믹 프로그래밍 알고리즘 Bottom-Up 방식 이용하였다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n\n            int[] arr = new int[n + 1];\n            int[] dp = new int[n + 1];\n\n            for (int i=1; i<=n; i++) {\n                arr[i] = Integer.parseInt(br.readLine());\n            }\n\n            // 기본 초기값 설정 (n이 1, 2일 수도 있어서 따로 처리)\n            dp[1] = arr[1];\n            if (n >= 2) {\n                dp[2] = arr[1] + arr[2];\n            }\n\n            // DP 점화식 적용\n            for (int i = 3; i <= n; i++) {\n                dp[i] = Math.max(dp[i - 1], \n                        Math.max(dp[i - 2] + arr[i], \n                                dp[i - 3] + arr[i - 1] + arr[i]));\n            }\n\n            // 출력\n            System.out.println(dp[n]);\n        }\n    }\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n문제를 다양한 각도에서 접근해보며 여러 가지 시도를 했고 기본 로직 구성에는 성공했으나 결론적으로 DP를 제대로 구현하지 못했다.\n\n+ 해결 과정   \n문제를 단순 반복문과 조건문으로 해결하려 했으나 시간 복잡도에서 문제가 발생했다. 이후 메모이제이션과 점화식을 고려하며 DP 방식으로 전환하려 했지만 상태 정의와 배열 설계에서 미흡함이 있었다.\n결국 참고 자료를 통해 DP 구현 방식을 다시 점검하고 문제 유형에 따라 어떻게 상태를 나누고 저장할지 구체화하는 연습이 필요함을 느꼈다.\n\n+ 배운 점   \n문제를 풀때마다 느끼는것인데 유형별로 한번씩 쭉 풀어볼 필요가 있을것같다. 문제를 읽고 어떤 알고리즘을 쓰면 좋을지 감을 잡는게 먼저 필요할것같다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 이분탐색 문제 URL : https://www.acmicpc.net/problem/16401 2. 공부한 내용 본인의 언어로 정리하기 시도1 소스 코드 이분 탐색 정렬된 배열이나 리스트에서 원하는 값을 빠르게 찾는 알고리즘를 말한다. 반드시 오름차순(또는 내림차순)으로 정렬되어 있어야 한다. 동작 방식 배열의…","fields":{"slug":"/archive/study/99클럽코테스터디/11/"},"frontmatter":{"date":"April 14, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 11일차 TIL + 이분탐색","description":"99클럽 코테 스터디 11일차 TIL + 이분탐색","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 이분탐색\n+ 문제 URL : https://www.acmicpc.net/problem/16401\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1\n    + 소스 코드\n    ```java\n    import java.io.*;\n    public class Main {\n        public static void main(String[] args) throws IOException {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] tmpArr = br.readLine().split(\" \");\n\n            int m = Integer.parseInt(tmpArr[0]); // 조카 수\n            int n = Integer.parseInt(tmpArr[1]); // 과자 수\n\n            long[] inputArr = new long[n];\n            long maxLen = 0;\n\n            String[] tpmArr2 = br.readLine().split(\" \");\n            for (int i=0; i<n; i++) {\n                inputArr[i] = Long.parseLong(tpmArr2[i]);\n                maxLen = Math.max(maxLen, inputArr[i]);\n            }\n\n            long left = 1;        // 시작점\n            long right = maxLen;  // 끝점\n            long result = 0;\n\n            // 길이를 1부터 가장 긴 과자 길이까지 이진 탐색 시작\n            // \"숫자 범위\"에서 최적의 값을 찾는 문제는 → 이진 탐색을 숫자 범위에 해야 한다.(예: 나무 자르기, 랜선 자르기, 과자 나눠주기 등)\n            while (left <= right) {\n                long mid = (left + right) / 2;\n                long count = 0;\n                // 각 과자를 mid 길이로 잘랐을 때 몇 개가 나오는지 합산\n                for (long num : inputArr) {\n                    count += num / mid;\n                }\n                // 줄 수 있는 과자 수가 조카 수 이상이면 더 길게 자를 수도 있음\n                if (count >= m) {\n                    result = mid;\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            // 출력\n            System.out.println(result);\n        }\n    }\n    ```\n+ 이분 탐색\n    + 정렬된 배열이나 리스트에서 원하는 값을 빠르게 찾는 알고리즘를 말한다.\n    + 반드시 오름차순(또는 내림차순)으로 정렬되어 있어야 한다.\n    + 동작 방식\n        + 배열의 중간값을 찾는다.\n        + 찾는 값이 중간값보다 작으면 왼쪽, 크면 오른쪽으로 탐색 범위를 줄인다.\n        + 범위가 좁아질 때까지 반복한다.\n    + 사용되는 상황\n        + 효율적으로 검색이 필요할 때\n        + 예: 값의 존재 여부, 최댓값/최솟값 구하기, 조건을 만족하는 값 찾기, 나무 자르기, 랜선 자르기, 과자 나눠주기\n        \n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n문제를 보고 어떤 알고리즘을 사용해야 할지 바로 떠오르지 않았다. 완전 탐색으로 접근하면 시간 초과가 날 것 같았고, DFS나 BFS 알고리즘도 적용되지 않을 것 같았다.\n\n+ 해결 과정   \n힌트를 통해 이분탐색을 사용해야 한다는 것을 알게 되었지만 이 알고리즘이 생소해서 구현하는 데 어려움이 있었다.\n\n+ 배운 점   \n이분탐색은 처음 접했을 때 구현이 어렵지만 문제를 풀고 나니 그 효율성을 잘 이해할 수 있었다.\n알고리즘을 배우고 익히는 과정에서 반복적인 연습의 중요성을 다시 한 번 느꼈다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 탐욕법 문제 URL : https://www.acmicpc.net/problem/1783 2. 공부한 내용 본인의 언어로 정리하기 시도1(틀림) 접근 방법 경우의 수를 전부 탐색해서 최대값을 찾아야 하는 문제인가 싶어 DFS 알고리즘을 떠올렸다. 문제점 DFS는 모든 경로를 탐색하므로 이동 횟수가 많아질 경우…","fields":{"slug":"/archive/study/99클럽코테스터디/10/"},"frontmatter":{"date":"April 11, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 10일차 TIL + 탐욕법","description":"99클럽 코테 스터디 10일차 TIL + 탐욕법","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 탐욕법\n+ 문제 URL : https://www.acmicpc.net/problem/1783\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1(틀림)\n    + 접근 방법 \n        + 경우의 수를 전부 탐색해서 최대값을 찾아야 하는 문제인가 싶어 DFS 알고리즘을 떠올렸다.\n    + 문제점\n        + **DFS는 모든 경로를 탐색하므로 이동 횟수가 많아질 경우 시간 초과 발생 가능성이 있다.**\n        + 이동 경로를 모두 찾는 게 아니라 **이동 가능한 칸 수의 최댓값을 구하는 것**이므로 DFS는 적절하지 않는다.\n+ 시도2(맞음)\n    + 접근 방법 \n        + 이동할 수 있는 규칙이 제한되어 있다. (체스판 위 나이트 이동과 유사)\n        + 이동 규칙 중 2칸 위로 1칸 옆으로 이동만 가능하므로 가능한 이동 방식이 총 4가지이다.\n        + 문제에서 주어진 조건을 기반으로 그리디하게 분기 처리하였다.\n    + **풀이 핵심**\n        + 세로 길이가 1인 경우: 이동 불가 → `1`\n        + 세로 길이가 2인 경우: 이동 가능한 칸이 제한됨 → `min(4, (가로 - 1) / 2 + 1)`\n        + 세로가 3 이상인 경우\n            + 가로가 7 미만일 경우 → `min(4, 가로)`\n            + 가로가 7 이상일 경우 → `가로로 - 2`\n    + 소스 코드\n    ```java\n    import java.io.*;\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String[] tmp = br.readLine().split(\" \");\n            int n = Integer.parseInt(tmp[0]);  // 세로\n            int m = Integer.parseInt(tmp[1]);  // 가로\n\n            int result = 0;\n\n            if (n == 1) {\n                // 이동 불가, 시작칸만 방문\n                result = 1;\n            } else if (n == 2) {\n                // 위아래 이동이 안되니, (1,2), (-1,2)만 사용 가능 => 4번까지만 가능\n                result = Math.min(4, (m + 1) / 2);\n            } else if (n >= 3 && m < 7) {\n                // 위아래는 충분하지만 오른쪽 이동이 부족해서 4가지 이동을 다 못 씀\n                result = Math.min(4, m);\n            } else {\n                // 4가지 이동 다 사용 가능\n                result = m - 2;\n            }\n\n            // 출력\n            System.out.println(result);\n        }\n    }\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n문제를 처음 보고 DFS로 모든 경로를 탐색해야 하는 건가 싶었다. 방문한 칸의 수를 최대화하려면 모든 경우를 봐야 한다고 생각했기 때문이다.\n\n+ 해결 과정   \n하지만 힌트를 보니 이 문제는 탐욕법으로 푸는 것이 적절하다는 것을 알게 되었고 그 순간 내가 접근했던 방식이 잘못되었음을 깨달았다. 이후 조건을 분기 처리하는 방식으로 접근했더니 훨씬 간결하고 효율적으로 문제를 해결할 수 있었다.\n\n+ 배운 점   \n이 문제는 단순히 이동 규칙을 구현하는 것이 아니라, 제한된 조건 안에서 최적의 해를 찾는 것이 핵심이었다. 앞으로는 문제의 조건을 잘 분석하고 거기에 맞는 알고리즘이 무엇인지 먼저 판단하는 연습을 더 많이 해야겠다고 느꼈다. "},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 탐욕법 문제 URL : https://www.acmicpc.net/problem/2437 2. 공부한 내용 본인의 언어로 정리하기 시도1(틀림) 접근 방법 1부터 1000까지 돌면서 가능한 무게를 추로 하나씩 빼본다. 문제점 단순히 무게를 빼면 부분 조합을 체크 할 수 없다. 시도2(맞음) 접근 방법 그리디 …","fields":{"slug":"/archive/study/99클럽코테스터디/9/"},"frontmatter":{"date":"April 10, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 9일차 TIL + 탐욕법","description":"99클럽 코테 스터디 9일차 TIL + 탐욕법","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 탐욕법\n+ 문제 URL : https://www.acmicpc.net/problem/2437\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시도1(틀림)\n    + 접근 방법 \n        + 1부터 1000까지 돌면서 가능한 무게를 추로 하나씩 빼본다.\n    + 문제점 \n        + **단순히 무게를 빼면 부분 조합을 체크 할 수 없다.**\n        ```\n        추 무게 : [1,1,3]\n        조합 : 1, 2(1+1), 3, 4(1+3), 5(1+1+3)\n        ```\n+ 시도2(맞음)\n    + 접근 방법 \n        + 그리디 알고리즘을 적용해본다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    import java.util.*;\n\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            String[] tmpArr = br.readLine().split(\" \");\n\n            int[] inputArr = new int[n];\n            for (int i=0; i<n; i++) {\n                inputArr[i] = Integer.parseInt(tmpArr[i]);\n            }\n\n            /**\n            * 정렬 + 누적합을 이용해서 최소 무게를 구해야함\n            */\n            Arrays.sort(inputArr);\n\n            int result = 1; // 현재까지 만들 수 있는 무게의 범위\n\n            /**\n            * 만약 현재 추의 무게가 result보다 작거나 같다면 result을 확장시킬 수 있음\n            * 그렇지 않다면 result는 만들 수 없는 가장 작은 무게임\n            */\n            for (int i=0; i<n; i++) {\n                // 이제 무게를 만들 수 없음\n                if (inputArr[i] > result) {\n                    break;\n                }\n                result += inputArr[i];\n    //            System.out.println(result);\n            }\n            // 출력\n            System.out.println(result);\n        }\n    }\n    ```\n+ 그리디 알고리즘(Greedy Algorithm)\n    + 문제를 해결할 때 **가장 최적의 선택을 하는 알고리즘**를 말한다.\n    + **이 문제에서는 정렬 + 누적합 + 그리디를 이용한 것이지 정렬+누적합 자체가 그리디 알고리즘을 말하는 것이 아니다.**\n    + 핵심 개념\n        + 탐욕적 선택\n        + 부분 문제 최적성\n    + 장점\n        + 계산 속도가 빠르다.\n    + 단점\n        + 문제에 따라 탐욕적 접근이 실패할 수 있다.\n    + 대표적인 문제\n        + 동전 거스름돈\n        + 회의실 배정\n        + 최소 신장 트리\n        + 다익스트라 알고리즘\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n문제를 보고 1부터 1000까지 돌면서 가능한 무게를 추로 하나씩 빼본다라고 생각했지만 문제 풀이의 핵심인 부분 조합 경우를 어떻게 구현해야 할지 떠오르지 않았다.\n\n+ 해결 과정   \nGPT의 도움을 받아 그리디 알고리즘이라는 개념을 접하게 되었고 이 문제에 적합한 해결 방법임을 알게 되었다.\n\n+ 배운 점   \n이번 문제를 통해 그리디 알고리즘의 개념과 그 활용 방법에 대해 알게 되었다. 그리디 알고리즘에 대한 문제를 좀 더 풀어봐야겠다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 정규표현식 문제 URL : https://www.acmicpc.net/problem/9996 2. 공부한 내용 본인의 언어로 정리하기 시도1(틀림) 접근 방법 를 기준으로 나눠서 regex[0]으로 시작하면서 regex[1]로 끝나는지 체크하였다. 문제점 중간에 들어갈 내용까지 포함해서 전체가 일치하는지 확인…","fields":{"slug":"/archive/study/99클럽코테스터디/8/"},"frontmatter":{"date":"April 09, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 8일차 TIL + 정규표현식","description":"99클럽 코테 스터디 8일차 TIL + 정규표현식","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 정규표현식\n+ 문제 URL : https://www.acmicpc.net/problem/9996\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n\n+ 시도1(틀림)\n    + 접근 방법 \n        + `*`를 기준으로 나눠서 regex[0]으로 시작하면서 regex[1]로 끝나는지 체크하였다.\n    + 문제점 \n        + 중간에 들어갈 내용까지 포함해서 전체가 일치하는지 확인해야한다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            // \\\\* 이렇게 해야 \"*\" 문자열로 인식함\n            String[] regex = br.readLine().split(\"\\\\*\"); \n            \n            for (int i=0; i<n; i++) {\n                String inputStr = br.readLine();\n                if (inputStr.startsWith(regex[0]) && inputStr.endsWith(regex[1])) {\n                    System.out.println(\"DA\");\n                } else {\n                    System.out.println(\"NE\");\n                }\n            }\n        }\n    }\n    ```\n+ 시도2(맞음)\n    + 접근 방법 \n        + 정규표현식을 이용하였다.\n    + 소스 코드\n    ```java\n    import java.io.*;\n\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int n = Integer.parseInt(br.readLine());\n            String pattern = br.readLine().replace(\"*\", \".*\");  // 정규표현식으로 변경\n            \n            // a.*b => a로 시작해서 b로 끝나는 문자열 (중간은 아무 문자든 가능)\n            // ^ab => ab로 시작하는 문자열\n            // ab$ => ab로 끝나는 문자열\n            // [abc] => a, b, c 중 하나\n            // [a-z] => 소문자 a~z 중 하나\n            \n            for (int i = 0; i < n; i++) {\n                String input = br.readLine();\n                if (input.matches(pattern)) {\n                    System.out.println(\"DA\");\n                } else {\n                    System.out.println(\"NE\");\n                }\n            }\n        }\n    }\n    ```\n## 3. 오늘의 회고\n+ 문제 상황과 시도   \n단순히 `*`을 기준으로 앞과 뒤를 나눠 비교하는 방식으로 접근했으나 한 번에 통과하지 못했다.   \n\n+ 해결 과정   \n2번째 시도에 바로 정규표현식을 떠올린 점은 좋았다.    \n\n+ 배운 점   \n정규표현식과 String.matches() 메서드를 활용한 점은 긍정적이었다.   \n하지만 권장 시간인 30분 내에 문제를 해결하지 못한 것은 아쉬운 부분이다.   \n다음에는 시간 안에 해결할 수 있도록 더 집중해서 풀어보자.   \n"},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 스택/큐 문제 URL : https://www.acmicpc.net/problem/10799 2. 공부한 내용 본인의 언어로 정리하기 소스 코드 시도1 3. 오늘의 회고 문제 상황과 시도 문제를 처음 보고 가 생길 때마다 개수를 세면 될 것 같다고 생각했지만 결과가 맞지 않았다.\n괄호의 모양과 위치에 따라 쇠…","fields":{"slug":"/archive/study/99클럽코테스터디/7/"},"frontmatter":{"date":"April 08, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 7일차 TIL + 스택/큐","description":"99클럽 코테 스터디 7일차 TIL + 스택/큐","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 스택/큐\n+ 문제 URL : https://www.acmicpc.net/problem/10799\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 소스 코드\n    + 시도1\n    ````java\n    import java.io.*;\n    import java.util.Stack;\n\n    public class Main {\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            String input = br.readLine();\n\n            Stack<Character> stack = new Stack<>();\n            int result = 0;\n\n            for (int i=0; i<input.length(); i++) {\n                char c = input.charAt(i);\n    //            System.out.println(\"## 문자: \" + c);\n                if (c == '(') {\n                    stack.push(c);\n                } else {\n                    stack.pop();\n                    if (input.charAt(i-1) == '(') {\n                        result += stack.size();\n    //                    System.out.println(\"## 레이저: 현재 스택 크기만큼 자름 (\" + stack.size() + \") ##\");\n                    } else {\n                        result += 1;\n    //                    System.out.println(\"## 쇠막대기 끝 ##\");\n                    }\n                }\n    //            System.out.println(\"현재 스택 상태: \" + stack);\n    //            System.out.println(\"result: \" + result);\n    //            System.out.println(\"------------\");\n            }\n            System.out.println(result);\n        }\n    }\n    ````\n\n## 3. 오늘의 회고\n+ 문제 상황과 시도\n문제를 처음 보고 `()`가 생길 때마다 개수를 세면 될 것 같다고 생각했지만 결과가 맞지 않았다.\n괄호의 모양과 위치에 따라 쇠막대기의 잘림 횟수를 정확히 계산해야 하는 문제였기 때문이다.\n괄호가 생길 때마다 단순히 카운트하는 방식으로는 레이저인지 막대기의 끝인지 구분할 수 없어서 올바른 풀이 방법이 될 수 없었다.\n\n+ 해결 과정\n다양한 접근 방식을 검색해보며 스택을 활용한 풀이를 참고했다.\n\n+ 배운 점\n힌트를 보지 않고 문제를 읽고 스택을 떠올린 점은 좋았다. 다만 문제를 더 꼼꼼히 읽고 조건을 정확히 파악한 후에 접근하는 연습이 필요하다고 느꼈다.\n앞으로 다양한 문제를 접하며 사고력을 더 키워야겠다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 DFS/BFS 문제 URL : https://www.acmicpc.net/problem/4963 2. 공부한 내용 본인의 언어로 정리하기 소스 코드 시도1 3. 오늘의 회고 문제 상황과 시도 이전에 DFS 알고리즘 문제를 풀어본 경험이 있었지만 이번 문제 풀이에서는 제대로 적용하지 못했다. 해결 과정 검색을 …","fields":{"slug":"/archive/study/99클럽코테스터디/6/"},"frontmatter":{"date":"April 07, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 6일차 TIL + DFS/BFS","description":"99클럽 코테 스터디 6일차 TIL + DFS/BFS","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ DFS/BFS\n+ 문제 URL : https://www.acmicpc.net/problem/4963\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 소스 코드\n    + 시도1\n    ````java\n    import java.io.*;\n    import java.util.*;\n\n    public class Main {\n        /**\n        * 8방향\n        *(-1,-1)  (-1,0)  (-1,1)\n        *( 0,-1)   x,y    ( 0,1)\n        * ( 1,-1)  ( 1,0)  ( 1,1)\n        */\n        static int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};\n        static int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};\n        \n        static int[][] arr = null;\n        static boolean[][] visited = null;\n\n        static int h = 0;\n        static int w = 0;\n\n        public static void main(String[] args) throws Exception {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            while (true) {\n                String[] tmpArr = br.readLine().split(\" \");\n                \n                w = Integer.parseInt(tmpArr[0]);\n                h = Integer.parseInt(tmpArr[1]);\n\n                if (w == 0 && h == 0) {\n                    break;\n                }\n\n                arr = new int[h][w];\n                visited = new boolean[h][w];\n                \n                // 입력 다 받기\n                for (int i=0; i<h; i++) {\n                    String[] strArr = br.readLine().split(\" \");\n                    for (int j=0; j<w; j++) {\n                        arr[i][j] = Integer.parseInt(strArr[j]);\n                    }\n                }\n\n                int cnt = 0;\n                for (int i=0; i<h; i++) {\n                    for (int j=0; j<w; j++) {\n                        // 육지이면서 방문 안한 경우에만\n                        if (arr[i][j] == 1 && !visited[i][j]) {\n                            dfs(i, j);\n                            // bfs(i, j);\n                            cnt++;\n                        }\n                    }\n                }\n\n                System.out.println(cnt);\n            }\n        }\n\n        public static void dfs(int x, int y) {\n            // 방문 표시\n            visited[x][y] = true;\n\n            // 대각선까지 포함해서 8방향 탐색\n            for (int i=0; i<8; i++) {\n                int nx = x + dx[i];   // 다음 행\n                int ny = y + dy[i];   // 다음 열\n                // 배열 범위 안인지 체크\n                if (nx >= 0 && ny >= 0 && nx < h && ny < w) {\n                    // 육지이면서 방문하지 않았다면 DFS 재귀 호출\n                    if (arr[nx][ny] == 1 && !visited[nx][ny]) {\n                        dfs(nx, ny);\n                    }\n                }\n            }\n        }\n        \n        public static void bfs(int x, int y) {\n            Queue<int[]> queue = new LinkedList<>();\n            queue.offer(new int[]{x, y});\n            visited[x][y] = true;\n\n            while (!queue.isEmpty()) {\n                int[] now = queue.poll();\n                int curX = now[0];\n                int curY = now[1];\n\n                for (int i = 0; i < 8; i++) {\n                    int nx = curX + dx[i];\n                    int ny = curY + dy[i];\n\n                    if (nx >= 0 && ny >= 0 && nx < h && ny < w) {\n                        if (arr[nx][ny] == 1 && !visited[nx][ny]) {\n                            visited[nx][ny] = true;  // 방문 처리\n                            queue.offer(new int[]{nx, ny});\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    ````\n\n## 3. 오늘의 회고\n+ 문제 상황과 시도\n이전에 DFS 알고리즘 문제를 풀어본 경험이 있었지만 이번 문제 풀이에서는 제대로 적용하지 못했다.\n\n+ 해결 과정\n검색을 통해 다양한 접근 방식을 참고했다.\n\n+ 배운 점\nDFS/BFS 알고리즘에 대한 이해를 높이기 위해 더 많은 문제를 풀어봐야겠다."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 투포인터 문제 URL : https://www.acmicpc.net/problem/2559 2. 공부한 내용 본인의 언어로 정리하기 투포인터 정렬된 배열이나 리스트에서 두 개의 포인터를 사용하여 문제를 해결하는 방법을 말한다. 주로 연속된 부분 배열, 구간 합, 정렬된 배열에서 특정 조건을 만족하는 쌍 찾기 …","fields":{"slug":"/archive/study/99클럽코테스터디/5/"},"frontmatter":{"date":"April 04, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 5일차 TIL + 투포인터","description":"99클럽 코테 스터디 5일차 TIL + 투포인터","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 투포인터\n+ 문제 URL : https://www.acmicpc.net/problem/2559\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 투포인터 \n    + 정렬된 배열이나 리스트에서 두 개의 포인터를 사용하여 문제를 해결하는 방법을 말한다.\n    + 주로 연속된 부분 배열, 구간 합, 정렬된 배열에서 특정 조건을 만족하는 쌍 찾기 등에 사용된다.\n+ 소스 코드\n    + 시도1\n    ````java\n    import java.io.*;\n    import java.util.Arrays;\n\n    public class Main {\n        static int[] arr = null;\n\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n            String[] tmp1 = br.readLine().split(\" \");\n            String[] tmp2 = br.readLine().split(\" \");\n\n            int n = Integer.parseInt(tmp1[0]);    // 온도를 측정한 전체 날짜의 수\n            int k = Integer.parseInt(tmp1[1]) - 1;    // 합을 구하기 위한 연속적인 날짜의 수(자기 자신도 포함되어서 -1)\n\n            arr = new int[n];\n            for (int i=0; i<n; i++) {\n                arr[i] = Integer.parseInt(tmp2[i]);\n                // System.out.print(arr[i] + \" \");\n            }\n\n            int maxSum = Integer.MIN_VALUE;\n            for (int i=0; i<n-1; i++) {\n                int j = i + k;\n                if (j < n) {\n                    // 연속적인 날짜의 합 구하기\n                    int sum = getSum(arr, i, j);\n    //                System.out.print(sum + \" \");\n                    maxSum = Math.max(maxSum, sum);\n                }\n            }\n            // 출력\n            System.out.println(maxSum);\n        }\n\n        public static int getSum(int[] arr, int startIdx, int endIndx) {\n            int sum = 0;\n            for (int i=startIdx; i<=endIndx; i++) {\n                sum += arr[i];\n            }\n            return sum;\n        }\n    }\n    ````\n\n## 3. 오늘의 회고\n+ 문제 상황과 시도\n초반에 문제를 잘못 이해하여 연속적인 구간의 합을 구해야 했는데 특정 인덱스끼리의 합을 구하는 방식으로 풀었다.\n\n+ 해결 과정\n생각한대로 쉽게 구현이 되었다.\n\n+ 배운 점\n처음에는 단순한 시뮬레이션 문제라고 생각했지만 힌트를 보고 투 포인터 알고리즘이 활용된다는 것을 알게 되었다. \n문제의 특성을 정확히 파악하는 것이 중요하다는 점을 다시 한번 느꼈다.\n"},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 DFS/BFS 문제 URL : https://www.acmicpc.net/problem/2468 2. 공부한 내용 본인의 언어로 정리하기 DFS(깊이 우선 탐색, Depth-First Search) 그래프를 탐색할 때 한 방향으로 갈 수 있을 만큼 깊이 들어가고 더 이상 갈 곳이 없으면 뒤로 돌아와 다른 경로…","fields":{"slug":"/archive/study/99클럽코테스터디/4/"},"frontmatter":{"date":"April 03, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 4일차 TIL + DFS/BFS","description":"99클럽 코테 스터디 4일차 TIL + DFS/BFS","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ DFS/BFS\n+ 문제 URL : https://www.acmicpc.net/problem/2468\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ DFS(깊이 우선 탐색, Depth-First Search)\n    + 그래프를 탐색할 때 한 방향으로 갈 수 있을 만큼 깊이 들어가고 더 이상 갈 곳이 없으면 뒤로 돌아와 다른 경로를 탐색하는 방식이다.\n    + 스택(Stack) 또는 재귀를 사용해서 구현한다.\n    + 사용 사례: 백트래킹, 퍼즐(미로 찾기, 체스 나이트 이동 등), 위상 정렬\n+ BFS(너비 우선 탐색, Breadth-First Search)\n    + 그래프를 탐색할 때 가까운 노드부터 차례대로 방문하는 방식이다.\n    + 큐(Queue)를 이용해 구현한다.\n    + 사용 사례: 최단 경로 찾기(미로, GPS), 네트워크 탐색, 웹 크롤링\n\n+ 소스 코드\n    + 시도1\n    ````java\n    import java.io.*;\n    import java.util.StringTokenizer;\n\n    public class Main {\n\n        static boolean[][] visited = null;\n        // 방향 벡터 (상, 하, 좌, 우)\n        static int[] dx = {-1, 1, 0, 0};\n        static int[] dy = {0, 0, -1, 1};\n\n        static int n = 0;\n        static int[][] arr = null;\n\n        public static void main(String[] args) throws Exception {\n            // 입력\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            n = Integer.parseInt(br.readLine());\n\n            StringTokenizer st = null;\n            arr = new int[n][n];\n            int maxHeight = 0;\n            int minHeight = 101;\n\n            // 2차원배열 생성\n            for (int i=0; i<n; i++) {\n                st = new StringTokenizer(br.readLine());\n                for (int j=0; j<n; j++) {\n                    arr[i][j] = Integer.parseInt(st.nextToken());\n                    maxHeight = Math.max(maxHeight, arr[i][j]);\n                    minHeight = Math.min(minHeight, arr[i][j]);\n                }\n            }\n\n            int maxCnt = 1;\n            for (int h=minHeight; h<=maxHeight; h++) {\n                visited = new boolean[n][n];\n                int cnt = 0;\n\n                for (int x=0; x<n; x++) {\n                    for (int y=0; y<n; y++) {\n                        if (arr[x][y] > h && !visited[x][y]) {\n                            dfs(x, y, h);\n                            cnt++;\n                        }\n                    }\n                }\n\n                maxCnt = Math.max(maxCnt, cnt);\n            }\n\n            // 출력\n            System.out.println(maxCnt);\n        }\n\n        public static void dfs(int x, int y , int h) {\n            visited[x][y] = true;\n\n            for (int i=0; i<4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                    if (!visited[nx][ny] && arr[nx][ny] > h) {\n                        dfs(nx, ny, h);\n                    }\n                }\n            }\n        }\n    }\n    ````\n\n## 3. 오늘의 회고\n+ 문제 상황과 시도\n문제를 이해하는 것조차 쉽지 않았다. 특히 물에 잠기지 않는 높이가 왜 존재하지 않는지 의문이 들었지만 결국 모든 경우의 수를 구하는 방식이라는 것을 깨달았다. \n또한 DFS와 BFS 알고리즘을 적용하는 과정도 어려움을 겪었다.\n\n+ 해결 과정\n이번 문제는 구현 방법이 쉽게 떠오르지 않아서 검색을 통해 다양한 접근 방식을 참고했다.\n\n+ 배운 점\n문제를 정확히 이해하는 것이 중요하며 직관적으로 해결 방법이 떠오르지 않을 때는 검색을 통해 다른 사람들의 접근 방식을 참고하는 것도 좋은 학습 방법이다.\n검색을 통해 알게된 방식을 스스로 이해하고 정리하여 구현해보는 과정을 해보자."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 시뮬레이션 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/161990 2. 공부한 내용 본인의 언어로 정리하기 시뮬레이션 문제에서 주어진 조건을 그대로 구현하여 해결하는 방법을 말한다. 보통 격자 이동, 회전 같은 문제에서 많이 사용된다…","fields":{"slug":"/archive/study/99클럽코테스터디/3/"},"frontmatter":{"date":"April 02, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 3일차 TIL + 시뮬레이션","description":"99클럽 코테 스터디 3일차 TIL + 시뮬레이션","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 시뮬레이션\n+ 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/161990\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 시뮬레이션\n    + **문제에서 주어진 조건을 그대로 구현하여 해결하는 방법**을 말한다.\n    + 보통 격자 이동, 회전 같은 문제에서 많이 사용된다.\n+ 소스 코드\n    + 시도1\n    ````java\n    public static int[] solution(String[] wallpaper) {\n        int[] answer = new int[4];\n        \n        int lux = Integer.MAX_VALUE;  // 상단 왼쪽\n        int luy = Integer.MAX_VALUE;  // 상단 오른쪽\n        int rdx = 0;                  // 하단 왼쪽\n        int rdy = 0;                  // 하단 오른쪽\n        \n        for (int i=0; i<wallpaper.length; i++) {\n            char[] arr = wallpaper[i].toCharArray();\n            for (int j=0; j<arr.length; j++) {\n                if (arr[j] == '#') {\n                    // System.out.println(String.format(\"x = %d / y = %d\", i, j));\n                    lux = Math.min(lux, i);\n                    luy = Math.min(luy, j);\n                    rdx = Math.max(rdx, i + 1);  // 끝점까지 포함시키기 위해서 +1\n                    rdy = Math.max(rdy, j + 1);  // 끝점까지 포함시키기 위해서 +1\n                }\n            }\n        }\n        \n        answer[0] = lux;\n        answer[1] = luy;\n        answer[2] = rdx;\n        answer[3] = rdy;\n        \n        // System.out.println(Arrays.toString(answer));\n        \n        return answer;\n    }\n    ````\n\n## 3. 오늘의 회고\n+ 문제 상황과 시도\n문제를 읽고 최단 거리를 구해야 한다고 판단하여 DFS나 BFS 알고리즘을 고려했다. \n그러나 검색을 통해 이러한 접근이 필요하지 않다는 것을 알게 되었다.\n\n+ 해결 과정\n머릿속에 떠오르는 방식대로 2차원 배열을 만들어 필요한 변수들을 계산하며 문제를 해결했다.\n\n+ 배운 점\n지문에서 요구하는 사항을 정확하게 파악하는 습관을 기르자."},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 동적계획법 문제 URL : https://www.acmicpc.net/problem/14495 2. 공부한 내용 본인의 언어로 정리하기 동적계획법(Dynamic Programming, DP) 복잡한 문제를 작은 부분 문제로 나누어 해결한 후 그 결과를 저장하여 동일한 계산을 반복하지 않도록 하는 최적화 기법을…","fields":{"slug":"/archive/study/99클럽코테스터디/2/"},"frontmatter":{"date":"April 01, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 2일차 TIL + 동적계획법","description":"99클럽 코테 스터디 2일차 TIL + 동적계획법","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 동적계획법\n+ 문제 URL : https://www.acmicpc.net/problem/14495\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 동적계획법(Dynamic Programming, DP)\n    + **복잡한 문제를 작은 부분 문제로 나누어 해결한** 후 그 결과를 저장하여 동일한 계산을 반복하지 않도록 하는 최적화 기법을 말한다.\n    + 구현 방법\n        + Top-Down (메모이제이션, Memoization)\n            + **재귀**를 사용하여 해결한다.\n            + 이미 계산한 값을 저장하고 필요할 때 다시 사용한다.\n        + Bottom-Up (타뷸레이션, Tabulation)\n            + 작은 문제부터 해결하여 큰 문제를 해결한다.\n            + **반복문**을 사용하여 점진적으로 결과를 계산한다.\n+ 소스 코드\n    + 시도1 : int형 -> long형으로 변경\n    ````java\n    import java.util.*;\n    public static void main(String[] args) {\n        // 입력\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        long[] arr = new long[n+1];\n        // f(1) = f(2) = f(3) = 1이며 \n        arr[1] = 1;\n        arr[2] = 1;\n        arr[3] = 1;\n        \n        // f(n) = f(n-1) + f(n-3)인 수열\n        for (int i=4; i<=n; i++) {\n            arr[i] = arr[i-1] + arr[i-3]\n            // System.out.println(arr[i]);\n        }\n        // 출력\n        System.out.println(arr[n]);\n    }\n    ````\n    + 시도2 : long형 -> BigInteger 타입으로 변경\n    ```java\n    import java.util.*;\n    import java.math.*;\n    public static void main(String[] args) {\n        // 입력\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        BigInteger[] arr = new BigInteger[n+1];\n        // f(1) = f(2) = f(3) = 1이며 \n        arr[1] = BigInteger.ONE;\n        arr[2] = BigInteger.ONE;\n        arr[3] = BigInteger.ONE;\n        \n        // f(n) = f(n-1) + f(n-3)인 수열\n        for (int i=4; i<=n; i++) {\n            arr[i] = arr[i-1].add(arr[i-3]);\n            // System.out.println(arr[i]);\n        }\n        // 출력\n        System.out.println(arr[n]);\n    }\n    ```\n    + 시도3\n    ```java\n    import java.util.*;\n    import java.math.*;\n    public static void main(String[] args) {\n        // 입력\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        // 유효성 검사 추가\n        if (n == 1 || n == 2 || n == 3) {\n            System.out.println(1);\n            return;\n        }\n        \n        // f(1) = f(2) = f(3) = 1이며 \n        BigInteger f1 = BigInteger.ONE;         // f(n-3)\n        BigInteger f2 = BigInteger.ONE;         // f(n-2)\n        BigInteger f3 = BigInteger.ONE;         // f(n-1)\n        BigInteger result = BigInteger.ZERO;    // 결과\n        \n        // f(n) = f(n-1) + f(n-3)인 수열\n        for (int i=4; i<=n; i++) {\n            result = f3.add(f1);\n            f1 = f2;\n            f2 = f3;\n            f3 = result;\n        }\n        // 출력\n        System.out.println(result);\n    }\n    ```\n\n## 3. 오늘의 회고\n+ 문제 상황과 시도\n처음에는 int형을 사용해 제출했지만 틀렸다는 결과가 나왔다. n의 최대값인 161로 테스트해 보니 중간에 값이 이상해지는 것을 확인했고 이는 int형의 범위를 초과했기 때문이라고 판단했다.\n이에 long형으로 변경했지만 여전히 같은 문제가 발생했다.\n\n+ 해결 과정\n검색을 통해 BigInteger를 사용하면 오버플로우를 방지할 수 있다는 것을 알게 되어 적용해 보았으나 이번에는 런타임 오류와 함께 메모리와 시간을 더 많이 사용하게 되었다.\n이를 해결하기 위해 배열 대신 변수를 활용하여 메모리 사용을 최적화했고 유효성 검사도 추가하여 안정성을 높였다.\n\n+ 배운 점\n코딩 테스트에서 자료형의 범위를 신중하게 고려하는 습관이 중요하다는 것을 다시 한번 깨달았다.\n앞으로는 숫자의 최대값을 미리 확인하고 적절한 자료형을 선택하는 과정을 습관화해야겠다. "},{"excerpt":"99클럽 코테 스터디 1. 오늘의 학습 키워드 에라토스테네스의 체 문제 URL : https://www.acmicpc.net/problem/1929 2. 공부한 내용 본인의 언어로 정리하기 소수 1과 자기 자신만을 약수로 가지는 수를 말한다. 0, 1은 소수가 아니다. 소수를 찾는 방법 소인수 분해를 이용하는 방법 에라토스테네스의 체를 이용하는 방법 에라…","fields":{"slug":"/archive/study/99클럽코테스터디/1/"},"frontmatter":{"date":"March 31, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 1일차 TIL + 에라토스테네스의 체 ","description":"99클럽 코테 스터디 1일차 TIL","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"99클럽 코테 스터디","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n![99클럽 코테 스터디](/images/99_java.png)\n\n## 1. 오늘의 학습 키워드\n+ 에라토스테네스의 체 \n+ 문제 URL : https://www.acmicpc.net/problem/1929\n\n## 2. 공부한 내용 본인의 언어로 정리하기\n+ 소수 \n    + 1과 자기 자신만을 약수로 가지는 수를 말한다.\n    + 0, 1은 소수가 아니다.\n    + 소수를 찾는 방법\n        + 소인수 분해를 이용하는 방법\n        + 에라토스테네스의 체를 이용하는 방법\n\n+ 에라토스테네스의 체 \n    + 소수를 빠르게 찾는 알고리즘을 말한다.\n    + 시간 복잡도가 줄어들게 된다.\n    + 원리\n        + 소수를 구하고자 하는 범위만큼 배열을 할당한다.\n        + 처음 모든 숫자를 소수라고 가정하기 위해서 true로 초기화한다.\n        + 2부터 시작해서 특정 수의 배수에 해당하는 수를 모두 지운다.(지울 때 자기자신은 지우지 않고 이미 지워진 수는 건너뛴다.)\n        + 2부터 시작하여 남아있는 수를 모두 출력한다.\n\n+ 소스 코드\n    ````java\n    import java.util.*;\n\n    public class Main {\n        public static void main(String[] args) {\n            // 입력\n            Scanner sc = new Scanner(System.in);\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n\n            boolean[] isPrime = new boolean[n + 1]; // boolean 배열을 사용해서 공간을 최소화\n            Arrays.fill(isPrime, true); // 처음 모든 숫자를 소수라고 가정하기 위해서\n\n            isPrime[0] = false;\n            isPrime[1] = false;\n\n            /**\n            * Q. i * i <= n까지만 반복하는 이유?\n            * A. 그 이전 값들은 이미 작은 수의 배수로 처리됐기 때문이다\n            *    예를 들어 i=3이면 3×2=6은 이미 i=2일 때 처리됐으므로 3×3=9부터 시작하면 된다\n            */\n            for (int i=2; i * i <= n; i++) { // 2부터 sqrt(n)까지 반복\n                if (isPrime[i]) { // 이미 지워진 숫자도 다시 검사 될 수 있으므로 필요함\n                    for (int j = i * i; j <= n; j += i) { // i의 배수 지우기\n                        isPrime[j] = false;\n                    }\n                }\n            }\n\n            // 출력\n            for (int i=m; i<=n; i++) {\n                if (isPrime[i]) {\n                    System.out.println(i);\n                }\n            }\n        }\n    }\n    ````\n\n## 3. 오늘의 회고\n소수의 개념이 기억나지 않아 개념을 찾아보고 코드를 작성해보았다. 처음 시도한 방법은 M과 N 사이의 모든 수를 반복문을 돌면서 소수인지 판별하는 방법이었다. 하지만 오답처리가 되었다. 그래서 int형의 범위 초과인지 싶어서 int형을 long형으로 변경해보았지만 여전히 오답처리가 되었다.\n그래서 소수 판별 알고리즘을 찾아보았는데 에라토스테네스의 체 알고리즘을 사용하면 더 빠르게 소수를 판별할 수 있다는 것을 알게 되었다.\n에라토스테네스의 체 알고리즘을 좀 더 공부해서 코드를 작성해보고 이해하는 시간이 필요할 것 같다.\n\n## 4. 내일 학습할 것\n+ 에라토스테네스의 체 알고리즘 코드 이해하기\n"},{"excerpt":"1. String클래스란? String 클래스는 자바에서 문자열을 다루기 위해 제공하는 클래스입니다. 자바에서 가장 많이 사용되는 클래스 중 하나죠. 문자열을 다루기 위해 기본형인 char 타입을 사용할 수도 있지만, 이 방법은 불편하기 때문에 자바에서는 문자열을 보다 편리하게 처리할 수 있도록 String 클래스를 제공합니다. String 클래스의 주요…","fields":{"slug":"/archive/java/2/"},"frontmatter":{"date":"November 10, 2024","title":"[Java] String 클래스","description":"String 클래스","tags":["Java","Study"],"series":"Java","previewImage":"java_logo.png","isPrivate":false},"rawMarkdownBody":"\n## 1. String클래스란?\n\nString 클래스는 **자바에서 문자열을 다루기 위해 제공하는 클래스**입니다. 자바에서 가장 많이 사용되는 클래스 중 하나죠.   \n문자열을 다루기 위해 기본형인 char 타입을 사용할 수도 있지만, 이 방법은 불편하기 때문에 자바에서는 문자열을 보다 편리하게 처리할 수 있도록 String 클래스를 제공합니다.\n\nString 클래스의 주요 특징 중 하나는 **불변(Immutable) 객체**라는 점입니다. 불변 객체란 값을 변경할 수 없는 객체를 의미하며, String 클래스는 내부적으로 문자열 데이터를 수정할 수 없게 설계되어 있습니다.\n\n![String클래스](/img1.png)\n\n위 이미지에서 볼 수 있듯이 value라는 변수는 실제로 String 클래스에서 문자열 데이터를 담는 역할을 합니다. 이 변수는 **final로 선언되어 있어 값 변경이 불가능**합니다.\n\nString 클래스의 소스 코드를 통해 이 구조를 좀 더 자세히 알아보겠습니다.\n\n```java\npublic final class String {\n    private final char[] value;    // 자바 9 이전\n    private final byte[] value;    // 자바 9 이후\n}\n```\n자바 9 이전에는 char 배열을 이용해 문자열 데이터를 저장했지만, 자바 9 이후부터는 메모리 효율성을 높이기 위해 byte 배열을 사용하도록 변경되었습니다.\n\n> **byte를 사용하는 이유**   \n> 예전에는 모든 String 객체가 UTF-16 인코딩을 사용하여 2Byte로 저장되었으나,   \n> 자바 9에서는 저장된 문자가 ASCII 문자일때 더 적은 메모리를 사용하도록 byte[] 배열을 사용하여 저장하는 방식으로 변경되었으며\n> 이러한 방식을 압축문자열(Compact Strings)이라고 합니다.\n\n## 2. String 선언 방법\n\nString을 선언하는 방법에는 리터럴 방식과 new 연산자를 이용한 방식 두 가지가 있습니다.\n\n![리터럴 방식](/img2.png)\n+ 리터럴 방식\n    + JVM는 먼저 String Pool에 \"hello\"라는 문자열이 존재하는지 확인합니다.\n    + 이미 \"hello\"가 존재한다면, 그 문자열의 참조값을 사용합니다.\n    + 존재하지 않으면 String Pool에 \"hello\"를 추가하고 그 참조값을 사용합니다.\n    + 메모리를 절약할 수 있으며, 동일 문자열 비교시 \"==\" 비교가 가능합니다.\n\n![new 연산자 이용 방식](/img3.png)\n+ new 연산자 이용 방식\n    + **String Pool을 거치지 않고 무조건 새로운 String 객체가 Heap 영역에 생성**됩니다.\n\n![선언방법 도식화](/img4.png)\n\n\"hello\"란 문자열은 같지만 리터럴 방식의 str1과 new 연산자를 사용한 str2는 서로 다른 참조값을 가지게 됩니다.\n\n![불변설계이유](/img5.png)\n\n> **String 클래스가 불변으로 설계된 이유**   \n> 만약 String 클래스가 값을 변경할 수 있다면, String Pool에 있는 객체의 값이 변경되면 같은 문자열을 참조하고 있는 다른 변수의 값도 함께 변경되는 문제가 발생합니다.\n> 그래서 불변으로 설계된 것입니다.\n\n## 3. 가변 String\n\nString은 불변 객체이기 때문에 문자열을 조작할 때마다 새로운 객체가 생성됩니다. 이로 인해 메모리 낭비와 속도 저하가 발생할 수 있습니다. 이러한 단점을 보완하기 위해 가변 String 클래스들이 도입되었습니다. 자바에서는 StringBuffer와 StringBuilder 클래스를 제공하여 String과 달리 문자열을 쉽게 수정할 수 있도록 하고 성능 개선에 도움을 줍니다.\n\n+ StringBuilder\n    + 동기화 처리가 없기 때문에 단일 스레드에서의 성능이 좋습니다.\n+ StringBuffer\n    + 멀티스레드 환경에서 안전하도록 동기화(synchronized) 처리가 되어있어 스레드 안전성을 보장합니다.\n\n그럼 가변 String을 사용하는게 더 좋은 경우는 언제일까요?\n\n+ 반복문(만건이상)이나 조건문에서 문자열을 조작할 때\n+ 복잡한 문자열의 특정 부분을 수정해야 할 때\n+ 대용량 문자열을 다룰 때\n\n\n이런 경우에는 String보다 가변 String을 사용하는것이 성능 측면에서 더 좋습니다.\n\n## 4. String 최적화\n\n+ 문자열 리터럴 최적화\n    ```java\n    // 컴파일 전\n    String str = \"A\" + \"B\";\n    // 컴파일 후\n    String str = \"AB\";\n    ```\n    자바 컴파일러는 **컴파일 시점에 문자열 리터럴을 자동으로 결합하여 최적화**합니다. 이로 인해 런타임 시 문자열 결합 연산을 수행할 필요가 없어 성능이 향상됩니다.\n\n+ String 변수 최적화\n    ```java\n    // 런타임 전\n    String str = \"A\";\n    String str2 = \"A\" + str;\n    // 런타임 후\n    String str = \"A\";\n    String str2 = new StringBuilder().append(\"A\").append(str).toString();\n    ```\n    변수가 포함된 문자열 결합은 컴파일 시점에 미리 결합할 수 없으므로, **런타임에 StringBuilder를 이용해 최적화**합니다. 자바 9부터는 `StringConcatFactory`를 사용하여 최적화가 더욱 개선되었습니다.\n\n> **StringConcatFactory**   \n> 자바 9에서 도입된 문자열 결합 최적화 기능으로 다양한 문자열 결합 방식을 효율적으로 처리하기 위해 동적 바이트코드를 생성하는 역할을 합니다. \n> 기존에는 StringBuilder를 이용해 문자열을 결합했으나 StringConcatFactory는 invokedynamic 명령어와 함께 동작하여 런타임에 가장 효율적인 방식으로 문자열을 결합할 수 있도록 최적화합니다. StringConcatFactory는 문자열 결합 패턴에 따라 적합한 결합 전략을 선택할 수 있게 해주므로 메모리 사용과 처리 속도를 개선하는 데 중요한 역할을 합니다.\n\n## 5. 정리\n+ String 클래스\n    + 자바에서 문자열을 다루기 위한 클래스입니다. String은 불변(Immutable) 객체로 값을 변경할 수 없도록 설계되었습니다. \n    + 자바 9부터는 메모리 효율성을 위해 byte[] 배열을 사용하는 압축 문자열(Compact Strings) 방식을 도입했습니다.\n+ String 선언 방식\n    + 리터럴 방식: 동일한 문자열을 String Pool에 저장해 메모리를 절약하며, `\"==\"`로 비교할 수 있습니다.\n    + new 연산자 방식: Heap 영역에 항상 새로운 String 객체를 생성합니다.\n+ 가변 String 클래스\n    + 문자열 변경 시 메모리와 성능을 개선하기 위해 StringBuffer(스레드 안전)와 StringBuilder(단일 스레드에서 효율적) 클래스를 사용합니다.\n+ String 최적화\n    + 문자열 리터럴 최적화: 컴파일 시점에 문자열 리터럴을 결합해 성능을 향상시킵니다.\n    + String 변수 최적화: 런타임 시점에 StringBuilder를 이용하거나, StringConcatFactory를 이용하여 성능을 최적화합니다.\n    \n## 참조\n+ https://velog.io/@gates/JAVA-String-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\n+ https://www.baeldung.com/java-string-immutable\n+ https://bugs.openjdk.org/browse/JDK-8054307\n+ https://www.inflearn.com/community/questions/1423424/string%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%B0%A9%EC%8B%9D-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8\n+ https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EC%A4%91%EA%B8%89-1"},{"excerpt":"if(kakao) 는 카카오 그룹의 기술 비전을 공개하고 기술적 성과를 소개하는 대표 개발자 컨퍼런스입니다. 매년 참여를 희망하며 신청했지만 올해 처음으로 당첨되는 행운을 얻어 마지막 날 행사에 참석할 수 있었습니다. 0. 셔틀버스 & 굿즈 오전 8시 20분까지 양재역에 도착해 셔틀버스를 타고 행사장으로 이동했습니다. 버스에 타자마자 굿즈를 나눠주셔서 기…","fields":{"slug":"/archive/review/1/"},"frontmatter":{"date":"October 25, 2024","title":"[후기] if(kakao) 2024","description":"if(kakaoAI) 2024 후기","tags":["컨퍼런스"],"series":"","previewImage":"oop.png","isPrivate":false},"rawMarkdownBody":"\n![카카오컨퍼런스](./kakao_img1.jpg)\n\n**if(kakao)** 는 카카오 그룹의 기술 비전을 공개하고 기술적 성과를 소개하는 대표 개발자 컨퍼런스입니다.   \n매년 참여를 희망하며 신청했지만 올해 처음으로 당첨되는 행운을 얻어 마지막 날 행사에 참석할 수 있었습니다.\n\n## 0. 셔틀버스 & 굿즈\n\n오전 8시 20분까지 양재역에 도착해 셔틀버스를 타고 행사장으로 이동했습니다.   \n버스에 타자마자 굿즈를 나눠주셔서 기분 좋게 시작할 수 있었습니다.\n\n![카카오컨퍼런스](./kakao_img3.jpg)\n\n이번 행사는 경기도 용인에 위치한 카카오 AI 캠퍼스에서 진행되었는데요. 날씨도 좋고 캠퍼스 건물 역시 인상적이었습니다. 곳곳에 비치된 물, 음료, 견과류 등 간식 덕분에 행사 내내 편하게 즐길 수 있었던 점도 만족스러웠습니다.\n\n![카카오컨퍼런스](./kakao_img2.jpg)\n\n## 1. Panel Talk\n\n오전 10시 오프닝 세션이 시작되었습니다. 이 시간에는 카카오 계열사들이 AI 기술을 어떻게 활용하고 있는지 구체적으로 소개했는데요. **특히 카카오페이와 카카오뱅크가 이상 거래 탐지 시스템(FDS)에 AI를 적용하고 있다는 점이 인상 깊었습니다.**  기존에는 사람만이 판단할 수 있다고 여겨졌던 영역에 AI가 도입된 것을 보며 기술의 발전에 신기함을 느꼈습니다.\n\n발표 내용은 금융 AI와 생활 AI 두 가지 주제로 나뉘었는데 개인적으로는 생활 AI 분야가 더 흥미로웠습니다. 특히 카카오페이지에서 AI가 웹툰 광고를 제작한다는 점이 놀라웠는데요. **사람이 작업하면 3주가 걸리는 일을 AI가 단 3시간 만에 처리할 수 있다고 합니다.**  또한 카카오모빌리티의 로봇 배송과 자율주행 택시에 대한 발표도 매우 흥미로웠습니다.\n\n![카카오컨퍼런스](./kakao_img4.jpg)\n![카카오컨퍼런스](./kakao_img5.jpg)\n![카카오컨퍼런스](./kakao_img6.jpg)\n![카카오컨퍼런스](./kakao_img7.jpg)\n\n## 2. 점심시간 & 체험부스\n\n![카카오컨퍼런스](./kakao_img8.jpg)\n\n카카오 AI 캠퍼스는 주변에 먹을만한 곳이 없습니다. 그래서 도시락 제공이 되었는데요. 아무래도 냉동이다보니 닭강정이랑 김밥이 좀 차갑더라구요. 식사 후에는 건물을 둘러보며 체험 부스도 구경했습니다. 밖에는 자율주행 택시가 1층 체험존에는 카나나 AI 포토부스가 있었고 2층에서는 카카오모빌리티의 로봇배송 서비스인 '브링'과 카카오헬스의 '파스타' 등 다양한 기술들을 직접 체험할 수 있었습니다. 오전에 들었던 기술 설명을 실제로 사용해 볼 수 있어 흥미로운 경험이었습니다.\n\n![카카오컨퍼런스](./kakao_img9.jpg)\n![카카오컨퍼런스](./kakao_img10.jpg)\n![카카오컨퍼런스](./kakao_img11.jpg)\n\n## 3. 인상깊었던 세션\n\n오전에는 카카오모빌리티 발표를 듣고 흥미가 생겨 **\"무엇이든 로봇배송! 진짜 되는 플랫폼 이야기\"** 세션에 참석했습니다. 기존 로봇 배송은 API 연동 방식으로 인해 여러 로봇 제조사에 공통 적용이 어려웠고 특정 제조사에 의존하는 구조였다고 합니다. 이를 개선하기 위해 설계를 변경하여 모든 제조사에 적용 가능한 플랫폼으로 바꿨다는 설명이 인상적이었습니다.\n\n![카카오컨퍼런스](./kakao_img12.jpg)\n\n마지막으로 **\"카카오 빌링 MySQL DB 샤딩 적용\"** 세션도 들었는데요. 발표자분이 유머를 곁들여 진행해 즐겁게 들을 수 있었습니다. 😄 DB 샤딩(Sharding)은 데이터베이스 트래픽을 분산시키는 중요한 방법으로 쉽게 말해서 각 DB서버에 데이터를 나눠 저장하는 방식을 말합니다. 기존에는 1대 서버에 의존하던 것을 12대로 대폭 확장했다고 합니다. 이 작업은 카카오 DB 팀과 협업해 108일 동안 진행되었다고 하네요.\n\n## 4. 마무리\n\n이번 카카오 AI 캠퍼스 방문을 통해 다양한 기술을 직접 체험하고 최신 트렌드를 배울 수 있는 뜻깊은 시간이었습니다. 특히 로봇 배송과 DB 샤딩과 같은 실무적이고 혁신적인 주제들을 접하며 많은 인사이트를 얻을 수 있었는데요. 앞으로도 이런 기술들이 어떻게 발전해 나갈지 기대가 됩니다. 또 이런 경험을 바탕으로 제 업무와 성장에도 도움이 될 수 있을 것 같아 더욱 의미 있었던 시간이었습니다.\n\n## 참조\n+ https://if.kakao.com/session?t.RVmWsFVgRd=2"},{"excerpt":"스터디에서 다형적참조에 대해 발표하게 되어 정리해보고자 합니다. 0. 서론 다형적 참조에 대해 설명하기 전에 먼저 다형성(Polymorphism)에 대해 알아보죠. 다형성(Polymorphism)은 객체지향 프로그래밍의 중요한 개념중 하나로 여러가지 형태를 가질 수 있는 능력을 의미합니다. 예시를 들자면, 다형성(Polymorphism)은 부모 클래스 타…","fields":{"slug":"/archive/java/1/"},"frontmatter":{"date":"September 28, 2024","title":"[Java] 다형적 참조","description":"다형적 참조","tags":["Java","Study"],"series":"Java","previewImage":"java_logo.png","isPrivate":false},"rawMarkdownBody":"\n스터디에서 다형적참조에 대해 발표하게 되어 정리해보고자 합니다.\n\n## 0. 서론\n\n다형적 참조에 대해 설명하기 전에 먼저 다형성(Polymorphism)에 대해 알아보죠.   \n다형성(Polymorphism)은 객체지향 프로그래밍의 중요한 개념중 하나로 **여러가지 형태를 가질 수 있는 능력을 의미**합니다. 예시를 들자면, 다형성(Polymorphism)은 부모 클래스 타입의 변수가 자식 클래스 타입의 객체를 참조할 수 있다는 것을 뜻합니다.\n\n## 1. 다형적 참조란?\n\n다시 돌아와서 다형적 참조(Polymorphic Reference)에 대해 알아보죠.   \n다형적 참조(Polymorphic Reference)는 **부모 클래스 타입의 인스턴스로 자식 클래스 타입의 인스턴스를 참조 할 수 있는 기능**을 의미합니다. 이는 다형성을 실현하는 방법 중 하나입니다.\n\n다형성과 비슷하다고 생각할 수 있지만 다형성과 다형적 참조는 보시다싶이 서로 다른 개념입니다. \n다형성이 더 포괄적인 개념이죠.\n![다형성과다형적참조](/1.png)\n\n## 2. 예제코드\n\nAnimal 클래스와 Jaelong 클래스가 있다고 가정해보죠. \n두 클래스는 부모(Animal)와 자식(Jaelong) 관계입니다.\n\n```java\npublic class Animal {\n    public void print() {\n        System.out.println(\"Animal\");\n    }\n}\n```\n```java\npublic class Jaelong extends Animal {\n    public void print() {\n        System.out.println(\"Jaelong\");\n    }\n\n    public void sound() {\n        System.out.println(\"멍멍\");\n    }\n}\n```\n\n```java\npublic class PolyTest {\n    public static void main(String[] args) {\n        Animal animal = new Animal();\n        Animal animal2 = new Jaelong();\n\n        animal.print();\n        animal2.print();\n    }\n}\n```\n\n이렇게 코드가 되어있다면 결과를 어떻게 될까요?\n\n```\n[결과]\nAnimal\nJaelong\n```\n\n`Animal animal2 = new Jaelong();` 부분에서 **다형적 참조를 통해 자식 클래스의 인스턴스로 변경되었기 때문에 \"Jaelong\"이라고 결과가 나오게 된 것입니다**.\n\n그렇다며 소스코드가 이렇게 되었다면 결과가 어떻게 될까요?\n\n```java\npublic class PolyTest {\n    public static void main(String[] args) {\n        Animal animal = new Animal();\n        Animal animal2 = new Jaelong();\n\n        animal.print();\n        animal2.print();\n        // 추가\n        animal2.sound();\n    }\n}\n```\n\n소스를 실행시키면 컴파일 에러가 발생합니다. 왜 그런걸까요?   \n다형적 참조로 자식 클래스의 인스턴스를 참조 했고 Jaelong 클래스에는 sound()가 있는데 말이죠.\n\n![소스분석](/2.png)\n`animal 변수`가 생성이 될때 메모리에 Animal 클래스만 로드가 됩니다. 반면에 `animal2 변수` 생성이 될때는 Jaelong 클래스와 부모 클래스인 Animal까지 같이 생성이 됩니다. \n\n![소스분석2](/3.png)\n`animal2 변수`는 Animal 타입으로 선언했기 때문에 먼저 Animal 클래스에 sound() 메소드가 있는지 확인합니다. **메소드를 찾는 방향은 자식->부모순으로 Animal (부모)에서 내려가면서 찾을 수는 없습니다.** 따라서 컴파일 오류가 발생한 것입니다. Jaelong 클래스로 다운 캐스팅후 호출하면 오류 없이 호출 할 수 있습니다.\n\n```java\npublic class PolyTest {\n    public static void main(String[] args) {\n        Animal animal = new Animal();\n        Animal animal2 = new Jaelong();\n\n        animal.print();\n        animal2.print();\n        // 추가\n        // animal2.sound(); // 컴파일 에러\n        ((Jaelong) animal2).sound(); // 다운 캐스팅후 호출\n    }\n}\n```\n\n## 3. 정리\n\n+ 다형성(Polymorphism)\n   + 객체지향 프로그래밍의 개념중 하나로 여러가지 형태를 가질 수 있는 능력을 의미합니다. \n+ 다형적 참조(Polymorphic Reference)\n   + 부모 클래스 타입의 인스턴스로 자식 클래스 타입의 인스턴스를 참조 할 수 있는 기능을 의미합니다. \n+ 메소드를 찾는 방향은 자식->부모순으로, 부모에서 내려가면서 찾을 수는 없습니다.\n\n\n## 참조\n+ https://medium.com/@binmuxiz/java-polymorphism-%EB%8B%A4%ED%98%95%EC%84%B1-1-%EB%8B%A4%ED%98%95%EC%A0%81-%EC%B0%B8%EC%A1%B0-1ee2e5535268\n+ https://yeoncoding.tistory.com/885\n+ GPT"},{"excerpt":"0. 서론 최근 면접을 보러 다니면서  Git 브랜치 전략에 대해 설명해 달라는 기술 질문을 공통적으로 받게 되었습니다. 사실 Git으로 소스 commit만 했지, 깊이있게 공부 하지 않았기 때문에 해당 질문에 대답 할 수 없었습니다. 따라서, Git 브랜치 전략에 대해 정리해보고자 합니다. 1. Git 브랜치 전략이란? Git은 브랜치라는 것을 사용하는…","fields":{"slug":"/archive/tech/1/"},"frontmatter":{"date":"September 04, 2024","title":"[기술면접] Git 브랜치 전략","description":"Git 브랜치 전략","tags":["Tech","Git"],"series":"기술면접","previewImage":"writing-help.png","isPrivate":false},"rawMarkdownBody":"\n## 0. 서론\n최근 면접을 보러 다니면서  **Git 브랜치 전략**에 대해 설명해 달라는 기술 질문을 공통적으로 받게 되었습니다. 사실 Git으로 소스 commit만 했지, 깊이있게 공부 하지 않았기 때문에 해당 질문에 대답 할 수 없었습니다.\n\n따라서, Git 브랜치 전략에 대해 정리해보고자 합니다.\n\n## 1. Git 브랜치 전략이란?\n\nGit은 브랜치라는 것을 사용하는데요. 브랜치는 특정 시점 스냅샷 같은 개념이라고 생각하시면 됩니다.   \n브랜치를 사용하면 한 프로젝트에서 서로 여러 작업을 동시에 수행하면서도, 작업간의 영향을 최소화 할 수 있습니다.\n\n이런 Git의 브랜치를 관리하는 전략을 Git 브랜치 전략이라고 말합니다.\n\n## 2. Git 브랜치 전략 사용 목적\n\n그렇다면 Git 브랜치 전략을 사용하는 목적이 뭘까요?   \nGit 브랜치 전략을 사용하는 목적에는 여러가지가 있지만 **문제가 생겼을 때 빠르게 복구하기 위해서**라고 생각합니다. 앞서 설명한 것처럼 브랜치를 사용하면 여러 가지 작업을 동시에 안전하게 진행할 수 있고, 언제든지 문제가 생기면 원래 상태로 돌아갈 수 있습니다.   \n\n## 3. Git 브랜치 전략 종류\n\n대표적인 Git 브랜치 전략에 대해 알아보겠습니다.\n\n+ Git Flow\n  + 브랜치 설명\n    + `main 브랜치`\n      + main 또는 master 브랜치 의미.\n      + 항상 배포 가능한 상태를 유지해야 합니다.\n    + `develop 브랜치` \n      + 개발이 완료된 코드를 통합하는 브랜치.\n      + 모든 기능은 develop 브랜치로 병합된 후 테스트 되어야 합니다.\n    + `feature 브랜치` \n      + 개발을 위해 develop 브랜치에서 파생된 브랜치.\n      + 개발이 완료되면 develop 브랜치로 병합됩니다.\n    + `release 브랜치` \n      + 배포 준비가 된 코드를 관리하는 브랜치.\n      + develop 브랜치에서 파생되어 테스트와 버그 수정을 거쳐 main 브랜치에 병합됩니다.\n    + `hotfix 브랜치`\n      + main 브랜치에서 직접 파생된 브랜치.\n      + 긴급한 버그 수정을 위해 사용되며, 수정 후 main과 develop 브랜치에 병합됩니다.\n  + 과정\n  ![GitFlow](https://images.squarespace-cdn.com/content/v1/5cd29903aadd34273bef66f8/50f3fcb5-5798-481c-85f0-5a85f0886ed9/Gitflow.png?format=2500w)\n  + 특징\n    + 복잡한 프로젝트에서 브랜치를 체계적으로 관리하기 위한 전략입니다. **주로 여러 단계의 개발과 배포를 체계적으로 관리하고자 할 때 사용**됩니다.\n    + **릴리즈와 관련된 버전을 체계적으로 관리하는 데 유리**합니다.\n  + 장/단점\n    + 개발과 릴리즈 준비를 분리하여 안정성을 유지할 수 있습니다.\n    + 브랜치가 많아지면 복잡해질수 있습니다.\n+ GitHub Flow\n  + 브랜치 설명\n    + `main 브랜치`:\n      + Git Flow의 `main 브랜치`와 동일합니다.\n    + `feature 브랜치`:\n      + 기능 또는 버그 수정을 위해 main 브랜치에서 파생된 브랜치\n      + 개발이 완료되면 `pull request`를 통해 코드 리뷰를 받고 main 브랜치로 병합됩니다.\n  + 과정\n  ![GitHubFlow](https://images.squarespace-cdn.com/content/v1/5cd29903aadd34273bef66f8/e05668eb-89fa-4ee0-8350-35c93d029fad/GitHub+Flow.png?format=2500w)\n  + 특징\n    + 소규모이거나 빠른 배포 주기를 가진 프로젝트를 위해 제안된 **간단하고 단순한 브랜치 전략**입니다.\n    + 단일 main 브랜치에서 이루어지며, feature 브랜치를 통해 코드 변경을 관리합니다.\n    + GitHub Flow는 PR 생성 시 자동으로 테스트가 실행되도록 설정할 수 있습니다. 이를 통해 코드가 main 브랜치에 병합되기 전에 버그가 없는지 기능이 정상적으로 동작하는지를 확인할 수 있습니다. 이를 통해 소스 코드의 품질까지 향상 시킬 수 있습니다.\n  + 장/단점\n    + 간단하고 직관적인 구조, 빠른 배포와 피드백 주기에 적합합니다.\n    + 릴리즈와 핫픽스 관리가 다소 비효율적일 수 있습니다.\n+ GitLab Flow\n  + 브랜치 설명\n    + `production 브랜치`\n      + 운영 환경에 배포되는 브랜치.\n    + `environment-specific 브랜치`\n      + 다양한 환경(staging, pre-production 등)에 맞는 브랜치로, 각 환경에 맞게 코드가 준비됩니다.\n    + `feature 브랜치`\n      + 개발을 위한 브랜치로 특정 환경 브랜치에 병합됩니다.\n  + 과정\n  ![GitLabFlow](https://images.squarespace-cdn.com/content/v1/5cd29903aadd34273bef66f8/87ed52b9-cb2e-456a-b345-c04121fb49b2/Gitlab+flow.png?format=2500w)\n  + 특징\n    + **GitHub Flow와 Git Flow의 장점을 결합**한 브랜치 전략입니다.\n    + 주로 main 브랜치와 feature 브랜치 외에도 환경 기반 브랜치를 사용합니다.\n  + 장/단점\n    + 환경에 맞는 브랜치 관리로 안정성 향상시킬 수 있으나, 환경 브랜치 관리가 복잡할 수 있습니다.\n## 4. 결론\n배포를 체계적으로 해야되는 경우에는 Git Flow를 사용하고, 배포를 자주 해야되는 경우에는 GitHub Flow를 사용하면 될 것 같습니다.\n프로젝트의 규모와 배포 주기에 따라서 알맞은 Git 브랜치 전략을 세우는것이 중요합니다.\n\n+ 참조\n  + https://be-student.tistory.com/83\n  + https://parkstate.tistory.com/33\n  + https://www.eisquare.co.uk/blogs/how-to-choose-your-branching-strategy"},{"excerpt":"1. 현상 A팝업 -> B팝업 -> C팝업으로 호출하는 경우 B팝업에서만 팝업 호출 시 해당 화면이 reload 되는 현상이 발생했다. 2. 원인 form 태그 안에  button 태그가 1개만 있는 경우에 onclick() 이벤트와 동시에 submit()도 같이 동작된다. 그래서 발생한 오류였다. 3. 해결 방법1) 방법2) 이런 방법 말고도 검색해보면…","fields":{"slug":"/error/2/"},"frontmatter":{"date":"August 25, 2024","title":"[오류] 팝업 여러개 띄울때 화면 reload 발생","description":"팝업 여러개 띄울때 화면 reload 발생","tags":["Error","Web"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 현상 \nA팝업 -> B팝업 -> C팝업으로 호출하는 경우 B팝업에서만 팝업 호출 시 해당 화면이 reload 되는 현상이 발생했다.\n\n## 2. 원인\n```html\n<form>\n    <button onclick=\"test();\"></button>\n</form>\n```\n**form 태그 안에  button 태그가 1개만 있는 경우에 onclick() 이벤트와 동시에 submit()도 같이** 동작된다. 그래서 발생한 오류였다.\n\n## 3. 해결\n+ 방법1)\n```html\n<form id=\"testForm\" method=\"post\" target=\"iframe1\">\n    <iframe id=\"iframe1\" name=\"iframe1\" style=\"display:none\"></iframe>\n</form>\n```\n+ 방법2)\n```html\n<form id=\"testForm\" method=\"post\" target=\"iframe1\">\n    <button type=\"button\" onclick=\"test();\"></button>\n</form>\n```\n이런 방법 말고도 검색해보면 다른 방법이 많이 있지만 나의 경우에는 이 2가지 방법으로 했을 때 오류가 발생하지 않았다.   \n\nbutton 태그에 대해서 좀 더 알아보다가 재미난 글을 발견하였다.   \n👉🏻[버튼에 타입을 쓰는 이유 (button type='button')](https://nykim.work/96 \"버튼에 타입을 쓰는 이유 (button type='button')\")\n\n+ 참조\n    + https://nykim.work/96"},{"excerpt":"1. 현상 2. 원인 3. 해결 참조","fields":{"slug":"/sample/test/"},"frontmatter":{"date":"August 25, 2024","title":"test","description":"tet","tags":["Error","Web"],"series":"오류 모음집","previewImage":"java_logo.png","isPrivate":true},"rawMarkdownBody":"\n## 1. 현상 \n## 2. 원인\n## 3. 해결\n+ 참조\n"},{"excerpt":"1. 현상  메소드를 이용해서 js를 분기처리 하는데 SSL 적용이 된 운영서버에서 http 리소스가 로드되어서 에러가 발생하였다. 2. 원인 web서버에서 was서버를 호출할때는 http 통신이기 때문에 isSecure() 메소드에서 false가 나온 것이다. 3. 해결 방법1) 방법2) 위와 같이 2가지 방법이 있는데 처음에는 x-forwarded-p…","fields":{"slug":"/error/3/"},"frontmatter":{"date":"August 25, 2024","title":"[오류] https 도메인인데 request.isSecure() return false인 경우","description":"https 도메인인데 request.isSecure() return false인 경우","tags":["Error","Web"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 현상 \n`request.isSecure()` 메소드를 이용해서 js를 분기처리 하는데 SSL 적용이 된 운영서버에서 http 리소스가 로드되어서 에러가 발생하였다.\n```\n<%\n   if( !request.isSecure() ) {\n%>\n\t<!-- http -->\n<%\n    } else {\n%>\n\t<!-- https -->\n<%\n    }\n%>\n```\n\n## 2. 원인\nweb서버에서 was서버를 호출할때는 http 통신이기 때문에 isSecure() 메소드에서 false가 나온 것이다.\n\n## 3. 해결\n+ 방법1) \n```\nrequest.getHeader(\"x-forwarded-proto\")\n```\n+ 방법2) \n```\nrequest.getRequestURL().indexOf(\"http://\") != -1\n```\n위와 같이 2가지 방법이 있는데 처음에는 x-forwarded-proto를 이용해서 하였으나 로드밸런서가 없는 로컬과 개발에서는 null로 나와서 방법 2로 변경하였다.\n\n> x-forwarded-proto \n> + 클라이언트가 로드밸런서에 접속할 때 사용한 프토토콜을 식별하는 표준 헤더\n\n+ 참조\n    + https://zetawiki.com/wiki/X-Forwarded-Proto\n"},{"excerpt":"환경설정 개발툴 : InteliJ Spring Boot : 2.7.14 Hibernate : 5.6.15 Java : 11 Gradle SpringBoot 검색을 해보면 application.properties 파일에 이 내용을 추가하면 파라미터 바인딩이 출력된다고 하는데, 저의 경우에는 그렇게 해도 나오지 않았습니다. 이 글을 참고하여 하니 원하는 결과…","fields":{"slug":"/archive/jpa/1/"},"frontmatter":{"date":"August 25, 2024","title":"[JPA] Hibernate 쿼리 파라미터 바인딩 출력","description":"Hibernate 쿼리 파라미터 바인딩 출력","tags":["JPA","Hibernate"],"series":"JPA","previewImage":"jpa.png","isPrivate":false},"rawMarkdownBody":"\n> 환경설정\n> + 개발툴 : InteliJ\n> + Spring Boot : 2.7.14\n> + Hibernate : 5.6.15\n> + Java : 11\n> + Gradle\n\n![SpringBoot](/images/hibernate_post.png)\n\n검색을 해보면 application.properties 파일에   \n```\nlogging.level.org.hibernate.SQL = debug\nlogging.level.org.hibernate.type.descriptor.sql = trace\n```\n이 내용을 추가하면 파라미터 바인딩이 출력된다고 하는데, 저의 경우에는 그렇게 해도 나오지 않았습니다.   \n이 글을 참고하여 하니 원하는 결과가 나왔습니다.   \n👉🏻[hibernate 의 완성된(?) 쿼리를 확인 하는 방법 문의 드립니다](https://www.inflearn.com/community/questions/59014/hibernate-%EC%9D%98-%EC%99%84%EC%84%B1%EB%90%9C-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%ED%99%95%EC%9D%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%AC%B8%EC%9D%98-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)\n\n\n## 1. bulid.gradle 파일에 추가 \n```\nimplementation 'org.bgee.log4jdbc-log4j2:log4jdbc-log4j2-jdbc4.1:1.16'\n```\n\n## 2. logback.xml 파일 추가\n`resources` 폴더 밑에 `logback.xml` 파일을 만들어줍니다.\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\n            <Pattern>%d{HH:mm} %-5level %logger{36} - %msg%n</Pattern>\n        </layout>\n    </appender>\n\n    <logger name=\"org.hibernate.type\" level=\"trace\" />\n\n    <root level=\"info\">\n        <appender-ref ref=\"STDOUT\" />\n    </root>\n</configuration>\n```\n\n## 3. 실행 결과\n파라미터가 같이 나오는 것을 확인 할 수 있습니다.\n![실행결과](./result.png)\n+ 참조\n    + https://www.inflearn.com/questions/59014/hibernate-%EC%9D%98-%EC%99%84%EC%84%B1%EB%90%9C-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%ED%99%95%EC%9D%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%AC%B8%EC%9D%98-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4"},{"excerpt":"환경설정 개발툴 : InteliJ Spring Boot : 2.7.14 Quartz : 2.3.2 Java : 11 Gradle SpringBoot Spring Boot에서 Quartz 연동 하는 예제를 소개합니다. 1. bulid.gradle 파일에 추가 2. @Scheduled 어노테이션을 이용 스케쥴러를 적용할 메소드에  어노테이션을 사용합니다. 이…","fields":{"slug":"/archive/spring/1/"},"frontmatter":{"date":"August 25, 2024","title":"[Spring Boot] Quartz 연동 예제","description":"Spring Boot Quartz 연동 예제","tags":["Srping Boot","Quartz"],"series":"Spring Boot","previewImage":"springboot_logo.png","isPrivate":false},"rawMarkdownBody":"\n> 환경설정\n> + 개발툴 : InteliJ\n> + Spring Boot : 2.7.14\n> + Quartz : 2.3.2\n> + Java : 11\n> + Gradle\n\n![SpringBoot](/images/springboot_post.png)\n\nSpring Boot에서 Quartz 연동 하는 예제를 소개합니다.\n\n## 1. bulid.gradle 파일에 추가 \n```\nimplementation \"org.springframework.boot:spring-boot-starter-quartz\"\n```\n\n## 2. @Scheduled 어노테이션을 이용\n스케쥴러를 적용할 메소드에 `@Scheduled` 어노테이션을 사용합니다.\n```java\n@Controller\npublic class QuartzController {\n    @Scheduled(cron = \"0/5 * * * * ?\")\n    public void everyFiveSeconds() {\n        DateTimeFormatter patten = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n        String formatDt = patten.format(LocalDateTime.now());\n\n        System.out.println(formatDt);\n    }\n}\n```\n`@SpringBootApplication`이 붙은 파일에 `@EnableScheduling` 어노테이션를 추가합니다.   \n추가 하지 않으면 스케쥴러가 실행되지 않습니다.\n```java\n@SpringBootApplication\n@EnableScheduling\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n> @EnableScheduling\n> + 스케쥴러를 기능을 켜는 역할을 하며, @Scheduled 어노테이션을 찾아서 실행을 시킨다.\n\n## 3. 실행 결과\n5초마다 실행 된것을 확인 할 수 있습니다.\n![SpringBoot](./result.png)\n+ 참조\n    + https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/EnableScheduling.html"},{"excerpt":"1. 현상 개발서버 https 적용으로 아래와 같이 http 요청 블락 에러가 발생하였다. 그래서 아래의 메타 태그를 추가해 줬다.  하지만 개발서버 https 적용을 해제하면서부터 화면 접속시 자동으로  로 붙어서 js, css를 읽는 경우가 발생하였다. 2. 원인 https때문에 추가했던 메타 태그의 문제로, content-security-policy…","fields":{"slug":"/error/1/"},"frontmatter":{"date":"August 23, 2024","title":"[오류] 자동으로 도메인에 https가 붙는 경우","description":"자동으로 도메인에 https가 붙는 경우","tags":["Error","Web"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n## 1. 현상 \n개발서버 https 적용으로 아래와 같이 http 요청 블락 에러가 발생하였다.\n```\nThis request has been blocked; the content must be served over HTTPS.\n```\n그래서 아래의 메타 태그를 추가해 줬다. \n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\">\n```\n하지만 개발서버 https 적용을 해제하면서부터 화면 접속시 자동으로 `https://` 로 붙어서 js, css를 읽는 경우가 발생하였다.\n\n## 2. 원인\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\">\n```\nhttps때문에 추가했던 메타 태그의 문제로, content-security-policy를 설정할 경우 자동으로 https로 호출해 주는 것이었다. \n```\nThe HTTP Content-Security-Policy (CSP) upgrade-insecure-requests directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS).\nHTTP Content-Security-Policy(CSP) upgrade-insecure-requests\n```\n\n## 3. 해결\n해당 태그를 주석처리 하면 현상은 해결되지만, 개발서버에 https 적용 시 http 요청 블락 에러를 이 방법 말고 다른 방법으로 해야 될 것 같다. 로컬은 http인데 개발서버는 https인 경우에는 이 메타태그를 사용하는 것은 좋은 방법이 아닌 것 같다.\n\n+ 참조\n  + https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/upgrade-insecure-requests\n"},{"excerpt":"Default Private Posts This is a default private post. It's recommended not to delete this posts 😵 (현재 이 포스트는 삭제하지 말아주세요.)","fields":{"slug":"/default/private-default/"},"frontmatter":{"date":"January 01, 2024","title":"Default Private","description":null,"tags":["private-tag"],"series":null,"previewImage":"banned.png","isPrivate":true},"rawMarkdownBody":"\n## Default Private Posts\n\nThis is a default private post. It's recommended not to delete this posts 😵\n\n(현재 이 포스트는 삭제하지 말아주세요.)\n"},{"excerpt":"환경설정 개발툴 : 이클립스 Spring : 4.3.3 Quartz : 2.3.0 Tomcat : 8.5 Java : 8 서버 :CentOS 1. 현상 개발서버에서 톰캣 프로세스가 여러개가 뜨면서 메모리 너무 많이 잡아먹는 현상이 발생하였다.\nnetstate -tnlp 하면 8080포트는 하나만 나오고, ps -ef | grep tomcat 하면 여러개 …","fields":{"slug":"/error/4/"},"frontmatter":{"date":"August 12, 2023","title":"[오류] 톰캣 프로세스 여러개 뜨는 경우","description":"톰캣 프로세스 여러개 뜨는 경우","tags":["Error","Tomcat"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\n> 환경설정\n> + 개발툴 : 이클립스\n> + Spring : 4.3.3\n> + Quartz : 2.3.0\n> + Tomcat : 8.5\n> + Java : 8\n> + 서버 :CentOS\n\n## 1. 현상 \n개발서버에서 톰캣 프로세스가 여러개가 뜨면서 메모리 너무 많이 잡아먹는 현상이 발생하였다.\n**netstate -tnlp 하면 8080포트는 하나만 나오고, ps -ef | grep tomcat 하면 여러개 나왔다.**\n\n## 2. 원인\n검색을 하다가 아래의 글을 보고 quartz 스케쥴러의 문제라고 생각이 들었다. \n톰캣 서버가 종료되어도 이미 실행된 job 스레드는 종료되지 않고 계속 남는다.   \n👉🏻[톰켓 프로세스 종료 이슈](https://log4day.tistory.com/m/59 \"톰켓 프로세스 종료 이슈\")\n\n## 3. 해결\ndestroy-method 속성을 이용해서 SchedulerFactoryBean 클래스에 있는 destroy() 메소드를 추가해줬다.\n```xml\n<bean id=\"qcrmJobScheduler\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\" destroy-method=\"destroy\">\n    <property name=\"triggers\">\n        <list>\n            <ref bean=\"testJobTrigger\" />\n        </list>\n    </property>\n</bean>\n```\n\n## + 추가(2023.10.13)\n위 방법으로 적용 후에도 계속 발생하여 젠킨스 배포시 실행중인 톰캣 프로세스 모두 종료시키는 쉘 스크립트를 추가하였다.\n```shell\n#!/bin/bash\n\ntomcat_pids=$(ps aux | grep tomcat | grep java | grep -v grep | awk '{print $2}')\n\nif [ -n \"$tomcat_pids\" ]; then\n    for pid in $tomcat_pids; do\n        echo \"PID: $pid\"\n        kill -9 $pid\n    done\nfi\n```\n\n+ 참조\n    + https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.htmlhttps://log4day.tistory.com/m/59\n    + https://log4day.tistory.com/m/59\n"},{"excerpt":"💡 현 포스트는 about 페이지에서도 조회 가능합니다. 포스트를 삭제하지 말고, 이 곳에다 본인만의 멋진 소개 글을 작성해주세요.","fields":{"slug":"/default/about/"},"frontmatter":{"date":"January 01, 2022","title":"Gatsby Starter Haon 저자에 대해 소개합니다.","description":null,"tags":["about"],"series":null,"previewImage":null,"isPrivate":true},"rawMarkdownBody":"\n> 💡 현 포스트는 about 페이지에서도 조회 가능합니다. 포스트를 삭제하지 말고, 이 곳에다 본인만의 멋진 소개 글을 작성해주세요.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}