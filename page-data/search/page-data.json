{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"오늘의 학습 키워드 공부한 내용 본인의 언어로 정리하기 오늘의 회고 어떤 문제가 있었고, 나는 어떤 시도를 했는지 어떻게 해결했는지 무엇을 새롭게 알았는지 내일 학습할 것은 무엇인지","fields":{"slug":"/archive/study/1/"},"frontmatter":{"date":"March 31, 2025","title":"[99클럽 코테 스터디] 99클럽 코테 스터디 1일차 TIL","description":"99클럽 코테 스터디 1일차 TIL","tags":["99클럽","코딩테스트준비","개발자취업","항해99","TIL"],"series":"","previewImage":"99_java.png","isPrivate":false},"rawMarkdownBody":"\r\n- 오늘의 학습 키워드\r\n- 공부한 내용 본인의 언어로 정리하기\r\n- 오늘의 회고\r\n  - 어떤 문제가 있었고, 나는 어떤 시도를 했는지\r\n  - 어떻게 해결했는지\r\n  - 무엇을 새롭게 알았는지\r\n  - 내일 학습할 것은 무엇인지"},{"excerpt":"1. String클래스란? String 클래스는 자바에서 문자열을 다루기 위해 제공하는 클래스입니다. 자바에서 가장 많이 사용되는 클래스 중 하나죠. 문자열을 다루기 위해 기본형인 char 타입을 사용할 수도 있지만, 이 방법은 불편하기 때문에 자바에서는 문자열을 보다 편리하게 처리할 수 있도록 String 클래스를 제공합니다. String 클래스의 주요…","fields":{"slug":"/archive/java/2/"},"frontmatter":{"date":"November 10, 2024","title":"[Java] String 클래스","description":"String 클래스","tags":["Java","Study"],"series":"Java","previewImage":"java_logo.png","isPrivate":false},"rawMarkdownBody":"\r\n## 1. String클래스란?\r\n\r\nString 클래스는 **자바에서 문자열을 다루기 위해 제공하는 클래스**입니다. 자바에서 가장 많이 사용되는 클래스 중 하나죠.   \r\n문자열을 다루기 위해 기본형인 char 타입을 사용할 수도 있지만, 이 방법은 불편하기 때문에 자바에서는 문자열을 보다 편리하게 처리할 수 있도록 String 클래스를 제공합니다.\r\n\r\nString 클래스의 주요 특징 중 하나는 **불변(Immutable) 객체**라는 점입니다. 불변 객체란 값을 변경할 수 없는 객체를 의미하며, String 클래스는 내부적으로 문자열 데이터를 수정할 수 없게 설계되어 있습니다.\r\n\r\n![String클래스](/img1.png)\r\n\r\n위 이미지에서 볼 수 있듯이 value라는 변수는 실제로 String 클래스에서 문자열 데이터를 담는 역할을 합니다. 이 변수는 **final로 선언되어 있어 값 변경이 불가능**합니다.\r\n\r\nString 클래스의 소스 코드를 통해 이 구조를 좀 더 자세히 알아보겠습니다.\r\n\r\n```java\r\npublic final class String {\r\n    private final char[] value;    // 자바 9 이전\r\n    private final byte[] value;    // 자바 9 이후\r\n}\r\n```\r\n자바 9 이전에는 char 배열을 이용해 문자열 데이터를 저장했지만, 자바 9 이후부터는 메모리 효율성을 높이기 위해 byte 배열을 사용하도록 변경되었습니다.\r\n\r\n> **byte를 사용하는 이유**   \r\n> 예전에는 모든 String 객체가 UTF-16 인코딩을 사용하여 2Byte로 저장되었으나,   \r\n> 자바 9에서는 저장된 문자가 ASCII 문자일때 더 적은 메모리를 사용하도록 byte[] 배열을 사용하여 저장하는 방식으로 변경되었으며\r\n> 이러한 방식을 압축문자열(Compact Strings)이라고 합니다.\r\n\r\n## 2. String 선언 방법\r\n\r\nString을 선언하는 방법에는 리터럴 방식과 new 연산자를 이용한 방식 두 가지가 있습니다.\r\n\r\n![리터럴 방식](/img2.png)\r\n+ 리터럴 방식\r\n    + JVM는 먼저 String Pool에 \"hello\"라는 문자열이 존재하는지 확인합니다.\r\n    + 이미 \"hello\"가 존재한다면, 그 문자열의 참조값을 사용합니다.\r\n    + 존재하지 않으면 String Pool에 \"hello\"를 추가하고 그 참조값을 사용합니다.\r\n    + 메모리를 절약할 수 있으며, 동일 문자열 비교시 \"==\" 비교가 가능합니다.\r\n\r\n![new 연산자 이용 방식](/img3.png)\r\n+ new 연산자 이용 방식\r\n    + **String Pool을 거치지 않고 무조건 새로운 String 객체가 Heap 영역에 생성**됩니다.\r\n\r\n![선언방법 도식화](/img4.png)\r\n\r\n\"hello\"란 문자열은 같지만 리터럴 방식의 str1과 new 연산자를 사용한 str2는 서로 다른 참조값을 가지게 됩니다.\r\n\r\n![불변설계이유](/img5.png)\r\n\r\n> **String 클래스가 불변으로 설계된 이유**   \r\n> 만약 String 클래스가 값을 변경할 수 있다면, String Pool에 있는 객체의 값이 변경되면 같은 문자열을 참조하고 있는 다른 변수의 값도 함께 변경되는 문제가 발생합니다.\r\n> 그래서 불변으로 설계된 것입니다.\r\n\r\n## 3. 가변 String\r\n\r\nString은 불변 객체이기 때문에 문자열을 조작할 때마다 새로운 객체가 생성됩니다. 이로 인해 메모리 낭비와 속도 저하가 발생할 수 있습니다. 이러한 단점을 보완하기 위해 가변 String 클래스들이 도입되었습니다. 자바에서는 StringBuffer와 StringBuilder 클래스를 제공하여 String과 달리 문자열을 쉽게 수정할 수 있도록 하고 성능 개선에 도움을 줍니다.\r\n\r\n+ StringBuilder\r\n    + 동기화 처리가 없기 때문에 단일 스레드에서의 성능이 좋습니다.\r\n+ StringBuffer\r\n    + 멀티스레드 환경에서 안전하도록 동기화(synchronized) 처리가 되어있어 스레드 안전성을 보장합니다.\r\n\r\n그럼 가변 String을 사용하는게 더 좋은 경우는 언제일까요?\r\n\r\n+ 반복문(만건이상)이나 조건문에서 문자열을 조작할 때\r\n+ 복잡한 문자열의 특정 부분을 수정해야 할 때\r\n+ 대용량 문자열을 다룰 때\r\n\r\n\r\n이런 경우에는 String보다 가변 String을 사용하는것이 성능 측면에서 더 좋습니다.\r\n\r\n## 4. String 최적화\r\n\r\n+ 문자열 리터럴 최적화\r\n    ```java\r\n    // 컴파일 전\r\n    String str = \"A\" + \"B\";\r\n    // 컴파일 후\r\n    String str = \"AB\";\r\n    ```\r\n    자바 컴파일러는 **컴파일 시점에 문자열 리터럴을 자동으로 결합하여 최적화**합니다. 이로 인해 런타임 시 문자열 결합 연산을 수행할 필요가 없어 성능이 향상됩니다.\r\n\r\n+ String 변수 최적화\r\n    ```java\r\n    // 런타임 전\r\n    String str = \"A\";\r\n    String str2 = \"A\" + str;\r\n    // 런타임 후\r\n    String str = \"A\";\r\n    String str2 = new StringBuilder().append(\"A\").append(str).toString();\r\n    ```\r\n    변수가 포함된 문자열 결합은 컴파일 시점에 미리 결합할 수 없으므로, **런타임에 StringBuilder를 이용해 최적화**합니다. 자바 9부터는 `StringConcatFactory`를 사용하여 최적화가 더욱 개선되었습니다.\r\n\r\n> **StringConcatFactory**   \r\n> 자바 9에서 도입된 문자열 결합 최적화 기능으로 다양한 문자열 결합 방식을 효율적으로 처리하기 위해 동적 바이트코드를 생성하는 역할을 합니다. \r\n> 기존에는 StringBuilder를 이용해 문자열을 결합했으나 StringConcatFactory는 invokedynamic 명령어와 함께 동작하여 런타임에 가장 효율적인 방식으로 문자열을 결합할 수 있도록 최적화합니다. StringConcatFactory는 문자열 결합 패턴에 따라 적합한 결합 전략을 선택할 수 있게 해주므로 메모리 사용과 처리 속도를 개선하는 데 중요한 역할을 합니다.\r\n\r\n## 5. 정리\r\n+ String 클래스\r\n    + 자바에서 문자열을 다루기 위한 클래스입니다. String은 불변(Immutable) 객체로 값을 변경할 수 없도록 설계되었습니다. \r\n    + 자바 9부터는 메모리 효율성을 위해 byte[] 배열을 사용하는 압축 문자열(Compact Strings) 방식을 도입했습니다.\r\n+ String 선언 방식\r\n    + 리터럴 방식: 동일한 문자열을 String Pool에 저장해 메모리를 절약하며, `\"==\"`로 비교할 수 있습니다.\r\n    + new 연산자 방식: Heap 영역에 항상 새로운 String 객체를 생성합니다.\r\n+ 가변 String 클래스\r\n    + 문자열 변경 시 메모리와 성능을 개선하기 위해 StringBuffer(스레드 안전)와 StringBuilder(단일 스레드에서 효율적) 클래스를 사용합니다.\r\n+ String 최적화\r\n    + 문자열 리터럴 최적화: 컴파일 시점에 문자열 리터럴을 결합해 성능을 향상시킵니다.\r\n    + String 변수 최적화: 런타임 시점에 StringBuilder를 이용하거나, StringConcatFactory를 이용하여 성능을 최적화합니다.\r\n    \r\n## 참조\r\n+ https://velog.io/@gates/JAVA-String-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90\r\n+ https://www.baeldung.com/java-string-immutable\r\n+ https://bugs.openjdk.org/browse/JDK-8054307\r\n+ https://www.inflearn.com/community/questions/1423424/string%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%EB%B0%A9%EC%8B%9D-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8\r\n+ https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EC%A4%91%EA%B8%89-1"},{"excerpt":"if(kakao) 는 카카오 그룹의 기술 비전을 공개하고 기술적 성과를 소개하는 대표 개발자 컨퍼런스입니다. 매년 참여를 희망하며 신청했지만 올해 처음으로 당첨되는 행운을 얻어 마지막 날 행사에 참석할 수 있었습니다. 0. 셔틀버스 & 굿즈 오전 8시 20분까지 양재역에 도착해 셔틀버스를 타고 행사장으로 이동했습니다. 버스에 타자마자 굿즈를 나눠주셔서 기…","fields":{"slug":"/archive/review/1/"},"frontmatter":{"date":"October 25, 2024","title":"[후기] if(kakao) 2024","description":"if(kakaoAI) 2024 후기","tags":["컨퍼런스"],"series":"","previewImage":"oop.png","isPrivate":false},"rawMarkdownBody":"\r\n![카카오컨퍼런스](./kakao_img1.jpg)\r\n\r\n**if(kakao)** 는 카카오 그룹의 기술 비전을 공개하고 기술적 성과를 소개하는 대표 개발자 컨퍼런스입니다.   \r\n매년 참여를 희망하며 신청했지만 올해 처음으로 당첨되는 행운을 얻어 마지막 날 행사에 참석할 수 있었습니다.\r\n\r\n## 0. 셔틀버스 & 굿즈\r\n\r\n오전 8시 20분까지 양재역에 도착해 셔틀버스를 타고 행사장으로 이동했습니다.   \r\n버스에 타자마자 굿즈를 나눠주셔서 기분 좋게 시작할 수 있었습니다.\r\n\r\n![카카오컨퍼런스](./kakao_img3.jpg)\r\n\r\n이번 행사는 경기도 용인에 위치한 카카오 AI 캠퍼스에서 진행되었는데요. 날씨도 좋고 캠퍼스 건물 역시 인상적이었습니다. 곳곳에 비치된 물, 음료, 견과류 등 간식 덕분에 행사 내내 편하게 즐길 수 있었던 점도 만족스러웠습니다.\r\n\r\n![카카오컨퍼런스](./kakao_img2.jpg)\r\n\r\n## 1. Panel Talk\r\n\r\n오전 10시 오프닝 세션이 시작되었습니다. 이 시간에는 카카오 계열사들이 AI 기술을 어떻게 활용하고 있는지 구체적으로 소개했는데요. **특히 카카오페이와 카카오뱅크가 이상 거래 탐지 시스템(FDS)에 AI를 적용하고 있다는 점이 인상 깊었습니다.**  기존에는 사람만이 판단할 수 있다고 여겨졌던 영역에 AI가 도입된 것을 보며 기술의 발전에 신기함을 느꼈습니다.\r\n\r\n발표 내용은 금융 AI와 생활 AI 두 가지 주제로 나뉘었는데 개인적으로는 생활 AI 분야가 더 흥미로웠습니다. 특히 카카오페이지에서 AI가 웹툰 광고를 제작한다는 점이 놀라웠는데요. **사람이 작업하면 3주가 걸리는 일을 AI가 단 3시간 만에 처리할 수 있다고 합니다.**  또한 카카오모빌리티의 로봇 배송과 자율주행 택시에 대한 발표도 매우 흥미로웠습니다.\r\n\r\n![카카오컨퍼런스](./kakao_img4.jpg)\r\n![카카오컨퍼런스](./kakao_img5.jpg)\r\n![카카오컨퍼런스](./kakao_img6.jpg)\r\n![카카오컨퍼런스](./kakao_img7.jpg)\r\n\r\n## 2. 점심시간 & 체험부스\r\n\r\n![카카오컨퍼런스](./kakao_img8.jpg)\r\n\r\n카카오 AI 캠퍼스는 주변에 먹을만한 곳이 없습니다. 그래서 도시락 제공이 되었는데요. 아무래도 냉동이다보니 닭강정이랑 김밥이 좀 차갑더라구요. 식사 후에는 건물을 둘러보며 체험 부스도 구경했습니다. 밖에는 자율주행 택시가 1층 체험존에는 카나나 AI 포토부스가 있었고 2층에서는 카카오모빌리티의 로봇배송 서비스인 '브링'과 카카오헬스의 '파스타' 등 다양한 기술들을 직접 체험할 수 있었습니다. 오전에 들었던 기술 설명을 실제로 사용해 볼 수 있어 흥미로운 경험이었습니다.\r\n\r\n![카카오컨퍼런스](./kakao_img9.jpg)\r\n![카카오컨퍼런스](./kakao_img10.jpg)\r\n![카카오컨퍼런스](./kakao_img11.jpg)\r\n\r\n## 3. 인상깊었던 세션\r\n\r\n오전에는 카카오모빌리티 발표를 듣고 흥미가 생겨 **\"무엇이든 로봇배송! 진짜 되는 플랫폼 이야기\"** 세션에 참석했습니다. 기존 로봇 배송은 API 연동 방식으로 인해 여러 로봇 제조사에 공통 적용이 어려웠고 특정 제조사에 의존하는 구조였다고 합니다. 이를 개선하기 위해 설계를 변경하여 모든 제조사에 적용 가능한 플랫폼으로 바꿨다는 설명이 인상적이었습니다.\r\n\r\n![카카오컨퍼런스](./kakao_img12.jpg)\r\n\r\n마지막으로 **\"카카오 빌링 MySQL DB 샤딩 적용\"** 세션도 들었는데요. 발표자분이 유머를 곁들여 진행해 즐겁게 들을 수 있었습니다. 😄 DB 샤딩(Sharding)은 데이터베이스 트래픽을 분산시키는 중요한 방법으로 쉽게 말해서 각 DB서버에 데이터를 나눠 저장하는 방식을 말합니다. 기존에는 1대 서버에 의존하던 것을 12대로 대폭 확장했다고 합니다. 이 작업은 카카오 DB 팀과 협업해 108일 동안 진행되었다고 하네요.\r\n\r\n## 4. 마무리\r\n\r\n이번 카카오 AI 캠퍼스 방문을 통해 다양한 기술을 직접 체험하고 최신 트렌드를 배울 수 있는 뜻깊은 시간이었습니다. 특히 로봇 배송과 DB 샤딩과 같은 실무적이고 혁신적인 주제들을 접하며 많은 인사이트를 얻을 수 있었는데요. 앞으로도 이런 기술들이 어떻게 발전해 나갈지 기대가 됩니다. 또 이런 경험을 바탕으로 제 업무와 성장에도 도움이 될 수 있을 것 같아 더욱 의미 있었던 시간이었습니다.\r\n\r\n## 참조\r\n+ https://if.kakao.com/session?t.RVmWsFVgRd=2"},{"excerpt":"스터디에서 다형적참조에 대해 발표하게 되어 정리해보고자 합니다. 0. 서론 다형적 참조에 대해 설명하기 전에 먼저 다형성(Polymorphism)에 대해 알아보죠. 다형성(Polymorphism)은 객체지향 프로그래밍의 중요한 개념중 하나로 여러가지 형태를 가질 수 있는 능력을 의미합니다. 예시를 들자면, 다형성(Polymorphism)은 부모 클래스 타…","fields":{"slug":"/archive/java/1/"},"frontmatter":{"date":"September 28, 2024","title":"[Java] 다형적 참조","description":"다형적 참조","tags":["Java","Study"],"series":"Java","previewImage":"java_logo.png","isPrivate":false},"rawMarkdownBody":"\r\n스터디에서 다형적참조에 대해 발표하게 되어 정리해보고자 합니다.\r\n\r\n## 0. 서론\r\n\r\n다형적 참조에 대해 설명하기 전에 먼저 다형성(Polymorphism)에 대해 알아보죠.   \r\n다형성(Polymorphism)은 객체지향 프로그래밍의 중요한 개념중 하나로 **여러가지 형태를 가질 수 있는 능력을 의미**합니다. 예시를 들자면, 다형성(Polymorphism)은 부모 클래스 타입의 변수가 자식 클래스 타입의 객체를 참조할 수 있다는 것을 뜻합니다.\r\n\r\n## 1. 다형적 참조란?\r\n\r\n다시 돌아와서 다형적 참조(Polymorphic Reference)에 대해 알아보죠.   \r\n다형적 참조(Polymorphic Reference)는 **부모 클래스 타입의 인스턴스로 자식 클래스 타입의 인스턴스를 참조 할 수 있는 기능**을 의미합니다. 이는 다형성을 실현하는 방법 중 하나입니다.\r\n\r\n다형성과 비슷하다고 생각할 수 있지만 다형성과 다형적 참조는 보시다싶이 서로 다른 개념입니다. \r\n다형성이 더 포괄적인 개념이죠.\r\n![다형성과다형적참조](/1.png)\r\n\r\n## 2. 예제코드\r\n\r\nAnimal 클래스와 Jaelong 클래스가 있다고 가정해보죠. \r\n두 클래스는 부모(Animal)와 자식(Jaelong) 관계입니다.\r\n\r\n```java\r\npublic class Animal {\r\n    public void print() {\r\n        System.out.println(\"Animal\");\r\n    }\r\n}\r\n```\r\n```java\r\npublic class Jaelong extends Animal {\r\n    public void print() {\r\n        System.out.println(\"Jaelong\");\r\n    }\r\n\r\n    public void sound() {\r\n        System.out.println(\"멍멍\");\r\n    }\r\n}\r\n```\r\n\r\n```java\r\npublic class PolyTest {\r\n    public static void main(String[] args) {\r\n        Animal animal = new Animal();\r\n        Animal animal2 = new Jaelong();\r\n\r\n        animal.print();\r\n        animal2.print();\r\n    }\r\n}\r\n```\r\n\r\n이렇게 코드가 되어있다면 결과를 어떻게 될까요?\r\n\r\n```\r\n[결과]\r\nAnimal\r\nJaelong\r\n```\r\n\r\n`Animal animal2 = new Jaelong();` 부분에서 **다형적 참조를 통해 자식 클래스의 인스턴스로 변경되었기 때문에 \"Jaelong\"이라고 결과가 나오게 된 것입니다**.\r\n\r\n그렇다며 소스코드가 이렇게 되었다면 결과가 어떻게 될까요?\r\n\r\n```java\r\npublic class PolyTest {\r\n    public static void main(String[] args) {\r\n        Animal animal = new Animal();\r\n        Animal animal2 = new Jaelong();\r\n\r\n        animal.print();\r\n        animal2.print();\r\n        // 추가\r\n        animal2.sound();\r\n    }\r\n}\r\n```\r\n\r\n소스를 실행시키면 컴파일 에러가 발생합니다. 왜 그런걸까요?   \r\n다형적 참조로 자식 클래스의 인스턴스를 참조 했고 Jaelong 클래스에는 sound()가 있는데 말이죠.\r\n\r\n![소스분석](/2.png)\r\n`animal 변수`가 생성이 될때 메모리에 Animal 클래스만 로드가 됩니다. 반면에 `animal2 변수` 생성이 될때는 Jaelong 클래스와 부모 클래스인 Animal까지 같이 생성이 됩니다. \r\n\r\n![소스분석2](/3.png)\r\n`animal2 변수`는 Animal 타입으로 선언했기 때문에 먼저 Animal 클래스에 sound() 메소드가 있는지 확인합니다. **메소드를 찾는 방향은 자식->부모순으로 Animal (부모)에서 내려가면서 찾을 수는 없습니다.** 따라서 컴파일 오류가 발생한 것입니다. Jaelong 클래스로 다운 캐스팅후 호출하면 오류 없이 호출 할 수 있습니다.\r\n\r\n```java\r\npublic class PolyTest {\r\n    public static void main(String[] args) {\r\n        Animal animal = new Animal();\r\n        Animal animal2 = new Jaelong();\r\n\r\n        animal.print();\r\n        animal2.print();\r\n        // 추가\r\n        // animal2.sound(); // 컴파일 에러\r\n        ((Jaelong) animal2).sound(); // 다운 캐스팅후 호출\r\n    }\r\n}\r\n```\r\n\r\n## 3. 정리\r\n\r\n+ 다형성(Polymorphism)\r\n   + 객체지향 프로그래밍의 개념중 하나로 여러가지 형태를 가질 수 있는 능력을 의미합니다. \r\n+ 다형적 참조(Polymorphic Reference)\r\n   + 부모 클래스 타입의 인스턴스로 자식 클래스 타입의 인스턴스를 참조 할 수 있는 기능을 의미합니다. \r\n+ 메소드를 찾는 방향은 자식->부모순으로, 부모에서 내려가면서 찾을 수는 없습니다.\r\n\r\n\r\n## 참조\r\n+ https://medium.com/@binmuxiz/java-polymorphism-%EB%8B%A4%ED%98%95%EC%84%B1-1-%EB%8B%A4%ED%98%95%EC%A0%81-%EC%B0%B8%EC%A1%B0-1ee2e5535268\r\n+ https://yeoncoding.tistory.com/885\r\n+ GPT"},{"excerpt":"0. 서론 최근 면접을 보러 다니면서  Git 브랜치 전략에 대해 설명해 달라는 기술 질문을 공통적으로 받게 되었습니다. 사실 Git으로 소스 commit만 했지, 깊이있게 공부 하지 않았기 때문에 해당 질문에 대답 할 수 없었습니다. 따라서, Git 브랜치 전략에 대해 정리해보고자 합니다. 1. Git 브랜치 전략이란? Git은 브랜치라는 것을 사용하는…","fields":{"slug":"/archive/tech/1/"},"frontmatter":{"date":"September 04, 2024","title":"[기술면접] Git 브랜치 전략","description":"Git 브랜치 전략","tags":["Tech","Git"],"series":"기술면접","previewImage":"writing-help.png","isPrivate":false},"rawMarkdownBody":"\r\n## 0. 서론\r\n최근 면접을 보러 다니면서  **Git 브랜치 전략**에 대해 설명해 달라는 기술 질문을 공통적으로 받게 되었습니다. 사실 Git으로 소스 commit만 했지, 깊이있게 공부 하지 않았기 때문에 해당 질문에 대답 할 수 없었습니다.\r\n\r\n따라서, Git 브랜치 전략에 대해 정리해보고자 합니다.\r\n\r\n## 1. Git 브랜치 전략이란?\r\n\r\nGit은 브랜치라는 것을 사용하는데요. 브랜치는 특정 시점 스냅샷 같은 개념이라고 생각하시면 됩니다.   \r\n브랜치를 사용하면 한 프로젝트에서 서로 여러 작업을 동시에 수행하면서도, 작업간의 영향을 최소화 할 수 있습니다.\r\n\r\n이런 Git의 브랜치를 관리하는 전략을 Git 브랜치 전략이라고 말합니다.\r\n\r\n## 2. Git 브랜치 전략 사용 목적\r\n\r\n그렇다면 Git 브랜치 전략을 사용하는 목적이 뭘까요?   \r\nGit 브랜치 전략을 사용하는 목적에는 여러가지가 있지만 **문제가 생겼을 때 빠르게 복구하기 위해서**라고 생각합니다. 앞서 설명한 것처럼 브랜치를 사용하면 여러 가지 작업을 동시에 안전하게 진행할 수 있고, 언제든지 문제가 생기면 원래 상태로 돌아갈 수 있습니다.   \r\n\r\n## 3. Git 브랜치 전략 종류\r\n\r\n대표적인 Git 브랜치 전략에 대해 알아보겠습니다.\r\n\r\n+ Git Flow\r\n  + 브랜치 설명\r\n    + `main 브랜치`\r\n      + main 또는 master 브랜치 의미.\r\n      + 항상 배포 가능한 상태를 유지해야 합니다.\r\n    + `develop 브랜치` \r\n      + 개발이 완료된 코드를 통합하는 브랜치.\r\n      + 모든 기능은 develop 브랜치로 병합된 후 테스트 되어야 합니다.\r\n    + `feature 브랜치` \r\n      + 개발을 위해 develop 브랜치에서 파생된 브랜치.\r\n      + 개발이 완료되면 develop 브랜치로 병합됩니다.\r\n    + `release 브랜치` \r\n      + 배포 준비가 된 코드를 관리하는 브랜치.\r\n      + develop 브랜치에서 파생되어 테스트와 버그 수정을 거쳐 main 브랜치에 병합됩니다.\r\n    + `hotfix 브랜치`\r\n      + main 브랜치에서 직접 파생된 브랜치.\r\n      + 긴급한 버그 수정을 위해 사용되며, 수정 후 main과 develop 브랜치에 병합됩니다.\r\n  + 과정\r\n  ![GitFlow](https://images.squarespace-cdn.com/content/v1/5cd29903aadd34273bef66f8/50f3fcb5-5798-481c-85f0-5a85f0886ed9/Gitflow.png?format=2500w)\r\n  + 특징\r\n    + 복잡한 프로젝트에서 브랜치를 체계적으로 관리하기 위한 전략입니다. **주로 여러 단계의 개발과 배포를 체계적으로 관리하고자 할 때 사용**됩니다.\r\n    + **릴리즈와 관련된 버전을 체계적으로 관리하는 데 유리**합니다.\r\n  + 장/단점\r\n    + 개발과 릴리즈 준비를 분리하여 안정성을 유지할 수 있습니다.\r\n    + 브랜치가 많아지면 복잡해질수 있습니다.\r\n+ GitHub Flow\r\n  + 브랜치 설명\r\n    + `main 브랜치`:\r\n      + Git Flow의 `main 브랜치`와 동일합니다.\r\n    + `feature 브랜치`:\r\n      + 기능 또는 버그 수정을 위해 main 브랜치에서 파생된 브랜치\r\n      + 개발이 완료되면 `pull request`를 통해 코드 리뷰를 받고 main 브랜치로 병합됩니다.\r\n  + 과정\r\n  ![GitHubFlow](https://images.squarespace-cdn.com/content/v1/5cd29903aadd34273bef66f8/e05668eb-89fa-4ee0-8350-35c93d029fad/GitHub+Flow.png?format=2500w)\r\n  + 특징\r\n    + 소규모이거나 빠른 배포 주기를 가진 프로젝트를 위해 제안된 **간단하고 단순한 브랜치 전략**입니다.\r\n    + 단일 main 브랜치에서 이루어지며, feature 브랜치를 통해 코드 변경을 관리합니다.\r\n    + GitHub Flow는 PR 생성 시 자동으로 테스트가 실행되도록 설정할 수 있습니다. 이를 통해 코드가 main 브랜치에 병합되기 전에 버그가 없는지 기능이 정상적으로 동작하는지를 확인할 수 있습니다. 이를 통해 소스 코드의 품질까지 향상 시킬 수 있습니다.\r\n  + 장/단점\r\n    + 간단하고 직관적인 구조, 빠른 배포와 피드백 주기에 적합합니다.\r\n    + 릴리즈와 핫픽스 관리가 다소 비효율적일 수 있습니다.\r\n+ GitLab Flow\r\n  + 브랜치 설명\r\n    + `production 브랜치`\r\n      + 운영 환경에 배포되는 브랜치.\r\n    + `environment-specific 브랜치`\r\n      + 다양한 환경(staging, pre-production 등)에 맞는 브랜치로, 각 환경에 맞게 코드가 준비됩니다.\r\n    + `feature 브랜치`\r\n      + 개발을 위한 브랜치로 특정 환경 브랜치에 병합됩니다.\r\n  + 과정\r\n  ![GitLabFlow](https://images.squarespace-cdn.com/content/v1/5cd29903aadd34273bef66f8/87ed52b9-cb2e-456a-b345-c04121fb49b2/Gitlab+flow.png?format=2500w)\r\n  + 특징\r\n    + **GitHub Flow와 Git Flow의 장점을 결합**한 브랜치 전략입니다.\r\n    + 주로 main 브랜치와 feature 브랜치 외에도 환경 기반 브랜치를 사용합니다.\r\n  + 장/단점\r\n    + 환경에 맞는 브랜치 관리로 안정성 향상시킬 수 있으나, 환경 브랜치 관리가 복잡할 수 있습니다.\r\n## 4. 결론\r\n배포를 체계적으로 해야되는 경우에는 Git Flow를 사용하고, 배포를 자주 해야되는 경우에는 GitHub Flow를 사용하면 될 것 같습니다.\r\n프로젝트의 규모와 배포 주기에 따라서 알맞은 Git 브랜치 전략을 세우는것이 중요합니다.\r\n\r\n+ 참조\r\n  + https://be-student.tistory.com/83\r\n  + https://parkstate.tistory.com/33\r\n  + https://www.eisquare.co.uk/blogs/how-to-choose-your-branching-strategy"},{"excerpt":"1. 현상 A팝업 -> B팝업 -> C팝업으로 호출하는 경우 B팝업에서만 팝업 호출 시 해당 화면이 reload 되는 현상이 발생했다. 2. 원인 form 태그 안에  button 태그가 1개만 있는 경우에 onclick() 이벤트와 동시에 submit()도 같이 동작된다. 그래서 발생한 오류였다. 3. 해결 방법1) 방법2) 이런 방법 말고도 검색해보면…","fields":{"slug":"/error/2/"},"frontmatter":{"date":"August 25, 2024","title":"[오류] 팝업 여러개 띄울때 화면 reload 발생","description":"팝업 여러개 띄울때 화면 reload 발생","tags":["Error","Web"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\r\n## 1. 현상 \r\nA팝업 -> B팝업 -> C팝업으로 호출하는 경우 B팝업에서만 팝업 호출 시 해당 화면이 reload 되는 현상이 발생했다.\r\n\r\n## 2. 원인\r\n```html\r\n<form>\r\n    <button onclick=\"test();\"></button>\r\n</form>\r\n```\r\n**form 태그 안에  button 태그가 1개만 있는 경우에 onclick() 이벤트와 동시에 submit()도 같이** 동작된다. 그래서 발생한 오류였다.\r\n\r\n## 3. 해결\r\n+ 방법1)\r\n```html\r\n<form id=\"testForm\" method=\"post\" target=\"iframe1\">\r\n    <iframe id=\"iframe1\" name=\"iframe1\" style=\"display:none\"></iframe>\r\n</form>\r\n```\r\n+ 방법2)\r\n```html\r\n<form id=\"testForm\" method=\"post\" target=\"iframe1\">\r\n    <button type=\"button\" onclick=\"test();\"></button>\r\n</form>\r\n```\r\n이런 방법 말고도 검색해보면 다른 방법이 많이 있지만 나의 경우에는 이 2가지 방법으로 했을 때 오류가 발생하지 않았다.   \r\n\r\nbutton 태그에 대해서 좀 더 알아보다가 재미난 글을 발견하였다.   \r\n👉🏻[버튼에 타입을 쓰는 이유 (button type='button')](https://nykim.work/96 \"버튼에 타입을 쓰는 이유 (button type='button')\")\r\n\r\n+ 참조\r\n    + https://nykim.work/96"},{"excerpt":"1. 현상  메소드를 이용해서 js를 분기처리 하는데 SSL 적용이 된 운영서버에서 http 리소스가 로드되어서 에러가 발생하였다. 2. 원인 web서버에서 was서버를 호출할때는 http 통신이기 때문에 isSecure() 메소드에서 false가 나온 것이다. 3. 해결 방법1) 방법2) 위와 같이 2가지 방법이 있는데 처음에는 x-forwarded-p…","fields":{"slug":"/error/3/"},"frontmatter":{"date":"August 25, 2024","title":"[오류] https 도메인인데 request.isSecure() return false인 경우","description":"https 도메인인데 request.isSecure() return false인 경우","tags":["Error","Web"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\r\n## 1. 현상 \r\n`request.isSecure()` 메소드를 이용해서 js를 분기처리 하는데 SSL 적용이 된 운영서버에서 http 리소스가 로드되어서 에러가 발생하였다.\r\n```\r\n<%\r\n   if( !request.isSecure() ) {\r\n%>\r\n\t<!-- http -->\r\n<%\r\n    } else {\r\n%>\r\n\t<!-- https -->\r\n<%\r\n    }\r\n%>\r\n```\r\n\r\n## 2. 원인\r\nweb서버에서 was서버를 호출할때는 http 통신이기 때문에 isSecure() 메소드에서 false가 나온 것이다.\r\n\r\n## 3. 해결\r\n+ 방법1) \r\n```\r\nrequest.getHeader(\"x-forwarded-proto\")\r\n```\r\n+ 방법2) \r\n```\r\nrequest.getRequestURL().indexOf(\"http://\") != -1\r\n```\r\n위와 같이 2가지 방법이 있는데 처음에는 x-forwarded-proto를 이용해서 하였으나 로드밸런서가 없는 로컬과 개발에서는 null로 나와서 방법 2로 변경하였다.\r\n\r\n> x-forwarded-proto \r\n> + 클라이언트가 로드밸런서에 접속할 때 사용한 프토토콜을 식별하는 표준 헤더\r\n\r\n+ 참조\r\n    + https://zetawiki.com/wiki/X-Forwarded-Proto\r\n"},{"excerpt":"1. 현상 2. 원인 3. 해결 참조","fields":{"slug":"/sample/test/"},"frontmatter":{"date":"August 25, 2024","title":"test","description":"tet","tags":["Error","Web"],"series":"오류 모음집","previewImage":"java_logo.png","isPrivate":true},"rawMarkdownBody":"\r\n## 1. 현상 \r\n## 2. 원인\r\n## 3. 해결\r\n+ 참조\r\n"},{"excerpt":"환경설정 개발툴 : InteliJ Spring Boot : 2.7.14 Hibernate : 5.6.15 Java : 11 Gradle SpringBoot 검색을 해보면 application.properties 파일에 이 내용을 추가하면 파라미터 바인딩이 출력된다고 하는데, 저의 경우에는 그렇게 해도 나오지 않았습니다. 이 글을 참고하여 하니 원하는 결과…","fields":{"slug":"/archive/jpa/1/"},"frontmatter":{"date":"August 25, 2024","title":"[JPA] Hibernate 쿼리 파라미터 바인딩 출력","description":"Hibernate 쿼리 파라미터 바인딩 출력","tags":["JPA","Hibernate"],"series":"JPA","previewImage":"jpa.png","isPrivate":false},"rawMarkdownBody":"\r\n> 환경설정\r\n> + 개발툴 : InteliJ\r\n> + Spring Boot : 2.7.14\r\n> + Hibernate : 5.6.15\r\n> + Java : 11\r\n> + Gradle\r\n\r\n![SpringBoot](/images/hibernate_post.png)\r\n\r\n검색을 해보면 application.properties 파일에   \r\n```\r\nlogging.level.org.hibernate.SQL = debug\r\nlogging.level.org.hibernate.type.descriptor.sql = trace\r\n```\r\n이 내용을 추가하면 파라미터 바인딩이 출력된다고 하는데, 저의 경우에는 그렇게 해도 나오지 않았습니다.   \r\n이 글을 참고하여 하니 원하는 결과가 나왔습니다.   \r\n👉🏻[hibernate 의 완성된(?) 쿼리를 확인 하는 방법 문의 드립니다](https://www.inflearn.com/community/questions/59014/hibernate-%EC%9D%98-%EC%99%84%EC%84%B1%EB%90%9C-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%ED%99%95%EC%9D%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%AC%B8%EC%9D%98-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)\r\n\r\n\r\n## 1. bulid.gradle 파일에 추가 \r\n```\r\nimplementation 'org.bgee.log4jdbc-log4j2:log4jdbc-log4j2-jdbc4.1:1.16'\r\n```\r\n\r\n## 2. logback.xml 파일 추가\r\n`resources` 폴더 밑에 `logback.xml` 파일을 만들어줍니다.\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<configuration>\r\n    <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\">\r\n        <layout class=\"ch.qos.logback.classic.PatternLayout\">\r\n            <Pattern>%d{HH:mm} %-5level %logger{36} - %msg%n</Pattern>\r\n        </layout>\r\n    </appender>\r\n\r\n    <logger name=\"org.hibernate.type\" level=\"trace\" />\r\n\r\n    <root level=\"info\">\r\n        <appender-ref ref=\"STDOUT\" />\r\n    </root>\r\n</configuration>\r\n```\r\n\r\n## 3. 실행 결과\r\n파라미터가 같이 나오는 것을 확인 할 수 있습니다.\r\n![실행결과](./result.png)\r\n+ 참조\r\n    + https://www.inflearn.com/questions/59014/hibernate-%EC%9D%98-%EC%99%84%EC%84%B1%EB%90%9C-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%ED%99%95%EC%9D%B8-%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%AC%B8%EC%9D%98-%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4"},{"excerpt":"환경설정 개발툴 : InteliJ Spring Boot : 2.7.14 Quartz : 2.3.2 Java : 11 Gradle SpringBoot Spring Boot에서 Quartz 연동 하는 예제를 소개합니다. 1. bulid.gradle 파일에 추가 2. @Scheduled 어노테이션을 이용 스케쥴러를 적용할 메소드에  어노테이션을 사용합니다. 이…","fields":{"slug":"/archive/spring/1/"},"frontmatter":{"date":"August 25, 2024","title":"[Spring Boot] Quartz 연동 예제","description":"Spring Boot Quartz 연동 예제","tags":["Srping Boot","Quartz"],"series":"Spring Boot","previewImage":"springboot_logo.png","isPrivate":false},"rawMarkdownBody":"\r\n> 환경설정\r\n> + 개발툴 : InteliJ\r\n> + Spring Boot : 2.7.14\r\n> + Quartz : 2.3.2\r\n> + Java : 11\r\n> + Gradle\r\n\r\n![SpringBoot](/images/springboot_post.png)\r\n\r\nSpring Boot에서 Quartz 연동 하는 예제를 소개합니다.\r\n\r\n## 1. bulid.gradle 파일에 추가 \r\n```\r\nimplementation \"org.springframework.boot:spring-boot-starter-quartz\"\r\n```\r\n\r\n## 2. @Scheduled 어노테이션을 이용\r\n스케쥴러를 적용할 메소드에 `@Scheduled` 어노테이션을 사용합니다.\r\n```java\r\n@Controller\r\npublic class QuartzController {\r\n    @Scheduled(cron = \"0/5 * * * * ?\")\r\n    public void everyFiveSeconds() {\r\n        DateTimeFormatter patten = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\r\n        String formatDt = patten.format(LocalDateTime.now());\r\n\r\n        System.out.println(formatDt);\r\n    }\r\n}\r\n```\r\n`@SpringBootApplication`이 붙은 파일에 `@EnableScheduling` 어노테이션를 추가합니다.   \r\n추가 하지 않으면 스케쥴러가 실행되지 않습니다.\r\n```java\r\n@SpringBootApplication\r\n@EnableScheduling\r\npublic class Application {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(Application.class, args);\r\n    }\r\n}\r\n```\r\n> @EnableScheduling\r\n> + 스케쥴러를 기능을 켜는 역할을 하며, @Scheduled 어노테이션을 찾아서 실행을 시킨다.\r\n\r\n## 3. 실행 결과\r\n5초마다 실행 된것을 확인 할 수 있습니다.\r\n![SpringBoot](./result.png)\r\n+ 참조\r\n    + https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/EnableScheduling.html"},{"excerpt":"1. 현상 개발서버 https 적용으로 아래와 같이 http 요청 블락 에러가 발생하였다. 그래서 아래의 메타 태그를 추가해 줬다.  하지만 개발서버 https 적용을 해제하면서부터 화면 접속시 자동으로  로 붙어서 js, css를 읽는 경우가 발생하였다. 2. 원인 https때문에 추가했던 메타 태그의 문제로, content-security-policy…","fields":{"slug":"/error/1/"},"frontmatter":{"date":"August 23, 2024","title":"[오류] 자동으로 도메인에 https가 붙는 경우","description":"자동으로 도메인에 https가 붙는 경우","tags":["Error","Web"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\r\n## 1. 현상 \r\n개발서버 https 적용으로 아래와 같이 http 요청 블락 에러가 발생하였다.\r\n```\r\nThis request has been blocked; the content must be served over HTTPS.\r\n```\r\n그래서 아래의 메타 태그를 추가해 줬다. \r\n```html\r\n<meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\">\r\n```\r\n하지만 개발서버 https 적용을 해제하면서부터 화면 접속시 자동으로 `https://` 로 붙어서 js, css를 읽는 경우가 발생하였다.\r\n\r\n## 2. 원인\r\n```html\r\n<meta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\">\r\n```\r\nhttps때문에 추가했던 메타 태그의 문제로, content-security-policy를 설정할 경우 자동으로 https로 호출해 주는 것이었다. \r\n```\r\nThe HTTP Content-Security-Policy (CSP) upgrade-insecure-requests directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS).\r\nHTTP Content-Security-Policy(CSP) upgrade-insecure-requests\r\n```\r\n\r\n## 3. 해결\r\n해당 태그를 주석처리 하면 현상은 해결되지만, 개발서버에 https 적용 시 http 요청 블락 에러를 이 방법 말고 다른 방법으로 해야 될 것 같다. 로컬은 http인데 개발서버는 https인 경우에는 이 메타태그를 사용하는 것은 좋은 방법이 아닌 것 같다.\r\n\r\n+ 참조\r\n  + https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/upgrade-insecure-requests\r\n"},{"excerpt":"Default Private Posts This is a default private post. It's recommended not to delete this posts 😵 (현재 이 포스트는 삭제하지 말아주세요.)","fields":{"slug":"/default/private-default/"},"frontmatter":{"date":"January 01, 2024","title":"Default Private","description":null,"tags":["private-tag"],"series":null,"previewImage":"banned.png","isPrivate":true},"rawMarkdownBody":"\r\n## Default Private Posts\r\n\r\nThis is a default private post. It's recommended not to delete this posts 😵\r\n\r\n(현재 이 포스트는 삭제하지 말아주세요.)\r\n"},{"excerpt":"환경설정 개발툴 : 이클립스 Spring : 4.3.3 Quartz : 2.3.0 Tomcat : 8.5 Java : 8 서버 :CentOS 1. 현상 개발서버에서 톰캣 프로세스가 여러개가 뜨면서 메모리 너무 많이 잡아먹는 현상이 발생하였다.\r\nnetstate -tnlp 하면 8080포트는 하나만 나오고, ps -ef | grep tomcat 하면 여러개…","fields":{"slug":"/error/4/"},"frontmatter":{"date":"August 12, 2023","title":"[오류] 톰캣 프로세스 여러개 뜨는 경우","description":"톰캣 프로세스 여러개 뜨는 경우","tags":["Error","Tomcat"],"series":"오류 모음집","previewImage":"how.png","isPrivate":false},"rawMarkdownBody":"\r\n> 환경설정\r\n> + 개발툴 : 이클립스\r\n> + Spring : 4.3.3\r\n> + Quartz : 2.3.0\r\n> + Tomcat : 8.5\r\n> + Java : 8\r\n> + 서버 :CentOS\r\n\r\n## 1. 현상 \r\n개발서버에서 톰캣 프로세스가 여러개가 뜨면서 메모리 너무 많이 잡아먹는 현상이 발생하였다.\r\n**netstate -tnlp 하면 8080포트는 하나만 나오고, ps -ef | grep tomcat 하면 여러개 나왔다.**\r\n\r\n## 2. 원인\r\n검색을 하다가 아래의 글을 보고 quartz 스케쥴러의 문제라고 생각이 들었다. \r\n톰캣 서버가 종료되어도 이미 실행된 job 스레드는 종료되지 않고 계속 남는다.   \r\n👉🏻[톰켓 프로세스 종료 이슈](https://log4day.tistory.com/m/59 \"톰켓 프로세스 종료 이슈\")\r\n\r\n## 3. 해결\r\ndestroy-method 속성을 이용해서 SchedulerFactoryBean 클래스에 있는 destroy() 메소드를 추가해줬다.\r\n```xml\r\n<bean id=\"qcrmJobScheduler\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\" destroy-method=\"destroy\">\r\n    <property name=\"triggers\">\r\n        <list>\r\n            <ref bean=\"testJobTrigger\" />\r\n        </list>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n## + 추가(2023.10.13)\r\n위 방법으로 적용 후에도 계속 발생하여 젠킨스 배포시 실행중인 톰캣 프로세스 모두 종료시키는 쉘 스크립트를 추가하였다.\r\n```shell\r\n#!/bin/bash\r\n\r\ntomcat_pids=$(ps aux | grep tomcat | grep java | grep -v grep | awk '{print $2}')\r\n\r\nif [ -n \"$tomcat_pids\" ]; then\r\n    for pid in $tomcat_pids; do\r\n        echo \"PID: $pid\"\r\n        kill -9 $pid\r\n    done\r\nfi\r\n```\r\n\r\n+ 참조\r\n    + https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.htmlhttps://log4day.tistory.com/m/59\r\n    + https://log4day.tistory.com/m/59\r\n"},{"excerpt":"💡 현 포스트는 about 페이지에서도 조회 가능합니다. 포스트를 삭제하지 말고, 이 곳에다 본인만의 멋진 소개 글을 작성해주세요.","fields":{"slug":"/default/about/"},"frontmatter":{"date":"January 01, 2022","title":"Gatsby Starter Haon 저자에 대해 소개합니다.","description":null,"tags":["about"],"series":null,"previewImage":null,"isPrivate":true},"rawMarkdownBody":"\r\n> 💡 현 포스트는 about 페이지에서도 조회 가능합니다. 포스트를 삭제하지 말고, 이 곳에다 본인만의 멋진 소개 글을 작성해주세요.\r\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}