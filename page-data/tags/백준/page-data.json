{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/백준/","result":{"data":{"allMarkdownRemark":{"totalCount":7,"nodes":[{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1138 난이도 : 실버2 2. 내 풀이 방법 시도1 접근 방법 입력 받기 index랑 사람수를 같이 저장할 클래스 선언 list에 넣기 사람수를 기준으로 오름차순 출력 문제점 단순 오름차순 정렬로는 사람 수 조건을 모두 만족하기 어렵다. 자리 배치를 하면서 현재 배열 상태를 고려해야 하기 때문에 이 방식은 논리적으로 성립하지 않음 정렬보다는 \"자리 찾기\" 방식으로 풀어야 한다. 시도2 접근 방법 입력 받기 결과를 저장할 배열 result 선언 N까지 반복 arr[i-1] → 왼쪽에 있어야 할 키 큰 사람 수 = peopleCnt result 배열에서 다음을 반복: 0(빈칸)을 만날 때마다 cnt 변수 값 증가 cnt와 peopleCnt이 같으면 빈칸 위치에 i번 사람을 배치 한번 배치하면 루프 종료 출력 소스 코드 3. 문제 회고 🔍 시도 처음에는 사람 번호와 왼쪽에 있어야 하는 사람 수를 …","fields":{"slug":"/archive/algorithm/24/"},"frontmatter":{"title":"[백준] 한 줄로 서기 Java","description":"한 줄로 서기 Java","date":"2025-06-12","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11720 난이도 : 브론즈4 문제 내용 : N개의 숫자가 공백 없이 문자열 형태로 주어질 때 이 숫자들의 합을 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법  문자열을 한 글자씩 분리한 후 각 문자를 정수로 변환하여 합산한다. 문제점 정답은 맞지만 split()은 내부적으로 정규식을 사용하기 때문에 속도가 느리다. 소스 코드 시도2 접근 방법  String.toCharArray()로 문자 배열을 만든 뒤 각 문자를 '0'과의 차이로 정수로 변환하여 합산한다. 문제점 char 배열을 복사해서 반환하기 때문에 String.charAt() 보다 속도가 느리다. 시도3 접근 방법  charAt(i)을 사용하여 각 문자를 직접 접근하고 '0'을 빼서 정수로 변환한다. 별도의 배열을 만들지 않기 때문에 가장 빠른 방식이다. 각 방법들 성능 비교 위에 시도한 방법들은 모두 제출시 정답이다. 하지…","fields":{"slug":"/archive/algorithm/7/"},"frontmatter":{"title":"[BOJ] 백준 11720 숫자의 합 Java","description":"백준 11720 숫자의 합 Java","date":"2025-05-07","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/9095 난이도 : 실버3 문제 내용 :  이 주어졌을 때, 정수 1, 2, 3을 더해서 을 만드는 모든 방법의 수를 구하는 문제이다. 순서가 다른 경우는 다른 방법으로 취급한다. 2. 내 풀이 방법 시도1 접근 방법 DP (Dynamic Programming) 이용하였다. 점화식 계산 방법 n 방법의 개수 1 1 2 1+1, 2 => 2 3 1+1+1, 1+2, 2+1 => 3 4 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1 => 7 = 4 + 2 + 1 5 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+1+3, 1+2+1+1, 1+2+2, 1+3+1,2+1+1+1, 2+1+2, 2+2+1, 2+3, 3+1+1, 3+2 => 13 = 7 + 4 + 2 소스 코드 3. 문제 회고 🔍 시도 1,2,3을 이용해서 n을 만들어야 한다는 문제의 조건을 보고 …","fields":{"slug":"/archive/algorithm/4/"},"frontmatter":{"title":"[BOJ] 백준 9095 1, 2, 3 더하기 Java","description":"백준 9095 1, 2, 3 더하기 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1912 난이도 : 실버2 문제 내용 : 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구한다. 단, 수는 한 개 이상 선택해야 한다. 2. 내 풀이 방법 시도1 접근 방법 완전탐색(= 브루트포스)를 이용하였다. 문제점 완전탐색의 시간복잡도는  이다. n = 100,000이라면 O(n²) → 10⁵ * 10⁵ → 100억 × 100억 = 1조 연산을 하게 되며 1초에 약 1억 연산 가능하기 때문에 시간 초과가 발생한다. 소스 코드 시도2 접근 방법 누적합 기법을 이용하였다. 계산 방법 i arr sum max 1 -4 max(-4, 10 + (-4)) = max(-4, 6) = 6 max(10, 6) = 10 2 3 max(3, 6 + 3) = max(3, 9) = 9 max(10, 9) = 10 3 1 max(1, 9 + 1) = 10 max(10, 10) = 10 4 5…","fields":{"slug":"/archive/algorithm/5/"},"frontmatter":{"title":"[BOJ] 백준 1912 연속합 Java","description":"백준 1912 연속합 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/2805 난이도 : 실버2 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 이분탐색 방법을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제에 맞는 알고리즘을 생각하지 못하였다. 🛠 해결 과정 문제 유형을 참고하여 이분 탐색 알고리즘을 적용해야 한다는 것을 알게 되었고 이를 기반으로 문제를 해결할 수 있었다. ✅ 잘한 점 ⚠ 개선할 점 이분 탐색 유형 문제를 많이 풀어봐야겠다. 참조","fields":{"slug":"/archive/algorithm/3/"},"frontmatter":{"title":"[BOJ] 백준 2805 나무 자르기 Java","description":"백준 2805 나무 자르기 Java","date":"2025-04-27","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1012 난이도 : 실버2 문제 내용 : 배추가 심어진 곳끼리 연결되어 있으면 하나의 \"덩어리\"로 보고 총 몇 개의 덩어리가 있는지 세는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 BFS 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 BFS 알고리즘과 4방향 탐색(상하좌우)이 필요하다고 빠르게 판단했다.\n 위치에서만 BFS 탐색을 시도했다. 🛠 해결 과정 만 탐색하면 전체 영역을 탐색하지 못하는 문제를 발견했다.\n이후 배열 전체를 순회하며 방문하지 않은 영역마다 BFS를 수행하는 방식으로 접근을 수정했다. ✅ 잘한 점 문제를 읽자마자 BFS로 해결해야 한다는 판단을 빠르게 내렸다.\nDFS/BFS 문제를 여러 번 풀어본 경험이 도움이 되었다. ⚠ 개선할 점 BFS + 4방향 탐색까진 좋았지만 \"전체 배열을 순회하며 시작점을 찾아야 한다\"는 기본적인 접근을 처음부터 …","fields":{"slug":"/archive/algorithm/1/"},"frontmatter":{"title":"[BOJ] 백준 1012 유기농 배추 Java","description":"백준 1012 유기농 배추 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11053 난이도 : 실버2 문제 내용 : 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 TreeSet에 이용해서 중복제거 + 정렬을 하였다. 문제점 TreeSet에 넣어서 중복제거 + 정렬하고 input.size 를 출력하고 있는데\n이건 서로 다른 수의 개수를 구하는 것이지 문제의 핵심인 가장 긴 증가하는 부분 수열을 구하게 아니다. 소스 코드 시도2 접근 방법 DP 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 처음에는 TreeSet을 사용해서 정렬과 중복 제거를 통해 문제를 풀려고 했지만 이는 문제의 의도와 맞지 않았다.\n문제 밑에 있는 알고리즘의 분류를 보고 동적 계획법(DP)을 이용해서 풀었다. 🛠 해결 과정 dp[i] = i번째 숫자를 마지막으로 했을 때의 LIS 길이라고 정의하고 i번째 수를 기준으로 0부터 i-1까지 순회…","fields":{"slug":"/archive/algorithm/2/"},"frontmatter":{"title":"[BOJ] 백준 11053 가장 긴 증가하는 부분 수열 Java","description":"백준 11053 가장 긴 증가하는 부분 수열 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}}]}},"pageContext":{"tag":"백준"}},"staticQueryHashes":[],"slicesMap":{}}