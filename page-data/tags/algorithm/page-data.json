{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/algorithm/","result":{"data":{"allMarkdownRemark":{"totalCount":5,"nodes":[{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/9095 난이도 : 실버3 문제 내용 :  이 주어졌을 때, 정수 1, 2, 3을 더해서 을 만드는 모든 방법의 수를 구하는 문제이다. 순서가 다른 경우는 다른 방법으로 취급한다. 2. 내 풀이 방법 시도1 접근 방법 DP (Dynamic Programming) 이용하였다. 점화식 계산 방법 n 방법의 개수 1 1 2 1+1, 2 => 2 3 1+1+1, 1+2, 2+1 => 3 4 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1 => 7 = 4 + 2 + 1 5 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+1+3, 1+2+1+1, 1+2+2, 1+3+1,2+1+1+1, 2+1+2, 2+2+1, 2+3, 3+1+1, 3+2 => 13 = 7 + 4 + 2 소스 코드 3. 문제 회고 🔍 시도 1,2,3을 이용해서 n을 만들어야 한다는 문제의 조건을 보고 …","fields":{"slug":"/archive/algorithm/4/"},"frontmatter":{"title":"[BOJ] 백준 9095 1, 2, 3 더하기 Java","description":"백준 9095 1, 2, 3 더하기 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1912 난이도 : 실버2 문제 내용 : 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구한다. 단, 수는 한 개 이상 선택해야 한다. 2. 내 풀이 방법 시도1 접근 방법 완전탐색(= 브루트포스)를 이용하였다. 문제점 완전탐색의 시간복잡도는  이다. n = 100,000이라면 O(n²) → 10⁵ * 10⁵ → 100억 × 100억 = 1조 연산을 하게 되며 1초에 약 1억 연산 가능하기 때문에 시간 초과가 발생한다. 소스 코드 시도2 접근 방법 누적합 기법을 이용하였다. 계산 방법 i arr sum max 1 -4 max(-4, 10 + (-4)) = max(-4, 6) = 6 max(10, 6) = 10 2 3 max(3, 6 + 3) = max(3, 9) = 9 max(10, 9) = 10 3 1 max(1, 9 + 1) = 10 max(10, 10) = 10 4 5…","fields":{"slug":"/archive/algorithm/5/"},"frontmatter":{"title":"[BOJ] 백준 1912 연속합 Java","description":"백준 1912 연속합 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/2805 난이도 : 실버2 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 이분탐색 방법을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제에 맞는 알고리즘을 생각하지 못하였다. 🛠 해결 과정 문제 유형을 참고하여 이분 탐색 알고리즘을 적용해야 한다는 것을 알게 되었고 이를 기반으로 문제를 해결할 수 있었다. ✅ 잘한 점 ⚠ 개선할 점 이분 탐색 유형 문제를 많이 풀어봐야겠다. 참조","fields":{"slug":"/archive/algorithm/3/"},"frontmatter":{"title":"[BOJ] 백준 2805 나무 자르기 Java","description":"백준 2805 나무 자르기 Java","date":"2025-04-27","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1012 난이도 : 실버2 문제 내용 : 배추가 심어진 곳끼리 연결되어 있으면 하나의 \"덩어리\"로 보고 총 몇 개의 덩어리가 있는지 세는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 BFS 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 BFS 알고리즘과 4방향 탐색(상하좌우)이 필요하다고 빠르게 판단했다.\n 위치에서만 BFS 탐색을 시도했다. 🛠 해결 과정 만 탐색하면 전체 영역을 탐색하지 못하는 문제를 발견했다.\n이후 배열 전체를 순회하며 방문하지 않은 영역마다 BFS를 수행하는 방식으로 접근을 수정했다. ✅ 잘한 점 문제를 읽자마자 BFS로 해결해야 한다는 판단을 빠르게 내렸다.\nDFS/BFS 문제를 여러 번 풀어본 경험이 도움이 되었다. ⚠ 개선할 점 BFS + 4방향 탐색까진 좋았지만 \"전체 배열을 순회하며 시작점을 찾아야 한다\"는 기본적인 접근을 처음부터 …","fields":{"slug":"/archive/algorithm/1/"},"frontmatter":{"title":"[BOJ] 백준 1012 유기농 배추 Java","description":"백준 1012 유기농 배추 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11053 난이도 : 실버2 문제 내용 : 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 TreeSet에 이용해서 중복제거 + 정렬을 하였다. 문제점 TreeSet에 넣어서 중복제거 + 정렬하고 input.size 를 출력하고 있는데\n이건 서로 다른 수의 개수를 구하는 것이지 문제의 핵심인 가장 긴 증가하는 부분 수열을 구하게 아니다. 소스 코드 시도2 접근 방법 DP 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 처음에는 TreeSet을 사용해서 정렬과 중복 제거를 통해 문제를 풀려고 했지만 이는 문제의 의도와 맞지 않았다.\n문제 밑에 있는 알고리즘의 분류를 보고 동적 계획법(DP)을 이용해서 풀었다. 🛠 해결 과정 dp[i] = i번째 숫자를 마지막으로 했을 때의 LIS 길이라고 정의하고 i번째 수를 기준으로 0부터 i-1까지 순회…","fields":{"slug":"/archive/algorithm/2/"},"frontmatter":{"title":"[BOJ] 백준 11053 가장 긴 증가하는 부분 수열 Java","description":"백준 11053 가장 긴 증가하는 부분 수열 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}}]}},"pageContext":{"tag":"Algorithm"}},"staticQueryHashes":[],"slicesMap":{}}