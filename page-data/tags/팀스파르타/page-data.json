{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/팀스파르타/","result":{"data":{"allMarkdownRemark":{"totalCount":6,"nodes":[{"excerpt":"1. 📝 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/12951 난이도 : 프로그래머스 레벨2 소요시간 : 10분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 문자열을 char 배열 소문자로 변경 배열을 순회하면서 첫번째 글자이거나 이전 글자가 공백 한 칸이면 대문자로 변환 출력 소스 코드 3. 🔍 문제 회고 이 문제는 비교적 단순한 문자열 처리 문제였다. 요구사항대로 단계별로 차근차근 구현하면 쉽게 해결할 수 있었다. 먼저 문자열을 소문자로 다 변경한 다음에 첫 번째 글자이거나 이전 글자가 공백 한 칸인 경우에만 대문자로 변환해줬다. 그리고 String이 불변 객체라는 점을 고려해 StringBuilder를 사용해 메모리 사용 효율을 높였다. 또한 문자열을 char 배열로 변환해 순회함으로써 처리 속도도 개선했다. 📚 참조","fields":{"slug":"/archive/study/jakshim-challenge/6/"},"frontmatter":{"title":"[작심큰일] 작심큰일 6일차 TIL","description":"[작심큰일] 작심큰일 6일차 TIL","date":"2025-08-11","tags":["작심큰일","코딩테스트준비","팀스파르타","TIL"],"series":"작심큰일 챌린지 1기","previewImage":"how.png","isPrivate":false}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/18126 난이도 : 백준 실버4 소요시간 : 20분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 DP 배열 선언 DP 배열 초기화 DP 처리 출력 소스 코드 3. 🔍 문제 회고 전형적인 DP 유형으로 문제 설명에 점화식과 구현 방법이 거의 제시되어 있어 비교적 쉽게 풀 수 있었다. 점화식을 코드로 구현하고 주어진 N에 대한 수열 값을 정확하게 계산하여 제출해야 했다. 점화식을 기반으로 DP 배열을 만들고 초기값 f(1) = 1, f(2) = 1, f(3) = 1을 설정했다.\n그러나 제출시 ArrayIndexOutOfBoundsException이 발생했다. 원인을 확인해 보니 N이 1, 2, 3인 경우에도 배열의 인덱스를 잘못 참조하게 되는 로직이 문제였다. 따라서 N이 1, 2, 3일 경우에는 그대로 초기값을 출력하는 예외 처리를 추가했다. 또한, N의 범위가 116이라 처음에는 int…","fields":{"slug":"/archive/study/jakshim-challenge/5/"},"frontmatter":{"title":"[작심큰일] 작심큰일 5일차 TIL","description":"[작심큰일] 작심큰일 5일차 TIL","date":"2025-08-08","tags":["작심큰일","코딩테스트준비","팀스파르타","TIL"],"series":"작심큰일 챌린지 1기","previewImage":"how.png","isPrivate":false}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/18126 난이도 : 백준 실버2 소요시간 : 32분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 인접행렬 만들기, 방문배열 생성 BFS 탐색을 통해 최대 거리 갱신 출력 소스 코드 시도2 접근 방법 입력 인접행렬 만들기, 방문배열 생성 DFS 탐색을 통해 최대 거리 갱신 출력 소스 코드 3. 🔍 문제 회고 이 문제는 트리 형태의 그래프에서 입구(1번 노드)로부터 가장 멀리 떨어진 노드까지의 거리를 구하는 전형적인 그래프 탐색 문제였다. 모든 노드를 탐색하여 가장 멀리 떨어진 노드까지의 거리를 계산해야 했다. 노드 수가 최대 10만 개까지 주어지므로 시간 복잡도와 메모리 효율성을 고려한 풀이가 필요했다. 또한 거리의 총합이 클 수 있기 때문에 오버플로우 방지도 고려해야 했다. 먼저 BFS 방식을 사용하여 1번 노드를 시작점으로 탐색을 수행했다. 이후 DFS 방식으로도 같은 로직을 구현하여…","fields":{"slug":"/archive/study/jakshim-challenge/4/"},"frontmatter":{"title":"[작심큰일] 작심큰일 4일차 TIL","description":"[작심큰일] 작심큰일 4일차 TIL","date":"2025-08-07","tags":["작심큰일","코딩테스트준비","팀스파르타","TIL"],"series":"작심큰일 챌린지 1기","previewImage":"how.png","isPrivate":false}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/2437 난이도 : 백준 골드2 소요시간 : 50분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 배열 오름차순으로 정렬 배열의 길이만큼 순회 하면서 누적합 계산하여 만들 수 있는지 체크 출력 소스 코드 3. 🔍 문제 회고 백준 2437번 문제는 다양한 무게의 추를 이용해 만들 수 없는 최소 무게를 구하는 문제였다. 골드2 난이도답게 처음에는 어떻게 접근해야 할지 막막했다. 추의 조합을 통해 만들 수 없는 최솟값을 찾아야 했다. 최솟값을 어떻게 구해야 할지 감이 잡히지 않아 풀이 방법을 검색했다. 그 과정에서 '오름차순 정렬 후 누적합을 활용해 만들 수 있는 무게 범위를 좁혀간다'는 그리디 알고리즘 풀이 방법을 알게 되었고 이를 그대로 적용해 문제를 해결했다. 생각보다 간단한 풀이 방법에 허무한 느낌도 들었지만 그리디 문제는 아이디어가 핵심이라는 점을 다시금 깨달았다. 아직 그리디 유형에 …","fields":{"slug":"/archive/study/jakshim-challenge/3/"},"frontmatter":{"title":"[작심큰일] 작심큰일 3일차 TIL","description":"[작심큰일] 작심큰일 3일차 TIL","date":"2025-08-06","tags":["작심큰일","코딩테스트준비","팀스파르타","TIL"],"series":"작심큰일 챌린지 1기","previewImage":"how.png","isPrivate":false}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/2468 난이도 : 백준 실버1 소요시간 : 40분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 배열, 방문배열 생성 bfs 방문배열, 안전영역개수 초기화 영역 순회 현재 높이가 h보다 크고(침수되지 않았고), 방문하지 않은 영역인 경우만 bfs 탐색 출력 소스 코드 3. 🔍 문제 회고 전형적인 BFS 문제였다. 몇 달 전에 한 번 풀었던 기억이 있지만 오랜만에 다시 보니 구현 방법이 정확하게 기억나지 않아 처음부터 차근차근 다시 접근했다. 특히 침수되지 않은 영역만 탐색해야 하는 조건인  부분을 처음에 빠뜨려서 디버깅에 꽤 시간을 허비했다. DFS를 이용해서도 풀었으나 BFS와 속도 차이는 크게 차이 나지 않았다. 📚 참조","fields":{"slug":"/archive/study/jakshim-challenge/2/"},"frontmatter":{"title":"[작심큰일] 작심큰일 2일차 TIL","description":"[작심큰일] 작심큰일 2일차 TIL","date":"2025-08-05","tags":["작심큰일","코딩테스트준비","팀스파르타","TIL"],"series":"작심큰일 챌린지 1기","previewImage":"how.png","isPrivate":false}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/1929 난이도 : 백준 실버3 소요시간 : 14분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 소수 찾기 출력 소스 코드 3. 🔍 문제 회고 이 문제는 범위 내의 모든 소수를 찾는 알고리즘을 구현하는 간단한 문제였다. 기본적인 소수 판별 함수를 작성해 정답을 도출했지만 초반에는 2부터 √N까지만 검사하면 된다는 사실을 잊고 전체 범위를 순회했다. 이후 로직을 수정해 불필요한 연산을 줄일 수 있었다. 하지만 2보다 작은 수를 예외 처리하는 부분을 놓친 점은 아쉬웠지만 빠른 시간 내에 문제를 해결한 점은 좋았다. 📚 참조","fields":{"slug":"/archive/study/jakshim-challenge/1/"},"frontmatter":{"title":"[작심큰일] 작심큰일 1일차 TIL","description":"[작심큰일] 작심큰일 1일차 TIL","date":"2025-08-04","tags":["작심큰일","코딩테스트준비","팀스파르타","TIL"],"series":"작심큰일 챌린지 1기","previewImage":"how.png","isPrivate":false}}]}},"pageContext":{"tag":"팀스파르타"}},"staticQueryHashes":[],"slicesMap":{}}