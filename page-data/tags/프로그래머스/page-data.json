{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/프로그래머스/","result":{"data":{"allMarkdownRemark":{"totalCount":5,"nodes":[{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/136798 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 1부터 number까지 약수의 개수 구하기 number까지의 약수들 중 limit를 초과하는 값들은 power로 값 변경하여 합계 구하기 answer return 소스 코드 3. 문제 회고 🔍 시도 1부터 number까지 각 숫자의 약수 개수를 구한 후 그 개수가 limit을 초과하면 power로 대체하여 누적합(answer)을 계산하는 방식으로 문제를 해결하고자 했다. 🛠 해결 과정 약수 개수를 효율적으로 구하기 위해 제곱근까지만 순회하면서 중복 약수 계산을 방지하는 방식으로 calcCnt() 메서드를 구현했다. ✅ 잘한 점 문제의 구현 로직 자체는 복잡하지 않아 구조를 빠르게 설계할 수 있었고 약수 개수를 구할 때 중복을 방지하는 최적화도 잘 적용했다. ⚠ 개선할 점 초기 문제…","fields":{"slug":"/archive/algorithm/11/"},"frontmatter":{"title":"[프로그래머스] 기사단원의 무기 Java","description":"기사단원의 무기 Java","date":"2025-05-24","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/161990 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 wallpaper 순회 - for문 이용 lux, luy, rdx, rdy 값 갱신 answer 배열에 lux, luy, rdx, rdy 값 저장 소스 코드 3. 문제 회고 🔍 시도 처음에는 단순히 이차원 배열을 순회하면서 #의 위치를 파악하고자 했다. 좌표의 최소값, 최대값을 추적하는 방식으로 접근하면 된다는 생각이이 바로 떠올랐다. 🛠 해결 과정 각 줄을 char[]로 변환해 이중 반복문으로 탐색하며 # 문자의 좌표를 확인하고 그에 따라 lux, luy, rdx, rdy 값을 실시간으로 갱신했다. Math.min()과 Math.max()를 이용해 깔끔하게 최소,최대 좌표를 계산할 수 있었다. ✅ 잘한 점 불필요한 자료구조 없이 최소,최대 좌표만 추적하는 방식으로 효율적으로 구현…","fields":{"slug":"/archive/algorithm/10/"},"frontmatter":{"title":"[프로그래머스] 바탕화면 정리 Java","description":"바탕화면 정리 Java","date":"2025-05-23","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/138477 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 k길이 만큼 배열 생성 score 순회 - for문 이용 score값을 받아서 만든 배열 정렬 answer 배열에 k번째 값 저장 문제점 정렬을 매번 수행하면 시간복잡도가 올라간다. 시도2 접근 방법 우선순위 큐 생성 score 순회 - for문 이용 현재 점수를 우선순위 큐에 추가 큐의 길이가 k를 초과하면 가장 낮은 점수 제거 - poll() 현재 우선순위 큐에서 가장 낮은 점수를 answer에 저장 - peek() 소스 코드 3. 문제 회고 🔍 시도 처음에는 배열을 정렬하면 되지 않을까 생각하였으나 매번 정렬을 수행하면 시간복잡도에 문제가 있지 않을까 생각이 들었다. 🛠 해결 과정 우선순위 큐를 사용하여 항상 가장 낮은 점수를 유지하는 방식으로 문제를 해결했다. 큐에 점수를 …","fields":{"slug":"/archive/algorithm/9/"},"frontmatter":{"title":"[프로그래머스] 프로그래머스 명예의 전당1 Java","description":"명예의 전당1 Java","date":"2025-05-20","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/12915 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 strings 순회 - for문 이용 strings 정렬시 n번째 글자순으로 - Arrays.sort() 문제점 이렇게 하면 for문을 할 필요가 없어진다. 시도2 접근 방법 n번재 글자순으로 정렬되게 - Arrays.sort() 이용 Comparator를 재정의하여 n번재 글자를 비교 같으면 글자를 비교 => 시간복잡도 O(n log n) 소스 코드 3. 문제 회고 🔍 시도 처음에는 for문으로 순회하며 정렬을 직접 구현하려 했지만 Java의 Arrays.sort()와 Comparator를 활용하면 훨씬 간단하고 효율적으로 문제를 해결할 수 있음을 알게 되었다. 🛠 해결 과정 Comparator를 람다식을 이용해서 재정의하여 n번째 문자를 기준으로 정렬하고 만약 두 문자의 값이 같…","fields":{"slug":"/archive/algorithm/8/"},"frontmatter":{"title":"[프로그래머스] 프로그래머스 문자열 내 마음대로 정렬하기 Java","description":"문자열 내 마음대로 정렬하기 Java","date":"2025-05-19","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/67256 난이도 : Lv.1 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 문제의 설명대로 구현하였으며 2, 5, 8, 0과 같은 번호에 대해 거리를 계산해야 한다는 점을 고려하였다. 손의 위치를 갱신하며 각 번호의 거리 계산을 통해 더 가까운 손을 결정한다. 4방향 이동이 가능한 격자형 문제이므로 맨해튼 거리를 사용하여 두 손의 거리를 비교하였다. 맨해튼 거리(Manhattan Distance)란? 두 점 사이의 \"직선 거리\"가 아닌 격자 형태로 이동하는 거리를 나타내는 방식이다. 격자형 평면에서 두 점이 있을 때 각 점의 x 좌표와 y 좌표를 이용하여 이동하는 데 드는 최소 거리를 계산하는 방법을 말한다. 두 점 (x1, y1) , (x2, y2)가 있을때 맨해튼 거리는 다음과 같이 계산된다. x1-x2 + y1-y2 소스 코드 3. 문…","fields":{"slug":"/archive/algorithm/6/"},"frontmatter":{"title":"[프로그래머스] 프로그래머스 [카카오 인턴] 키패드 누르기 Java","description":"프로그래머스 [카카오 인턴] 키패드 누르기 Java","date":"2025-05-04","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}}]}},"pageContext":{"tag":"프로그래머스"}},"staticQueryHashes":[],"slicesMap":{}}