{"componentChunkName":"component---src-templates-tag-jsx","path":"/tags/코딩테스트/","result":{"data":{"allMarkdownRemark":{"totalCount":24,"nodes":[{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1138 난이도 : 실버2 2. 내 풀이 방법 시도1 접근 방법 입력 받기 index랑 사람수를 같이 저장할 클래스 선언 list에 넣기 사람수를 기준으로 오름차순 출력 문제점 단순 오름차순 정렬로는 사람 수 조건을 모두 만족하기 어렵다. 자리 배치를 하면서 현재 배열 상태를 고려해야 하기 때문에 이 방식은 논리적으로 성립하지 않음 정렬보다는 \"자리 찾기\" 방식으로 풀어야 한다. 시도2 접근 방법 입력 받기 결과를 저장할 배열 result 선언 N까지 반복 arr[i-1] → 왼쪽에 있어야 할 키 큰 사람 수 = peopleCnt result 배열에서 다음을 반복: 0(빈칸)을 만날 때마다 cnt 변수 값 증가 cnt와 peopleCnt이 같으면 빈칸 위치에 i번 사람을 배치 한번 배치하면 루프 종료 출력 소스 코드 3. 문제 회고 🔍 시도 처음에는 사람 번호와 왼쪽에 있어야 하는 사람 수를 …","fields":{"slug":"/archive/algorithm/24/"},"frontmatter":{"title":"[백준] 한 줄로 서기 Java","description":"한 줄로 서기 Java","date":"2025-06-12","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/42889 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 Stage 클래스 선언, Stage 타입의 List 선언 스테이지 개수 만큼 for문 수행 실패율 로직 처리 해당 index와 동일한 번호가 있으면 실패율 계산 없다면 도달한 유저가 없는것으로 실패율을 0으로 정의 list에 담기 list 정렬 실패율 내림차순 같으면 스테이지 오름차순 list -> int[] 변환 answer 반환 소스 코드 3. 문제 회고 🔍 시도 문제를 처음 읽고 대략적인 구현 방법은 금방 떠올랐다. 하지만 실패율 계산 로직과 정렬 기준 구현에서 조금 막혔다. 특히 실패율을 정확히 계산하고 이를 기준으로 스테이지 번호까지 고려하여 정렬하는 부분이 생각보다 까다로웠다. 🛠 해결 과정 실패율은 각 스테이지에 도달한 사용자 수를 기준으로 해당 스테이지를 클리어하지 못…","fields":{"slug":"/archive/algorithm/23/"},"frontmatter":{"title":"[프로그래머스] 실패율 Java","description":"실패율 Java","date":"2025-06-11","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/340199 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 minBill > minWallet 이거나 maxBill > maxWallet인 동안만 while문 반복 bill[0]과 bill[1]를 비교하여 큰 값을 2로 나누고 나머지를 버림 minBill, maxBill 값 갱신 answer 값 증가 answer 반환 소스 코드 3. 문제 회고 🔍 시도 문제 지문에 구현 방식이 친절하게 설명되어 있어 그대로 따라가며 구현하기만 하면 되는 문제였다. 🛠 해결 과정 반복문을 이용해 bill의 작은 값이 wallet의 작은 값 보다 크거나 bill의 큰 값이 wallet의 큰 값 보다 큰 동안 과정을 반복하면 된다. bill[0]이 bill[1]보다 크다면 bill[0]을 2로 나누고 그렇지 않다면 bill[1]을 2로 나누고 나머지는 버린다.…","fields":{"slug":"/archive/algorithm/22/"},"frontmatter":{"title":"[프로그래머스] [PCCE 기출문제] 9번 / 지폐 접기 Java","description":"[PCCE 기출문제] 9번 / 지폐 접기 Java","date":"2025-06-10","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/17681 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 문자열 연산을 많이 해야 하니 StringBuilder 사용 arr1, arr2를 순회 각 항목을 이진수로 변환 - Integer.toBinaryString 각 항목에 '1'이 하나라도 있으면 '#', 둘다 '0'이면 공백으로 표시 answer 반환 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 각 항목값을 비교하여 하나라도 1이면 '#', 둘 다 0이면 공백 ' '으로 표시하면 되겠다는 아이디어가 떠올랐다. 예제를 보며 예상한 방식이 정답과 일치하는지 확인했고 해당 흐름대로 구현하기로 결정했다. 🛠 해결 과정 arr1, arr2 배열을 순회하며 각 요소를 십진수에서 이진수로 변환하였다. 그 후 n자리로 자릿수를 맞춘 이진수 문자열을 char[]로 비교하여 각 자릿수에서 두 값이 …","fields":{"slug":"/archive/algorithm/21/"},"frontmatter":{"title":"[프로그래머스] [1차] 비밀지도 Java","description":"[1차] 비밀지도 Java","date":"2025-06-09","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/42586 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 process 라는 클래스를 생성, List 타입도 하나 생성 Stack 타입으로 생성하여 작업 진도와 개발 속도를 함께 체크 progresses 배열을 스택으로 변환 스택을 순회하면서 해당값이 100이 되면 pop() 그 다음값도 100이 되는지 체크 answer 반환 문제점 문제의 진행 순서는 앞에서부터 순서대로 처리되어야 하며 (후입선출)은 부적절하다. 선입선출(FIFO)에 해당하는 Queue 또는 일반 for 순회가 더 적절하다. 작업 완료 순서를 정확히 유지하기 어렵다. 불필요한 클래스 생성 및 자료구조 사용으로 복잡도 증가한다. 시도2 접근 방법 각 기능이 완료되기까지 걸리는 날짜 계산 - for문 로직 처리 첫 번째 작업의 완료일을 기준 - pivot 순회하며 pivot…","fields":{"slug":"/archive/algorithm/20/"},"frontmatter":{"title":"[프로그래머스] 기능 개발 Java","description":"기능 개발 Java","date":"2025-06-07","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/133502 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 ingredient 배열을 문자열(str)로 변환 로 치환이 될때마다 answer 증가 - while문 이용 answer 반환 문제점 테스트 케이스는 통과 하였으나 제출까지는 통과하지 못함 문자열 치환이 비효율적이다. String.replace(\"1231\", \"\")는 내부적으로 문자열 전체를 한 번 순회한다. → O(N) \"1231\"이 많다면 위 과정을 여러 번 반복한다. → O(N * \"1231\" 등장 횟수) 소스 코드 시도2 접근 방법 스택 생성 ingredient 배열을 순회 각 원소를 넣으면서 스택의 마지막 4개의 값이 1231인지 체크하여 맞으면 pop()을 4번 수행, answer 증가 answer 반환 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 \"1231\" 패턴을…","fields":{"slug":"/archive/algorithm/19/"},"frontmatter":{"title":"[프로그래머스] 햄버거 만들기 Java","description":"햄버거 만들기 Java","date":"2025-06-05","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/12909 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 스택 생성 문자열 를 char 배열로 변환해 순회 - for문 이용 로직 처리 스택이 비어있지 않고 현재 문자가 이고 스택의 top이 이면 pop() 그 외의 경우는 push() 스택이 비어 있으면 true 아니면 false를 반환 소스 코드 3. 문제 회고 🔍 시도 처음 문제를 읽고 나서 스택으로 접근하는 방식이 자연스럽게 떠올랐다. 괄호의 짝을 맞추는 전형적인 문제였기 때문이다. 🛠 해결 과정 처음에는 if-else 구조를 잘못 사용해서 결과가 잘못 나왔다. push()는 괄호의 짝이 맞지 않을 때 반드시 호출되어야 하는데 조건문 안에서만 처리하다 보니 예외가 발생했던 것이다. 나누었던 조건문을 하나로 합쳤더니 테스트 케이스를 모두 통과하였다. ✅ 잘한 점 스택 자료구조를 이용해…","fields":{"slug":"/archive/algorithm/18/"},"frontmatter":{"title":"[프로그래머스] 올바른 괄호 Java","description":"올바른 괄호 Java","date":"2025-06-04","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/42587 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 우선순위 큐 생성, index 변수 생성 우선순위 큐에 priorities 배열 담기 우선순위 큐를 순회하면서 index가 location과 같으면 break 다르면 answer 증가 answer 반환 문제점 우선순위 큐를 넣으면 순서가 달라진다. 시도2 접근 방법 큐 생성 큐에 priorities 배열 담기 로직 처리 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다. 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다. answer 반환 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 …","fields":{"slug":"/archive/algorithm/17/"},"frontmatter":{"title":"[프로그래머스] 프로세스 Java","description":"프로세스 Java","date":"2025-06-03","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/131704 난이도 : 레벨2 2. 내 풀이 방법 시도1 접근 방법 현재 박스 번호를 나타내는 nowBoxNum 변수, 보조 컨테이너 벨트 생성 - stack 이용 while문 이용 로직 처리 case1) 메인 컨테이너 벨트에서 박스를 꺼낼 수 있고 그 박스가 order[i]보다 작거나 같을 때 order와 현재 박스 번호가 같으면 트럭에 바로 싣고 다음 order로 이동 그렇지 않으면 보조 컨테이너 벨트에 보관하고 다음 박스로 이동 case2) 메인 벨트에서 꺼낼 수 없거나 order[i]가 현재보다 작은 경우 보조 컨테이너 벨트의 맨 위 박스가 실어야 할 박스면 트럭에 싣기 아니면 더 이상 실을 수 없으므로 종료 - break 위의 과정을 반복하며 order 배열의 끝까지 처리 소스 코드 3. 문제 회고 🔍 시도 보조 컨테이너 벨트을 보고 자연…","fields":{"slug":"/archive/algorithm/16/"},"frontmatter":{"title":"[프로그래머스] 택배 상자 Java","description":"택배 상자 Java","date":"2025-05-31","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/64061 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 바구니 생성 - 스택 이용 moves 배열을 순회 - for문 이용 각 항목을 순회하면서 해당 열에 맨 첫번째 값을 찾기 찾은값이 스택의 첫번째값이랑 같으면 pop() 아니면 push() answer return 소스 코드 3. 문제 회고 🔍 시도 처음 문제를 보고 인형을 하나씩 꺼내 바구니에 담는 구조가 스택과 유사하다고 판단했다. 그래서 바구니를 Stack으로 구현하고 인형이 두 개 연속으로 겹칠 경우 제거되는 로직을 중심으로 설계를 시작했다. 🛠 해결 과정 moves 배열을 순회하면서 각 열에서 인형을 하나씩 꺼낸다. 꺼낸 인형이 바구니의 맨 위 인형과 같으면 두 인형을 제거하고 answer를 추가한다. 그렇지 않으면 바구니에 인형을 넣는다. ✅ 잘한 점 문제를 보고 스택을 활…","fields":{"slug":"/archive/algorithm/15/"},"frontmatter":{"title":"[프로그래머스] 크레인 인형뽑기 게임 Java","description":"크레인 인형뽑기 게임 Java","date":"2025-05-28","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/150370 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 약관 정보(terms) 배열을 Map 형태로 변환 각 약관명을 key로 유효기간을 일단위로 환산한 값을 value로 하여 형태로 변환한다. 예) \"A 6\" => map.put(\"A\", 6 * 28); 개인정보 수집 내역(privacies) 배열 순회 - for문 이용 파기 대상 여부 판단 개인정보 수집일자를 LocalDate로 변환한다. 해당 항목의 약관 유형을 기준으로 유효기간을 더해 파기 예정일을 계산한다. 파기 예정일 = 개인정보 수집일 + 유효기간(일) - 1 오늘 날짜와 파기 예정일을 비교한다. - isBefore() 이용 answer return 문제점 테스트 케이스를 통과하지 못해서 파기예정일을 출력해보았더니 예제와 맞지 않았다. 문제처럼 \"모든 달이 28일\" 이라는 …","fields":{"slug":"/archive/algorithm/14/"},"frontmatter":{"title":"[프로그래머스] 개인정보 수집 유효기간 Java","description":"개인정보 수집 유효기간 Java","date":"2025-05-27","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/176963 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 name 배열과 yearning 배열을 기반으로 이름별 그리움 점수를 조회할 수 있도록 Map 형태로 변환 photo 배열을 순회 - for문 이용 이름이 map에 존재하는 경우 해당 점수를 더하고 존재하지 않으면 0을 더한다 - getOrDefault() answer 반환 소스 코드 3. 문제 회고 🔍 시도 문제를 처음 접했을 때  name 배열과 yearning 배열을 Map으로 변환하는 방식으로 하면 빠르게 풀 수 있을것같았다. 🛠 해결 과정 name과 yearning 배열을 순회하며 이름별 점수를  형태로 구성하였다. 각 photo마다 등장하는 이름들을 순회하면서 getOrDefault()로 점수를 누적하였고 사진별 총 점수를 answer 배열에 저장 후 반환하였다. ✅ 잘…","fields":{"slug":"/archive/algorithm/13/"},"frontmatter":{"title":"[프로그래머스] 추억점수 Java","description":"추억점수 Java","date":"2025-05-26","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/159994 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 cards1, cards2 배열을 큐로 변환 goal 배열 순회 - for문 이용 현재 단어가 queue1.peek()이면 queue1.poll() 아니고 queue2.peek()이면 queue2.poll() 둘 다 아니면 return \"No\" 끝까지 다 순회했다면 return \"Yes\" 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 는 조건과 는 조건에 주목했다. 이 조건을 보고 FIFO 구조인 Queue를 사용하면 적절하겠다고 판단했다. 🛠 해결 과정 cards1과 cards2를 각각 Queue로 변환한 후 goal 배열을 순차적으로 순회하며 각 단어가 어떤 큐의 맨 앞에 있는지 확인했다.\nqueue1.peek()과 queue2.peek()를 비교해서 일치하면 poll()로 …","fields":{"slug":"/archive/algorithm/12/"},"frontmatter":{"title":"[프로그래머스] 카드뭉치 Java","description":"카드뭉치 Java","date":"2025-05-25","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/136798 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 1부터 number까지 약수의 개수 구하기 number까지의 약수들 중 limit를 초과하는 값들은 power로 값 변경하여 합계 구하기 answer return 소스 코드 3. 문제 회고 🔍 시도 1부터 number까지 각 숫자의 약수 개수를 구한 후 그 개수가 limit을 초과하면 power로 대체하여 누적합(answer)을 계산하는 방식으로 문제를 해결하고자 했다. 🛠 해결 과정 약수 개수를 효율적으로 구하기 위해 제곱근까지만 순회하면서 중복 약수 계산을 방지하는 방식으로 calcCnt() 메서드를 구현했다. ✅ 잘한 점 문제의 구현 로직 자체는 복잡하지 않아 구조를 빠르게 설계할 수 있었고 약수 개수를 구할 때 중복을 방지하는 최적화도 잘 적용했다. ⚠ 개선할 점 초기 문제…","fields":{"slug":"/archive/algorithm/11/"},"frontmatter":{"title":"[프로그래머스] 기사단원의 무기 Java","description":"기사단원의 무기 Java","date":"2025-05-24","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/161990 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 wallpaper 순회 - for문 이용 lux, luy, rdx, rdy 값 갱신 answer 배열에 lux, luy, rdx, rdy 값 저장 소스 코드 3. 문제 회고 🔍 시도 처음에는 단순히 이차원 배열을 순회하면서 #의 위치를 파악하고자 했다. 좌표의 최소값, 최대값을 추적하는 방식으로 접근하면 된다는 생각이이 바로 떠올랐다. 🛠 해결 과정 각 줄을 char[]로 변환해 이중 반복문으로 탐색하며 # 문자의 좌표를 확인하고 그에 따라 lux, luy, rdx, rdy 값을 실시간으로 갱신했다. Math.min()과 Math.max()를 이용해 깔끔하게 최소,최대 좌표를 계산할 수 있었다. ✅ 잘한 점 불필요한 자료구조 없이 최소,최대 좌표만 추적하는 방식으로 효율적으로 구현…","fields":{"slug":"/archive/algorithm/10/"},"frontmatter":{"title":"[프로그래머스] 바탕화면 정리 Java","description":"바탕화면 정리 Java","date":"2025-05-23","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/138477 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 k길이 만큼 배열 생성 score 순회 - for문 이용 score값을 받아서 만든 배열 정렬 answer 배열에 k번째 값 저장 문제점 정렬을 매번 수행하면 시간복잡도가 올라간다. 시도2 접근 방법 우선순위 큐 생성 score 순회 - for문 이용 현재 점수를 우선순위 큐에 추가 큐의 길이가 k를 초과하면 가장 낮은 점수 제거 - poll() 현재 우선순위 큐에서 가장 낮은 점수를 answer에 저장 - peek() 소스 코드 3. 문제 회고 🔍 시도 처음에는 배열을 정렬하면 되지 않을까 생각하였으나 매번 정렬을 수행하면 시간복잡도에 문제가 있지 않을까 생각이 들었다. 🛠 해결 과정 우선순위 큐를 사용하여 항상 가장 낮은 점수를 유지하는 방식으로 문제를 해결했다. 큐에 점수를 …","fields":{"slug":"/archive/algorithm/9/"},"frontmatter":{"title":"[프로그래머스] 프로그래머스 명예의 전당1 Java","description":"명예의 전당1 Java","date":"2025-05-20","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/12915 난이도 : 레벨1 2. 내 풀이 방법 시도1 접근 방법 strings 순회 - for문 이용 strings 정렬시 n번째 글자순으로 - Arrays.sort() 문제점 이렇게 하면 for문을 할 필요가 없어진다. 시도2 접근 방법 n번재 글자순으로 정렬되게 - Arrays.sort() 이용 Comparator를 재정의하여 n번재 글자를 비교 같으면 글자를 비교 => 시간복잡도 O(n log n) 소스 코드 3. 문제 회고 🔍 시도 처음에는 for문으로 순회하며 정렬을 직접 구현하려 했지만 Java의 Arrays.sort()와 Comparator를 활용하면 훨씬 간단하고 효율적으로 문제를 해결할 수 있음을 알게 되었다. 🛠 해결 과정 Comparator를 람다식을 이용해서 재정의하여 n번째 문자를 기준으로 정렬하고 만약 두 문자의 값이 같…","fields":{"slug":"/archive/algorithm/8/"},"frontmatter":{"title":"[프로그래머스] 프로그래머스 문자열 내 마음대로 정렬하기 Java","description":"문자열 내 마음대로 정렬하기 Java","date":"2025-05-19","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11720 난이도 : 브론즈4 문제 내용 : N개의 숫자가 공백 없이 문자열 형태로 주어질 때 이 숫자들의 합을 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법  문자열을 한 글자씩 분리한 후 각 문자를 정수로 변환하여 합산한다. 문제점 정답은 맞지만 split()은 내부적으로 정규식을 사용하기 때문에 속도가 느리다. 소스 코드 시도2 접근 방법  String.toCharArray()로 문자 배열을 만든 뒤 각 문자를 '0'과의 차이로 정수로 변환하여 합산한다. 문제점 char 배열을 복사해서 반환하기 때문에 String.charAt() 보다 속도가 느리다. 시도3 접근 방법  charAt(i)을 사용하여 각 문자를 직접 접근하고 '0'을 빼서 정수로 변환한다. 별도의 배열을 만들지 않기 때문에 가장 빠른 방식이다. 각 방법들 성능 비교 위에 시도한 방법들은 모두 제출시 정답이다. 하지…","fields":{"slug":"/archive/algorithm/7/"},"frontmatter":{"title":"[BOJ] 백준 11720 숫자의 합 Java","description":"백준 11720 숫자의 합 Java","date":"2025-05-07","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://school.programmers.co.kr/learn/courses/30/lessons/67256 난이도 : Lv.1 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 문제의 설명대로 구현하였으며 2, 5, 8, 0과 같은 번호에 대해 거리를 계산해야 한다는 점을 고려하였다. 손의 위치를 갱신하며 각 번호의 거리 계산을 통해 더 가까운 손을 결정한다. 4방향 이동이 가능한 격자형 문제이므로 맨해튼 거리를 사용하여 두 손의 거리를 비교하였다. 맨해튼 거리(Manhattan Distance)란? 두 점 사이의 \"직선 거리\"가 아닌 격자 형태로 이동하는 거리를 나타내는 방식이다. 격자형 평면에서 두 점이 있을 때 각 점의 x 좌표와 y 좌표를 이용하여 이동하는 데 드는 최소 거리를 계산하는 방법을 말한다. 두 점 (x1, y1) , (x2, y2)가 있을때 맨해튼 거리는 다음과 같이 계산된다. x1-x2 + y1-y2 소스 코드 3. 문…","fields":{"slug":"/archive/algorithm/6/"},"frontmatter":{"title":"[프로그래머스] 프로그래머스 [카카오 인턴] 키패드 누르기 Java","description":"프로그래머스 [카카오 인턴] 키패드 누르기 Java","date":"2025-05-04","tags":["Algorithm","프로그래머스","코딩테스트"],"series":"프로그래머스","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/9095 난이도 : 실버3 문제 내용 :  이 주어졌을 때, 정수 1, 2, 3을 더해서 을 만드는 모든 방법의 수를 구하는 문제이다. 순서가 다른 경우는 다른 방법으로 취급한다. 2. 내 풀이 방법 시도1 접근 방법 DP (Dynamic Programming) 이용하였다. 점화식 계산 방법 n 방법의 개수 1 1 2 1+1, 2 => 2 3 1+1+1, 1+2, 2+1 => 3 4 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1 => 7 = 4 + 2 + 1 5 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+1+3, 1+2+1+1, 1+2+2, 1+3+1,2+1+1+1, 2+1+2, 2+2+1, 2+3, 3+1+1, 3+2 => 13 = 7 + 4 + 2 소스 코드 3. 문제 회고 🔍 시도 1,2,3을 이용해서 n을 만들어야 한다는 문제의 조건을 보고 …","fields":{"slug":"/archive/algorithm/4/"},"frontmatter":{"title":"[BOJ] 백준 9095 1, 2, 3 더하기 Java","description":"백준 9095 1, 2, 3 더하기 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1912 난이도 : 실버2 문제 내용 : 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구한다. 단, 수는 한 개 이상 선택해야 한다. 2. 내 풀이 방법 시도1 접근 방법 완전탐색(= 브루트포스)를 이용하였다. 문제점 완전탐색의 시간복잡도는  이다. n = 100,000이라면 O(n²) → 10⁵ * 10⁵ → 100억 × 100억 = 1조 연산을 하게 되며 1초에 약 1억 연산 가능하기 때문에 시간 초과가 발생한다. 소스 코드 시도2 접근 방법 누적합 기법을 이용하였다. 계산 방법 i arr sum max 1 -4 max(-4, 10 + (-4)) = max(-4, 6) = 6 max(10, 6) = 10 2 3 max(3, 6 + 3) = max(3, 9) = 9 max(10, 9) = 10 3 1 max(1, 9 + 1) = 10 max(10, 10) = 10 4 5…","fields":{"slug":"/archive/algorithm/5/"},"frontmatter":{"title":"[BOJ] 백준 1912 연속합 Java","description":"백준 1912 연속합 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/2805 난이도 : 실버2 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 이분탐색 방법을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제에 맞는 알고리즘을 생각하지 못하였다. 🛠 해결 과정 문제 유형을 참고하여 이분 탐색 알고리즘을 적용해야 한다는 것을 알게 되었고 이를 기반으로 문제를 해결할 수 있었다. ✅ 잘한 점 ⚠ 개선할 점 이분 탐색 유형 문제를 많이 풀어봐야겠다. 참조","fields":{"slug":"/archive/algorithm/3/"},"frontmatter":{"title":"[BOJ] 백준 2805 나무 자르기 Java","description":"백준 2805 나무 자르기 Java","date":"2025-04-27","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1012 난이도 : 실버2 문제 내용 : 배추가 심어진 곳끼리 연결되어 있으면 하나의 \"덩어리\"로 보고 총 몇 개의 덩어리가 있는지 세는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 BFS 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 BFS 알고리즘과 4방향 탐색(상하좌우)이 필요하다고 빠르게 판단했다.\n 위치에서만 BFS 탐색을 시도했다. 🛠 해결 과정 만 탐색하면 전체 영역을 탐색하지 못하는 문제를 발견했다.\n이후 배열 전체를 순회하며 방문하지 않은 영역마다 BFS를 수행하는 방식으로 접근을 수정했다. ✅ 잘한 점 문제를 읽자마자 BFS로 해결해야 한다는 판단을 빠르게 내렸다.\nDFS/BFS 문제를 여러 번 풀어본 경험이 도움이 되었다. ⚠ 개선할 점 BFS + 4방향 탐색까진 좋았지만 \"전체 배열을 순회하며 시작점을 찾아야 한다\"는 기본적인 접근을 처음부터 …","fields":{"slug":"/archive/algorithm/1/"},"frontmatter":{"title":"[BOJ] 백준 1012 유기농 배추 Java","description":"백준 1012 유기농 배추 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11053 난이도 : 실버2 문제 내용 : 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 TreeSet에 이용해서 중복제거 + 정렬을 하였다. 문제점 TreeSet에 넣어서 중복제거 + 정렬하고 input.size 를 출력하고 있는데\n이건 서로 다른 수의 개수를 구하는 것이지 문제의 핵심인 가장 긴 증가하는 부분 수열을 구하게 아니다. 소스 코드 시도2 접근 방법 DP 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 처음에는 TreeSet을 사용해서 정렬과 중복 제거를 통해 문제를 풀려고 했지만 이는 문제의 의도와 맞지 않았다.\n문제 밑에 있는 알고리즘의 분류를 보고 동적 계획법(DP)을 이용해서 풀었다. 🛠 해결 과정 dp[i] = i번째 숫자를 마지막으로 했을 때의 LIS 길이라고 정의하고 i번째 수를 기준으로 0부터 i-1까지 순회…","fields":{"slug":"/archive/algorithm/2/"},"frontmatter":{"title":"[BOJ] 백준 11053 가장 긴 증가하는 부분 수열 Java","description":"백준 11053 가장 긴 증가하는 부분 수열 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png","isPrivate":false}}]}},"pageContext":{"tag":"코딩테스트"}},"staticQueryHashes":[],"slicesMap":{}}