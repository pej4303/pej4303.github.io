{"componentChunkName":"component---src-templates-series-jsx","path":"/series/백준/","result":{"data":{"allMarkdownRemark":{"totalCount":13,"nodes":[{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/1697 난이도 : 실버1 소요시간 : 31분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 방문배열 만들기 bfs으로 탐색 출력 소스 코드 3. 🔍 문제 회고 문제을 읽고 가장 빠른 시간이 몇 초 후인지 구하는 문제여서 bfs문제라고 생각이 들었다. 방문배열과 큐에 넣을때 어떤 자료구조로 해야될까 고민을 많이 하였다. 방문배열은 범위에 맞는 0 ~ 100000까지만 하면 되니까 int 배열로 선언하였고, 큐에는 현재 위치와 시간을 같이 넣어야 되어서 int 배열로 선언하였다. 핵심 로직인 \"다음에 탐색할 위치를 어떻게 정의하고 큐에 넣을지\" 에서 약간의 막힘이 있었지만\n결국 현재 위치에서 -1, +1, *2의 세 가지 이동을 모두 시도하면서 방문하지 않은 위치만 큐에 넣으면 된다는 단순한 원리였다. 📚 참조","fields":{"slug":"/archive/algorithm/31/"},"frontmatter":{"title":"[백준] 숨바꼭질 Java","description":"숨바꼭질 Java","date":"2025-07-12","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/1932 난이도 : 실버1 소요시간 : 30분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 DP 테이블 생성 DP 처리 출력 소스 코드 3. 🔍 문제 회고 문제을 읽고 다이나믹 프로그래밍 문제라고 생각했다. dp 점화식을 떠오르지 않아서 검색에 의존했다. 문제를 처음 보았을 때 단순 탐색으로는 비효율적일 것 같아 다이나믹 프로그래밍(DP)으로 접근해야 한다고 판단했다.\n아래로 내려오면서 최댓값을 누적해서 계산해야 했고 이를 위해 이전 계산 결과를 기반으로 다음 값을 구할 수 있는 점화식을 도출하는 것이 핵심 과제였다. DP 테이블을 2배열로 선언하고 각 위치에서 올 수 있는 경로를 고려하여 최댓값을 누적하는 방식으로 점화식을 완성했다. 삼각형의 양쪽 끝은 경로가 하나이므로 예외 처리를 통해 처리하였다. 점화식이 완성된 이후에는 구현은 수월하게 이루어졌고, 정답을 맞출 수 있었다.\n다만, …","fields":{"slug":"/archive/algorithm/30/"},"frontmatter":{"title":"[백준] 정수 삼각형 Java","description":"정수 삼각형 Java","date":"2025-07-09","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/1149 난이도 : 실버1 소요시간 : 50분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 DP 테이블 생성 DP 처리 출력 소스 코드 3. 🔍 문제 회고 \"모든 집을 칠하되 총 비용이 최소가 되도록 하라\"는 조건과 인접한 집을 같은 색으로 칠할 수 없는 제약이 있는 문제였다. 단순히 모든 경우를 시도하기엔 집의 수가 많아질수록 계산량이 폭발적으로 늘어날 수 있다는 점에서 효율적인 접근이 필요했다. 각 집을 어떤 색으로 칠할지를 결정하면서 인접한 집과 색이 겹치지 않도록 하고 전체 칠하는 비용의 합이 최소가 되도록 해야 했다. 문제를 처음 접했을 때는 어떻게 풀어야 할지 감이 오지 않아 검색에 의존했다. 이후에 색상과 집 번호라는 두 가지 상태를 기준으로 2차원 DP 테이블을 만들고 이전 집의 색에 따라 현재 집의 최소 비용을 계산하는 점화식을 세워 문제를 해결했다. DP의 개념을 코드에…","fields":{"slug":"/archive/algorithm/29/"},"frontmatter":{"title":"[백준] RGB거리 Java","description":"RGB거리 Java","date":"2025-07-05","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/2667 난이도 : 실버1 소요시간 : 40분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 BFS 탐색 오름차순으로 정렬 출력 소스 코드 3. 🔍 문제 회고 문제에서 '1'로 연결된 영역의 개수와 각 영역의 크기를 구하는 전형적인 탐색 문제였다. BFS를 사용하여 지도 상의 연결된 단지를 탐색하고 각 단지에 포함된 집의 수를 구해 오름차순으로 출력하는 것이 목표였다. 를 사용한 을 구현하려고 했다. 하지만 평소에 자주 사용하지 않았던 BFS 코드가 잘 기억나지 않아 구현에 시간이 오래 걸렸다. 탐색한 집의 수를 list에 담아 정렬 후 출력하였다. 전형적인 BFS 유형의 문제였지만 익숙하지 않아 구현에 시간이 많이 소요되었고 결국 제한 시간을 초과해 아쉬운 결과를 얻게 되었다. BFS 로직에 대한 기억이 흐릿했던 점이 원인이었고 BFS 기본 패턴을 다시 복습할 필요성을 느꼈다. 그리고 입…","fields":{"slug":"/archive/algorithm/28/"},"frontmatter":{"title":"[백준] 단지번호붙이기 Java","description":"단지번호붙이기 Java","date":"2025-06-23","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/10819 난이도 : 실버2 소요시간 : 35분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 DFS를 이용해서 순열 만들기 완전탐색 최댓값 찾기 출력 소스 코드 3. 🔍 문제 회고 입력된 숫자의 개수가 최대 8개라는 점을 보고 완전탐색이 가능하다고 판단했다. 하지만 배열의 숫자들을 어떤 순서로 나열해서 조합을 만들지 고민하던 중 검색을 통해 DFS를 이용해서 모든 가능한 순서를 만들 수 있다는 사실을 알게 되었다. 이 문제는 주어진 숫자들을 한 번씩만 사용해 인접한 수들의 차이의 총합이 가장 큰 순서를 찾는 것이 목표였다. DFS를 활용하여 숫자들을 한 번씩만 사용해 만들 수 있는 모든 순서를 생성했고 각 순서에 대해 인접한 숫자들의 차이를 모두 더한 후 Math.max()를 이용해 최댓값을 갱신했다. 문제는 무리 없이 해결했지만 숫자를 나열하는 방식에 대해 처음부터 스스로 끝까지 시도해…","fields":{"slug":"/archive/algorithm/27/"},"frontmatter":{"title":"[백준] 차이를 최대로 Java","description":"차이를 최대로 Java","date":"2025-06-21","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/2304 난이도 : 실버2 소요시간 : 50분 2. 💡 내 풀이 방법 시도1 접근 방법 입력 L, H를 클래스로 리스트에 저장 L 기준 정렬 최대 높이의 인덱스 찾기 로직 처리 왼쪽 → 중앙까지 현재 높이가 최대높이보다 크면 면적구하기 오른쪽 → 중앙까지 면적 계산 최대 높이 기둥 면적 추가 출력 소스 코드 3. 🔍 문제 회고 문제를 처음 접했을 때 막대들이 이루는 전체 면적을 단순히 나누어 계산하는 방식으로 접근했다. 하지만 그렇게 하기보다는 가장 높은 막대를 기준으로 왼쪽과 오른쪽을 나눠서 면적을 계산하는 것이 더 효율적이라는 점을 파악할 수 있었다. 이 문제는 주어진 좌표(L)와 높이(H)를 이용해 복잡하지 않게 전체 면적을 계산해야 하는 과제였다. 먼저 L과 H를 라는 클래스로 별도로 분리하여 리스트 타입으로 입력을 받았다. 계산하기 쉽게 L 기준으로 정렬을 해준 기준점이 되는 다음…","fields":{"slug":"/archive/algorithm/26/"},"frontmatter":{"title":"[백준] 창고 다각형 Java","description":"창고 다각형 Java","date":"2025-06-14","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 📝 문제 요약 문제 URL : https://www.acmicpc.net/problem/1138 난이도 : 실버2 2. 💡 내 풀이 방법 시도1 접근 방법 입력 받기 index랑 사람수를 같이 저장할 클래스 선언 list에 넣기 사람수를 기준으로 오름차순 출력 문제점 단순 오름차순 정렬로는 사람 수 조건을 모두 만족하기 어렵다. 자리 배치를 하면서 현재 배열 상태를 고려해야 하기 때문에 이 방식은 논리적으로 성립하지 않음 정렬보다는 \"자리 찾기\" 방식으로 풀어야 한다. 시도2 접근 방법 입력 받기 결과를 저장할 배열 result 선언 N까지 반복 arr[i-1] → 왼쪽에 있어야 할 키 큰 사람 수 = peopleCnt result 배열에서 다음을 반복: 0(빈칸)을 만날 때마다 cnt 변수 값 증가 cnt와 peopleCnt이 같으면 빈칸 위치에 i번 사람을 배치 한번 배치하면 루프 종료 출력 소스 코드 3. 🔍 문제 회고 처음에는 사람 번호와 왼쪽에 있어야 할 사람 수를 …","fields":{"slug":"/archive/algorithm/24/"},"frontmatter":{"title":"[백준] 한 줄로 서기 Java","description":"한 줄로 서기 Java","date":"2025-06-12","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11720 난이도 : 브론즈4 문제 내용 : N개의 숫자가 공백 없이 문자열 형태로 주어질 때 이 숫자들의 합을 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법  문자열을 한 글자씩 분리한 후 각 문자를 정수로 변환하여 합산한다. 문제점 정답은 맞지만 split()은 내부적으로 정규식을 사용하기 때문에 속도가 느리다. 소스 코드 시도2 접근 방법  String.toCharArray()로 문자 배열을 만든 뒤 각 문자를 '0'과의 차이로 정수로 변환하여 합산한다. 문제점 char 배열을 복사해서 반환하기 때문에 String.charAt() 보다 속도가 느리다. 시도3 접근 방법  charAt(i)을 사용하여 각 문자를 직접 접근하고 '0'을 빼서 정수로 변환한다. 별도의 배열을 만들지 않기 때문에 가장 빠른 방식이다. 각 방법들 성능 비교 위에 시도한 방법들은 모두 제출시 정답이다. 하지…","fields":{"slug":"/archive/algorithm/7/"},"frontmatter":{"title":"[BOJ] 백준 11720 숫자의 합 Java","description":"백준 11720 숫자의 합 Java","date":"2025-05-07","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1912 난이도 : 실버2 문제 내용 : 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구한다. 단, 수는 한 개 이상 선택해야 한다. 2. 내 풀이 방법 시도1 접근 방법 완전탐색(= 브루트포스)를 이용하였다. 문제점 완전탐색의 시간복잡도는  이다. n = 100,000이라면 O(n²) → 10⁵ * 10⁵ → 100억 × 100억 = 1조 연산을 하게 되며 1초에 약 1억 연산 가능하기 때문에 시간 초과가 발생한다. 소스 코드 시도2 접근 방법 누적합 기법을 이용하였다. 계산 방법 i arr sum max 1 -4 max(-4, 10 + (-4)) = max(-4, 6) = 6 max(10, 6) = 10 2 3 max(3, 6 + 3) = max(3, 9) = 9 max(10, 9) = 10 3 1 max(1, 9 + 1) = 10 max(10, 10) = 10 4 5…","fields":{"slug":"/archive/algorithm/5/"},"frontmatter":{"title":"[BOJ] 백준 1912 연속합 Java","description":"백준 1912 연속합 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/9095 난이도 : 실버3 문제 내용 :  이 주어졌을 때, 정수 1, 2, 3을 더해서 을 만드는 모든 방법의 수를 구하는 문제이다. 순서가 다른 경우는 다른 방법으로 취급한다. 2. 내 풀이 방법 시도1 접근 방법 DP (Dynamic Programming) 이용하였다. 점화식 계산 방법 n 방법의 개수 1 1 2 1+1, 2 => 2 3 1+1+1, 1+2, 2+1 => 3 4 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1 => 7 = 4 + 2 + 1 5 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+1+3, 1+2+1+1, 1+2+2, 1+3+1,2+1+1+1, 2+1+2, 2+2+1, 2+3, 3+1+1, 3+2 => 13 = 7 + 4 + 2 소스 코드 3. 문제 회고 🔍 시도 1,2,3을 이용해서 n을 만들어야 한다는 문제의 조건을 보고 …","fields":{"slug":"/archive/algorithm/4/"},"frontmatter":{"title":"[BOJ] 백준 9095 1, 2, 3 더하기 Java","description":"백준 9095 1, 2, 3 더하기 Java","date":"2025-05-02","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/2805 난이도 : 실버2 문제 내용 : 2. 내 풀이 방법 시도1 접근 방법 이분탐색 방법을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제에 맞는 알고리즘을 생각하지 못하였다. 🛠 해결 과정 문제 유형을 참고하여 이분 탐색 알고리즘을 적용해야 한다는 것을 알게 되었고 이를 기반으로 문제를 해결할 수 있었다. ✅ 잘한 점 ⚠ 개선할 점 이분 탐색 유형 문제를 많이 풀어봐야겠다. 참조","fields":{"slug":"/archive/algorithm/3/"},"frontmatter":{"title":"[BOJ] 백준 2805 나무 자르기 Java","description":"백준 2805 나무 자르기 Java","date":"2025-04-27","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/1012 난이도 : 실버2 문제 내용 : 배추가 심어진 곳끼리 연결되어 있으면 하나의 \"덩어리\"로 보고 총 몇 개의 덩어리가 있는지 세는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 BFS 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 문제를 읽고 BFS 알고리즘과 4방향 탐색(상하좌우)이 필요하다고 빠르게 판단했다.\n 위치에서만 BFS 탐색을 시도했다. 🛠 해결 과정 만 탐색하면 전체 영역을 탐색하지 못하는 문제를 발견했다.\n이후 배열 전체를 순회하며 방문하지 않은 영역마다 BFS를 수행하는 방식으로 접근을 수정했다. ✅ 잘한 점 문제를 읽자마자 BFS로 해결해야 한다는 판단을 빠르게 내렸다.\nDFS/BFS 문제를 여러 번 풀어본 경험이 도움이 되었다. ⚠ 개선할 점 BFS + 4방향 탐색까진 좋았지만 \"전체 배열을 순회하며 시작점을 찾아야 한다\"는 기본적인 접근을 처음부터 …","fields":{"slug":"/archive/algorithm/1/"},"frontmatter":{"title":"[BOJ] 백준 1012 유기농 배추 Java","description":"백준 1012 유기농 배추 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}},{"excerpt":"1. 문제 요약 문제 URL : https://www.acmicpc.net/problem/11053 난이도 : 실버2 문제 내용 : 가장 긴 증가하는 부분 수열의 길이를 구하는 문제이다. 2. 내 풀이 방법 시도1 접근 방법 TreeSet에 이용해서 중복제거 + 정렬을 하였다. 문제점 TreeSet에 넣어서 중복제거 + 정렬하고 input.size 를 출력하고 있는데\n이건 서로 다른 수의 개수를 구하는 것이지 문제의 핵심인 가장 긴 증가하는 부분 수열을 구하게 아니다. 소스 코드 시도2 접근 방법 DP 알고리즘을 이용하였다. 소스 코드 3. 문제 회고 🔍 시도 처음에는 TreeSet을 사용해서 정렬과 중복 제거를 통해 문제를 풀려고 했지만 이는 문제의 의도와 맞지 않았다.\n문제 밑에 있는 알고리즘의 분류를 보고 동적 계획법(DP)을 이용해서 풀었다. 🛠 해결 과정 dp[i] = i번째 숫자를 마지막으로 했을 때의 LIS 길이라고 정의하고 i번째 수를 기준으로 0부터 i-1까지 순회…","fields":{"slug":"/archive/algorithm/2/"},"frontmatter":{"title":"[BOJ] 백준 11053 가장 긴 증가하는 부분 수열 Java","description":"백준 11053 가장 긴 증가하는 부분 수열 Java","date":"2025-04-26","tags":["Algorithm","백준","코딩테스트"],"series":"백준","previewImage":"writing.png"}}]}},"pageContext":{"series":"백준"}},"staticQueryHashes":[],"slicesMap":{}}